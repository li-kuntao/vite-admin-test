/**
 * @licstart The following is the entire license notice for the
 * JavaScript code in this page
 *
 * Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * JavaScript code in this page
 */
!(function webpackUniversalModuleDefinition(e, t) {
  typeof exports === 'object' && typeof module === 'object'
    ? (module.exports = t())
    : typeof define === 'function' && define.amd
    ? define('pdfjs-dist/build/pdf', [], t)
    : typeof exports === 'object'
    ? (exports['pdfjs-dist/build/pdf'] = t())
    : (e['pdfjs-dist/build/pdf'] = e.pdfjsLib = t())
})(globalThis, () =>
  (() => {
    const __webpack_modules__ = [
      ,
      (e, t, i) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.VerbosityLevel =
          t.Util =
          t.UnknownErrorException =
          t.UnexpectedResponseException =
          t.UNSUPPORTED_FEATURES =
          t.TextRenderingMode =
          t.StreamType =
          t.RenderingIntentFlag =
          t.PermissionFlag =
          t.PasswordResponses =
          t.PasswordException =
          t.PageActionEventType =
          t.OPS =
          t.MissingPDFException =
          t.LINE_FACTOR =
          t.LINE_DESCENT_FACTOR =
          t.InvalidPDFException =
          t.ImageKind =
          t.IDENTITY_MATRIX =
          t.FormatError =
          t.FontType =
          t.FeatureTest =
          t.FONT_IDENTITY_MATRIX =
          t.DocumentActionEventType =
          t.CMapCompressionType =
          t.BaseException =
          t.AnnotationType =
          t.AnnotationStateModelType =
          t.AnnotationReviewState =
          t.AnnotationReplyType =
          t.AnnotationMode =
          t.AnnotationMarkedState =
          t.AnnotationFlag =
          t.AnnotationFieldFlag =
          t.AnnotationEditorType =
          t.AnnotationEditorPrefix =
          t.AnnotationEditorParamsType =
          t.AnnotationBorderStyleType =
          t.AnnotationActionEventType =
          t.AbortException =
            void 0
        t.arrayByteLength = arrayByteLength
        t.arraysToBytes = function arraysToBytes(e) {
          const t = e.length
          if (t === 1 && e[0] instanceof Uint8Array) return e[0]
          let i = 0
          for (let n = 0; n < t; n++) i += arrayByteLength(e[n])
          let n = 0
          const s = new Uint8Array(i)
          for (let i = 0; i < t; i++) {
            let t = e[i]
            t instanceof Uint8Array ||
              (t = typeof t === 'string' ? stringToBytes(t) : new Uint8Array(t))
            const a = t.byteLength
            s.set(t, n)
            n += a
          }
          return s
        }
        t.assert = function assert(e, t) {
          e || unreachable(t)
        }
        t.bytesToString = function bytesToString(e) {
          ;(typeof e === 'object' && e !== null && void 0 !== e.length) ||
            unreachable('Invalid argument for bytesToString')
          const t = e.length
          const i = 8192
          if (t < i) return String.fromCharCode.apply(null, e)
          const n = []
          for (let s = 0; s < t; s += i) {
            const a = Math.min(s + i, t)
            const r = e.subarray(s, a)
            n.push(String.fromCharCode.apply(null, r))
          }
          return n.join('')
        }
        t.createPromiseCapability = function createPromiseCapability() {
          const e = Object.create(null)
          let t = !1
          Object.defineProperty(e, 'settled', { get: () => t })
          e.promise = new Promise(function (i, n) {
            e.resolve = function (e) {
              t = !0
              i(e)
            }
            e.reject = function (e) {
              t = !0
              n(e)
            }
          })
          return e
        }
        t.createValidAbsoluteUrl = function createValidAbsoluteUrl(e) {
          const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
          const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
          if (!e) return null
          try {
            if (i && typeof e === 'string') {
              if (i.addDefaultProtocol && e.startsWith('www.')) {
                const t = e.match(/\./g)
                t && t.length >= 2 && (e = `http://${e}`)
              }
              if (i.tryConvertEncoding)
                try {
                  e = stringToUTF8String(e)
                } catch (e) {}
            }
            const n = t ? new URL(e, t) : new URL(e)
            if (_isValidProtocol(n)) return n
          } catch (e) {}
          return null
        }
        t.escapeString = function escapeString(e) {
          return e.replace(/([()\\\n\r])/g, (e) =>
            e === '\n' ? '\\n' : e === '\r' ? '\\r' : `\\${e}`
          )
        }
        t.getModificationDate = function getModificationDate() {
          const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Date()
          const t = [
            e.getUTCFullYear().toString(),
            (e.getUTCMonth() + 1).toString().padStart(2, '0'),
            e.getUTCDate().toString().padStart(2, '0'),
            e.getUTCHours().toString().padStart(2, '0'),
            e.getUTCMinutes().toString().padStart(2, '0'),
            e.getUTCSeconds().toString().padStart(2, '0')
          ]
          return t.join('')
        }
        t.getVerbosityLevel = function getVerbosityLevel() {
          return s
        }
        t.info = function info(e) {
          s >= n.INFOS && console.log(`Info: ${e}`)
        }
        t.isArrayBuffer = function isArrayBuffer(e) {
          return typeof e === 'object' && e !== null && void 0 !== e.byteLength
        }
        t.isArrayEqual = function isArrayEqual(e, t) {
          if (e.length !== t.length) return !1
          for (let i = 0, n = e.length; i < n; i++) if (e[i] !== t[i]) return !1
          return !0
        }
        t.isAscii = function isAscii(e) {
          return /^[\x00-\x7F]*$/.test(e)
        }
        t.isNum = function isNum(e) {
          return typeof e === 'number'
        }
        t.objectFromMap = function objectFromMap(e) {
          const t = Object.create(null)
          for (const [i, n] of e) t[i] = n
          return t
        }
        t.objectSize = function objectSize(e) {
          return Object.keys(e).length
        }
        t.setVerbosityLevel = function setVerbosityLevel(e) {
          Number.isInteger(e) && (s = e)
        }
        t.shadow = shadow
        t.string32 = function string32(e) {
          return String.fromCharCode((e >> 24) & 255, (e >> 16) & 255, (e >> 8) & 255, 255 & e)
        }
        t.stringToBytes = stringToBytes
        t.stringToPDFString = function stringToPDFString(e) {
          if (e[0] >= 'ï') {
            let t
            e[0] === 'þ' && e[1] === 'ÿ'
              ? (t = 'utf-16be')
              : e[0] === 'ÿ' && e[1] === 'þ'
              ? (t = 'utf-16le')
              : e[0] === 'ï' && e[1] === '»' && e[2] === '¿' && (t = 'utf-8')
            if (t)
              try {
                const i = new TextDecoder(t, { fatal: !0 })
                const n = stringToBytes(e)
                return i.decode(n)
              } catch (e) {
                warn(`stringToPDFString: "${e}".`)
              }
          }
          const t = []
          for (let i = 0, n = e.length; i < n; i++) {
            const n = o[e.charCodeAt(i)]
            t.push(n ? String.fromCharCode(n) : e.charAt(i))
          }
          return t.join('')
        }
        t.stringToUTF16BEString = function stringToUTF16BEString(e) {
          const t = ['þÿ']
          for (let i = 0, n = e.length; i < n; i++) {
            const n = e.charCodeAt(i)
            t.push(String.fromCharCode((n >> 8) & 255), String.fromCharCode(255 & n))
          }
          return t.join('')
        }
        t.stringToUTF8String = stringToUTF8String
        t.unreachable = unreachable
        t.utf8StringToString = function utf8StringToString(e) {
          return unescape(encodeURIComponent(e))
        }
        t.warn = warn
        i(2)
        t.IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0]
        t.FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0]
        t.LINE_FACTOR = 1.35
        t.LINE_DESCENT_FACTOR = 0.35
        t.RenderingIntentFlag = {
          ANY: 1,
          DISPLAY: 2,
          PRINT: 4,
          ANNOTATIONS_FORMS: 16,
          ANNOTATIONS_STORAGE: 32,
          ANNOTATIONS_DISABLE: 64,
          OPLIST: 256
        }
        t.AnnotationMode = { DISABLE: 0, ENABLE: 1, ENABLE_FORMS: 2, ENABLE_STORAGE: 3 }
        t.AnnotationEditorPrefix = 'pdfjs_internal_editor_'
        t.AnnotationEditorType = { DISABLE: -1, NONE: 0, FREETEXT: 3, INK: 15 }
        t.AnnotationEditorParamsType = {
          FREETEXT_SIZE: 1,
          FREETEXT_COLOR: 2,
          FREETEXT_OPACITY: 3,
          INK_COLOR: 11,
          INK_THICKNESS: 12,
          INK_OPACITY: 13
        }
        t.PermissionFlag = {
          PRINT: 4,
          MODIFY_CONTENTS: 8,
          COPY: 16,
          MODIFY_ANNOTATIONS: 32,
          FILL_INTERACTIVE_FORMS: 256,
          COPY_FOR_ACCESSIBILITY: 512,
          ASSEMBLE: 1024,
          PRINT_HIGH_QUALITY: 2048
        }
        t.TextRenderingMode = {
          FILL: 0,
          STROKE: 1,
          FILL_STROKE: 2,
          INVISIBLE: 3,
          FILL_ADD_TO_PATH: 4,
          STROKE_ADD_TO_PATH: 5,
          FILL_STROKE_ADD_TO_PATH: 6,
          ADD_TO_PATH: 7,
          FILL_STROKE_MASK: 3,
          ADD_TO_PATH_FLAG: 4
        }
        t.ImageKind = { GRAYSCALE_1BPP: 1, RGB_24BPP: 2, RGBA_32BPP: 3 }
        t.AnnotationType = {
          TEXT: 1,
          LINK: 2,
          FREETEXT: 3,
          LINE: 4,
          SQUARE: 5,
          CIRCLE: 6,
          POLYGON: 7,
          POLYLINE: 8,
          HIGHLIGHT: 9,
          UNDERLINE: 10,
          SQUIGGLY: 11,
          STRIKEOUT: 12,
          STAMP: 13,
          CARET: 14,
          INK: 15,
          POPUP: 16,
          FILEATTACHMENT: 17,
          SOUND: 18,
          MOVIE: 19,
          WIDGET: 20,
          SCREEN: 21,
          PRINTERMARK: 22,
          TRAPNET: 23,
          WATERMARK: 24,
          THREED: 25,
          REDACT: 26
        }
        t.AnnotationStateModelType = { MARKED: 'Marked', REVIEW: 'Review' }
        t.AnnotationMarkedState = { MARKED: 'Marked', UNMARKED: 'Unmarked' }
        t.AnnotationReviewState = {
          ACCEPTED: 'Accepted',
          REJECTED: 'Rejected',
          CANCELLED: 'Cancelled',
          COMPLETED: 'Completed',
          NONE: 'None'
        }
        t.AnnotationReplyType = { GROUP: 'Group', REPLY: 'R' }
        t.AnnotationFlag = {
          INVISIBLE: 1,
          HIDDEN: 2,
          PRINT: 4,
          NOZOOM: 8,
          NOROTATE: 16,
          NOVIEW: 32,
          READONLY: 64,
          LOCKED: 128,
          TOGGLENOVIEW: 256,
          LOCKEDCONTENTS: 512
        }
        t.AnnotationFieldFlag = {
          READONLY: 1,
          REQUIRED: 2,
          NOEXPORT: 4,
          MULTILINE: 4096,
          PASSWORD: 8192,
          NOTOGGLETOOFF: 16384,
          RADIO: 32768,
          PUSHBUTTON: 65536,
          COMBO: 131072,
          EDIT: 262144,
          SORT: 524288,
          FILESELECT: 1048576,
          MULTISELECT: 2097152,
          DONOTSPELLCHECK: 4194304,
          DONOTSCROLL: 8388608,
          COMB: 16777216,
          RICHTEXT: 33554432,
          RADIOSINUNISON: 33554432,
          COMMITONSELCHANGE: 67108864
        }
        t.AnnotationBorderStyleType = { SOLID: 1, DASHED: 2, BEVELED: 3, INSET: 4, UNDERLINE: 5 }
        t.AnnotationActionEventType = {
          E: 'Mouse Enter',
          X: 'Mouse Exit',
          D: 'Mouse Down',
          U: 'Mouse Up',
          Fo: 'Focus',
          Bl: 'Blur',
          PO: 'PageOpen',
          PC: 'PageClose',
          PV: 'PageVisible',
          PI: 'PageInvisible',
          K: 'Keystroke',
          F: 'Format',
          V: 'Validate',
          C: 'Calculate'
        }
        t.DocumentActionEventType = {
          WC: 'WillClose',
          WS: 'WillSave',
          DS: 'DidSave',
          WP: 'WillPrint',
          DP: 'DidPrint'
        }
        t.PageActionEventType = { O: 'PageOpen', C: 'PageClose' }
        t.StreamType = {
          UNKNOWN: 'UNKNOWN',
          FLATE: 'FLATE',
          LZW: 'LZW',
          DCT: 'DCT',
          JPX: 'JPX',
          JBIG: 'JBIG',
          A85: 'A85',
          AHX: 'AHX',
          CCF: 'CCF',
          RLX: 'RLX'
        }
        t.FontType = {
          UNKNOWN: 'UNKNOWN',
          TYPE1: 'TYPE1',
          TYPE1STANDARD: 'TYPE1STANDARD',
          TYPE1C: 'TYPE1C',
          CIDFONTTYPE0: 'CIDFONTTYPE0',
          CIDFONTTYPE0C: 'CIDFONTTYPE0C',
          TRUETYPE: 'TRUETYPE',
          CIDFONTTYPE2: 'CIDFONTTYPE2',
          TYPE3: 'TYPE3',
          OPENTYPE: 'OPENTYPE',
          TYPE0: 'TYPE0',
          MMTYPE1: 'MMTYPE1'
        }
        const n = { ERRORS: 0, WARNINGS: 1, INFOS: 5 }
        t.VerbosityLevel = n
        t.CMapCompressionType = { NONE: 0, BINARY: 1, STREAM: 2 }
        t.OPS = {
          dependency: 1,
          setLineWidth: 2,
          setLineCap: 3,
          setLineJoin: 4,
          setMiterLimit: 5,
          setDash: 6,
          setRenderingIntent: 7,
          setFlatness: 8,
          setGState: 9,
          save: 10,
          restore: 11,
          transform: 12,
          moveTo: 13,
          lineTo: 14,
          curveTo: 15,
          curveTo2: 16,
          curveTo3: 17,
          closePath: 18,
          rectangle: 19,
          stroke: 20,
          closeStroke: 21,
          fill: 22,
          eoFill: 23,
          fillStroke: 24,
          eoFillStroke: 25,
          closeFillStroke: 26,
          closeEOFillStroke: 27,
          endPath: 28,
          clip: 29,
          eoClip: 30,
          beginText: 31,
          endText: 32,
          setCharSpacing: 33,
          setWordSpacing: 34,
          setHScale: 35,
          setLeading: 36,
          setFont: 37,
          setTextRenderingMode: 38,
          setTextRise: 39,
          moveText: 40,
          setLeadingMoveText: 41,
          setTextMatrix: 42,
          nextLine: 43,
          showText: 44,
          showSpacedText: 45,
          nextLineShowText: 46,
          nextLineSetSpacingShowText: 47,
          setCharWidth: 48,
          setCharWidthAndBounds: 49,
          setStrokeColorSpace: 50,
          setFillColorSpace: 51,
          setStrokeColor: 52,
          setStrokeColorN: 53,
          setFillColor: 54,
          setFillColorN: 55,
          setStrokeGray: 56,
          setFillGray: 57,
          setStrokeRGBColor: 58,
          setFillRGBColor: 59,
          setStrokeCMYKColor: 60,
          setFillCMYKColor: 61,
          shadingFill: 62,
          beginInlineImage: 63,
          beginImageData: 64,
          endInlineImage: 65,
          paintXObject: 66,
          markPoint: 67,
          markPointProps: 68,
          beginMarkedContent: 69,
          beginMarkedContentProps: 70,
          endMarkedContent: 71,
          beginCompat: 72,
          endCompat: 73,
          paintFormXObjectBegin: 74,
          paintFormXObjectEnd: 75,
          beginGroup: 76,
          endGroup: 77,
          beginAnnotations: 78,
          endAnnotations: 79,
          beginAnnotation: 80,
          endAnnotation: 81,
          paintJpegXObject: 82,
          paintImageMaskXObject: 83,
          paintImageMaskXObjectGroup: 84,
          paintImageXObject: 85,
          paintInlineImageXObject: 86,
          paintInlineImageXObjectGroup: 87,
          paintImageXObjectRepeat: 88,
          paintImageMaskXObjectRepeat: 89,
          paintSolidColorImageMask: 90,
          constructPath: 91
        }
        t.UNSUPPORTED_FEATURES = {
          unknown: 'unknown',
          forms: 'forms',
          javaScript: 'javaScript',
          signatures: 'signatures',
          smask: 'smask',
          shadingPattern: 'shadingPattern',
          font: 'font',
          errorTilingPattern: 'errorTilingPattern',
          errorExtGState: 'errorExtGState',
          errorXObject: 'errorXObject',
          errorFontLoadType3: 'errorFontLoadType3',
          errorFontState: 'errorFontState',
          errorFontMissing: 'errorFontMissing',
          errorFontTranslate: 'errorFontTranslate',
          errorColorSpace: 'errorColorSpace',
          errorOperatorList: 'errorOperatorList',
          errorFontToUnicode: 'errorFontToUnicode',
          errorFontLoadNative: 'errorFontLoadNative',
          errorFontBuildPath: 'errorFontBuildPath',
          errorFontGetPath: 'errorFontGetPath',
          errorMarkedContent: 'errorMarkedContent',
          errorContentSubStream: 'errorContentSubStream'
        }
        t.PasswordResponses = { NEED_PASSWORD: 1, INCORRECT_PASSWORD: 2 }
        let s = n.WARNINGS
        function warn(e) {
          s >= n.WARNINGS && console.log(`Warning: ${e}`)
        }
        function unreachable(e) {
          throw new Error(e)
        }
        function _isValidProtocol(e) {
          if (!e) return !1
          switch (e.protocol) {
            case 'http:':
            case 'https:':
            case 'ftp:':
            case 'mailto:':
            case 'tel:':
              return !0
            default:
              return !1
          }
        }
        function shadow(e, t, i) {
          Object.defineProperty(e, t, {
            value: i,
            enumerable: !0,
            configurable: !0,
            writable: !1
          })
          return i
        }
        const a = (function BaseExceptionClosure() {
          function BaseException(e, t) {
            this.constructor === BaseException && unreachable('Cannot initialize BaseException.')
            this.message = e
            this.name = t
          }
          BaseException.prototype = new Error()
          BaseException.constructor = BaseException
          return BaseException
        })()
        t.BaseException = a
        t.PasswordException = class PasswordException extends a {
          constructor(e, t) {
            super(e, 'PasswordException')
            this.code = t
          }
        }
        t.UnknownErrorException = class UnknownErrorException extends a {
          constructor(e, t) {
            super(e, 'UnknownErrorException')
            this.details = t
          }
        }
        t.InvalidPDFException = class InvalidPDFException extends a {
          constructor(e) {
            super(e, 'InvalidPDFException')
          }
        }
        t.MissingPDFException = class MissingPDFException extends a {
          constructor(e) {
            super(e, 'MissingPDFException')
          }
        }
        t.UnexpectedResponseException = class UnexpectedResponseException extends a {
          constructor(e, t) {
            super(e, 'UnexpectedResponseException')
            this.status = t
          }
        }
        t.FormatError = class FormatError extends a {
          constructor(e) {
            super(e, 'FormatError')
          }
        }
        t.AbortException = class AbortException extends a {
          constructor(e) {
            super(e, 'AbortException')
          }
        }
        function stringToBytes(e) {
          typeof e !== 'string' && unreachable('Invalid argument for stringToBytes')
          const t = e.length
          const i = new Uint8Array(t)
          for (let n = 0; n < t; ++n) i[n] = 255 & e.charCodeAt(n)
          return i
        }
        function arrayByteLength(e) {
          if (void 0 !== e.length) return e.length
          if (void 0 !== e.byteLength) return e.byteLength
          unreachable('Invalid argument for arrayByteLength')
        }
        t.FeatureTest = class FeatureTest {
          static get isLittleEndian() {
            return shadow(
              this,
              'isLittleEndian',
              (function isLittleEndian() {
                const e = new Uint8Array(4)
                e[0] = 1
                return new Uint32Array(e.buffer, 0, 1)[0] === 1
              })()
            )
          }

          static get isEvalSupported() {
            return shadow(
              this,
              'isEvalSupported',
              (function isEvalSupported() {
                try {
                  new Function('')
                  return !0
                } catch (e) {
                  return !1
                }
              })()
            )
          }

          static get isOffscreenCanvasSupported() {
            return shadow(
              this,
              'isOffscreenCanvasSupported',
              typeof OffscreenCanvas !== 'undefined'
            )
          }
        }
        const r = [...Array(256).keys()].map((e) => e.toString(16).padStart(2, '0'))
        class Util {
          static makeHexColor(e, t, i) {
            return `#${r[e]}${r[t]}${r[i]}`
          }

          static scaleMinMax(e, t) {
            let i
            if (e[0]) {
              if (e[0] < 0) {
                i = t[0]
                t[0] = t[1]
                t[1] = i
              }
              t[0] *= e[0]
              t[1] *= e[0]
              if (e[3] < 0) {
                i = t[2]
                t[2] = t[3]
                t[3] = i
              }
              t[2] *= e[3]
              t[3] *= e[3]
            } else {
              i = t[0]
              t[0] = t[2]
              t[2] = i
              i = t[1]
              t[1] = t[3]
              t[3] = i
              if (e[1] < 0) {
                i = t[2]
                t[2] = t[3]
                t[3] = i
              }
              t[2] *= e[1]
              t[3] *= e[1]
              if (e[2] < 0) {
                i = t[0]
                t[0] = t[1]
                t[1] = i
              }
              t[0] *= e[2]
              t[1] *= e[2]
            }
            t[0] += e[4]
            t[1] += e[4]
            t[2] += e[5]
            t[3] += e[5]
          }

          static transform(e, t) {
            return [
              e[0] * t[0] + e[2] * t[1],
              e[1] * t[0] + e[3] * t[1],
              e[0] * t[2] + e[2] * t[3],
              e[1] * t[2] + e[3] * t[3],
              e[0] * t[4] + e[2] * t[5] + e[4],
              e[1] * t[4] + e[3] * t[5] + e[5]
            ]
          }

          static applyTransform(e, t) {
            return [e[0] * t[0] + e[1] * t[2] + t[4], e[0] * t[1] + e[1] * t[3] + t[5]]
          }

          static applyInverseTransform(e, t) {
            const i = t[0] * t[3] - t[1] * t[2]
            return [
              (e[0] * t[3] - e[1] * t[2] + t[2] * t[5] - t[4] * t[3]) / i,
              (-e[0] * t[1] + e[1] * t[0] + t[4] * t[1] - t[5] * t[0]) / i
            ]
          }

          static getAxialAlignedBoundingBox(e, t) {
            const i = Util.applyTransform(e, t)
            const n = Util.applyTransform(e.slice(2, 4), t)
            const s = Util.applyTransform([e[0], e[3]], t)
            const a = Util.applyTransform([e[2], e[1]], t)
            return [
              Math.min(i[0], n[0], s[0], a[0]),
              Math.min(i[1], n[1], s[1], a[1]),
              Math.max(i[0], n[0], s[0], a[0]),
              Math.max(i[1], n[1], s[1], a[1])
            ]
          }

          static inverseTransform(e) {
            const t = e[0] * e[3] - e[1] * e[2]
            return [
              e[3] / t,
              -e[1] / t,
              -e[2] / t,
              e[0] / t,
              (e[2] * e[5] - e[4] * e[3]) / t,
              (e[4] * e[1] - e[5] * e[0]) / t
            ]
          }

          static apply3dTransform(e, t) {
            return [
              e[0] * t[0] + e[1] * t[1] + e[2] * t[2],
              e[3] * t[0] + e[4] * t[1] + e[5] * t[2],
              e[6] * t[0] + e[7] * t[1] + e[8] * t[2]
            ]
          }

          static singularValueDecompose2dScale(e) {
            const t = [e[0], e[2], e[1], e[3]]
            const i = e[0] * t[0] + e[1] * t[2]
            const n = e[0] * t[1] + e[1] * t[3]
            const s = e[2] * t[0] + e[3] * t[2]
            const a = e[2] * t[1] + e[3] * t[3]
            const r = (i + a) / 2
            const o = Math.sqrt((i + a) ** 2 - 4 * (i * a - s * n)) / 2
            const l = r + o || 1
            const c = r - o || 1
            return [Math.sqrt(l), Math.sqrt(c)]
          }

          static normalizeRect(e) {
            const t = e.slice(0)
            if (e[0] > e[2]) {
              t[0] = e[2]
              t[2] = e[0]
            }
            if (e[1] > e[3]) {
              t[1] = e[3]
              t[3] = e[1]
            }
            return t
          }

          static intersect(e, t) {
            const i = Math.max(Math.min(e[0], e[2]), Math.min(t[0], t[2]))
            const n = Math.min(Math.max(e[0], e[2]), Math.max(t[0], t[2]))
            if (i > n) return null
            const s = Math.max(Math.min(e[1], e[3]), Math.min(t[1], t[3]))
            const a = Math.min(Math.max(e[1], e[3]), Math.max(t[1], t[3]))
            return s > a ? null : [i, s, n, a]
          }

          static bezierBoundingBox(e, t, i, n, s, a, r, o) {
            const l = []
            const c = [[], []]
            let d
            let h
            let u
            let p
            let g
            let f
            let m
            let v
            for (let c = 0; c < 2; ++c) {
              if (c === 0) {
                h = 6 * e - 12 * i + 6 * s
                d = -3 * e + 9 * i - 9 * s + 3 * r
                u = 3 * i - 3 * e
              } else {
                h = 6 * t - 12 * n + 6 * a
                d = -3 * t + 9 * n - 9 * a + 3 * o
                u = 3 * n - 3 * t
              }
              if (Math.abs(d) < 1e-12) {
                if (Math.abs(h) < 1e-12) continue
                p = -u / h
                p > 0 && p < 1 && l.push(p)
              } else {
                m = h * h - 4 * u * d
                v = Math.sqrt(m)
                if (!(m < 0)) {
                  g = (-h + v) / (2 * d)
                  g > 0 && g < 1 && l.push(g)
                  f = (-h - v) / (2 * d)
                  f > 0 && f < 1 && l.push(f)
                }
              }
            }
            let _
            let b = l.length
            const w = b
            for (; b--; ) {
              p = l[b]
              _ = 1 - p
              c[0][b] = _ * _ * _ * e + 3 * _ * _ * p * i + 3 * _ * p * p * s + p * p * p * r
              c[1][b] = _ * _ * _ * t + 3 * _ * _ * p * n + 3 * _ * p * p * a + p * p * p * o
            }
            c[0][w] = e
            c[1][w] = t
            c[0][w + 1] = r
            c[1][w + 1] = o
            c[0].length = c[1].length = w + 2
            return [Math.min(...c[0]), Math.min(...c[1]), Math.max(...c[0]), Math.max(...c[1])]
          }
        }
        t.Util = Util
        const o = [
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710,
          729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260,
          8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338,
          352, 376, 381, 305, 322, 339, 353, 382, 0, 8364
        ]
        function stringToUTF8String(e) {
          return decodeURIComponent(escape(e))
        }
      },
      (e, t, i) => {
        const n = i(3)
        if (!globalThis._pdfjsCompatibilityChecked) {
          globalThis._pdfjsCompatibilityChecked = !0
          !(function checkNodeBtoa() {
            !globalThis.btoa &&
              n.isNodeJS &&
              (globalThis.btoa = function (e) {
                return Buffer.from(e, 'binary').toString('base64')
              })
          })()
          !(function checkNodeAtob() {
            !globalThis.atob &&
              n.isNodeJS &&
              (globalThis.atob = function (e) {
                return Buffer.from(e, 'base64').toString('binary')
              })
          })()
          !(function checkDOMMatrix() {
            !globalThis.DOMMatrix &&
              n.isNodeJS &&
              (globalThis.DOMMatrix = require('dommatrix/dist/dommatrix.js'))
          })()
          !(function checkReadableStream() {
            !globalThis.ReadableStream &&
              n.isNodeJS &&
              (globalThis.ReadableStream =
                require('web-streams-polyfill/dist/ponyfill.js').ReadableStream)
          })()
          !(function checkArrayAt() {
            Array.prototype.at || i(4)
          })()
          !(function checkTypedArrayAt() {
            Uint8Array.prototype.at || i(76)
          })()
          !(function checkStructuredClone() {
            globalThis.structuredClone || i(86)
          })()
        }
      },
      (e, t) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.isNodeJS = void 0
        const i = !(
          typeof process !== 'object' ||
          `${process}` != '[object process]' ||
          process.versions.nw ||
          (process.versions.electron && process.type && process.type !== 'browser')
        )
        t.isNodeJS = i
      },
      (e, t, i) => {
        i(5)
        const n = i(75)
        e.exports = n('Array', 'at')
      },
      (e, t, i) => {
        const n = i(6)
        const s = i(41)
        const a = i(65)
        const r = i(63)
        const o = i(70)
        n(
          { target: 'Array', proto: !0 },
          {
            at: function at(e) {
              const t = s(this)
              const i = a(t)
              const n = r(e)
              const o = n >= 0 ? n : i + n
              return o < 0 || o >= i ? void 0 : t[o]
            }
          }
        )
        o('at')
      },
      (e, t, i) => {
        const n = i(7)
        const s = i(8).f
        const a = i(45)
        const r = i(49)
        const o = i(39)
        const l = i(57)
        const c = i(69)
        e.exports = function (e, t) {
          let i
          let d
          let h
          let u
          let p
          const g = e.target
          const f = e.global
          const m = e.stat
          if ((i = f ? n : m ? n[g] || o(g, {}) : (n[g] || {}).prototype))
            for (d in t) {
              u = t[d]
              h = e.dontCallGetSet ? (p = s(i, d)) && p.value : i[d]
              if (!c(f ? d : g + (m ? '.' : '#') + d, e.forced) && void 0 !== h) {
                if (typeof u === typeof h) continue
                l(u, h)
              }
              ;(e.sham || (h && h.sham)) && a(u, 'sham', !0)
              r(i, d, u, e)
            }
        }
      },
      (e) => {
        const check = function (e) {
          return e && e.Math == Math && e
        }
        e.exports =
          check(typeof globalThis === 'object' && globalThis) ||
          check(typeof window === 'object' && window) ||
          check(typeof self === 'object' && self) ||
          check(typeof global === 'object' && global) ||
          (function () {
            return this
          })() ||
          Function('return this')()
      },
      (e, t, i) => {
        const n = i(9)
        const s = i(11)
        const a = i(13)
        const r = i(14)
        const o = i(15)
        const l = i(20)
        const c = i(40)
        const d = i(43)
        const h = Object.getOwnPropertyDescriptor
        t.f = n
          ? h
          : function getOwnPropertyDescriptor(e, t) {
              e = o(e)
              t = l(t)
              if (d)
                try {
                  return h(e, t)
                } catch (e) {}
              if (c(e, t)) return r(!s(a.f, e, t), e[t])
            }
      },
      (e, t, i) => {
        const n = i(10)
        e.exports = !n(function () {
          return (
            Object.defineProperty({}, 1, {
              get() {
                return 7
              }
            })[1] != 7
          )
        })
      },
      (e) => {
        e.exports = function (e) {
          try {
            return !!e()
          } catch (e) {
            return !0
          }
        }
      },
      (e, t, i) => {
        const n = i(12)
        const s = Function.prototype.call
        e.exports = n
          ? s.bind(s)
          : function () {
              return s.apply(s, arguments)
            }
      },
      (e, t, i) => {
        const n = i(10)
        e.exports = !n(function () {
          const e = function () {}.bind()
          return typeof e !== 'function' || e.hasOwnProperty('prototype')
        })
      },
      (e, t) => {
        const i = {}.propertyIsEnumerable
        const n = Object.getOwnPropertyDescriptor
        const s = n && !i.call({ 1: 2 }, 1)
        t.f = s
          ? function propertyIsEnumerable(e) {
              const t = n(this, e)
              return !!t && t.enumerable
            }
          : i
      },
      (e) => {
        e.exports = function (e, t) {
          return { enumerable: !(1 & e), configurable: !(2 & e), writable: !(4 & e), value: t }
        }
      },
      (e, t, i) => {
        const n = i(16)
        const s = i(19)
        e.exports = function (e) {
          return n(s(e))
        }
      },
      (e, t, i) => {
        const n = i(17)
        const s = i(10)
        const a = i(18)
        const r = Object
        const o = n(''.split)
        e.exports = s(function () {
          return !r('z').propertyIsEnumerable(0)
        })
          ? function (e) {
              return a(e) == 'String' ? o(e, '') : r(e)
            }
          : r
      },
      (e, t, i) => {
        const n = i(12)
        const s = Function.prototype
        const a = s.bind
        const r = s.call
        const o = n && a.bind(r, r)
        e.exports = n
          ? function (e) {
              return e && o(e)
            }
          : function (e) {
              return (
                e &&
                function () {
                  return r.apply(e, arguments)
                }
              )
            }
      },
      (e, t, i) => {
        const n = i(17)
        const s = n({}.toString)
        const a = n(''.slice)
        e.exports = function (e) {
          return a(s(e), 8, -1)
        }
      },
      (e) => {
        const t = TypeError
        e.exports = function (e) {
          if (e == null) throw t(`Can't call method on ${e}`)
          return e
        }
      },
      (e, t, i) => {
        const n = i(21)
        const s = i(24)
        e.exports = function (e) {
          const t = n(e, 'string')
          return s(t) ? t : `${t}`
        }
      },
      (e, t, i) => {
        const n = i(11)
        const s = i(22)
        const a = i(24)
        const r = i(31)
        const o = i(34)
        const l = i(35)
        const c = TypeError
        const d = l('toPrimitive')
        e.exports = function (e, t) {
          if (!s(e) || a(e)) return e
          let i
          const l = r(e, d)
          if (l) {
            void 0 === t && (t = 'default')
            i = n(l, e, t)
            if (!s(i) || a(i)) return i
            throw c("Can't convert object to primitive value")
          }
          void 0 === t && (t = 'number')
          return o(e, t)
        }
      },
      (e, t, i) => {
        const n = i(23)
        e.exports = function (e) {
          return typeof e === 'object' ? e !== null : n(e)
        }
      },
      (e) => {
        e.exports = function (e) {
          return typeof e === 'function'
        }
      },
      (e, t, i) => {
        const n = i(25)
        const s = i(23)
        const a = i(26)
        const r = i(27)
        const o = Object
        e.exports = r
          ? function (e) {
              return typeof e === 'symbol'
            }
          : function (e) {
              const t = n('Symbol')
              return s(t) && a(t.prototype, o(e))
            }
      },
      (e, t, i) => {
        const n = i(7)
        const s = i(23)
        const aFunction = function (e) {
          return s(e) ? e : void 0
        }
        e.exports = function (e, t) {
          return arguments.length < 2 ? aFunction(n[e]) : n[e] && n[e][t]
        }
      },
      (e, t, i) => {
        const n = i(17)
        e.exports = n({}.isPrototypeOf)
      },
      (e, t, i) => {
        const n = i(28)
        e.exports = n && !Symbol.sham && typeof Symbol.iterator === 'symbol'
      },
      (e, t, i) => {
        const n = i(29)
        const s = i(10)
        e.exports =
          !!Object.getOwnPropertySymbols &&
          !s(function () {
            const e = Symbol()
            return !String(e) || !(Object(e) instanceof Symbol) || (!Symbol.sham && n && n < 41)
          })
      },
      (e, t, i) => {
        let n
        let s
        const a = i(7)
        const r = i(30)
        const o = a.process
        const l = a.Deno
        const c = (o && o.versions) || (l && l.version)
        const d = c && c.v8
        d && (s = (n = d.split('.'))[0] > 0 && n[0] < 4 ? 1 : +(n[0] + n[1]))
        !s &&
          r &&
          (!(n = r.match(/Edge\/(\d+)/)) || n[1] >= 74) &&
          (n = r.match(/Chrome\/(\d+)/)) &&
          (s = +n[1])
        e.exports = s
      },
      (e, t, i) => {
        const n = i(25)
        e.exports = n('navigator', 'userAgent') || ''
      },
      (e, t, i) => {
        const n = i(32)
        e.exports = function (e, t) {
          const i = e[t]
          return i == null ? void 0 : n(i)
        }
      },
      (e, t, i) => {
        const n = i(23)
        const s = i(33)
        const a = TypeError
        e.exports = function (e) {
          if (n(e)) return e
          throw a(`${s(e)} is not a function`)
        }
      },
      (e) => {
        const t = String
        e.exports = function (e) {
          try {
            return t(e)
          } catch (e) {
            return 'Object'
          }
        }
      },
      (e, t, i) => {
        const n = i(11)
        const s = i(23)
        const a = i(22)
        const r = TypeError
        e.exports = function (e, t) {
          let i
          let o
          if (t === 'string' && s((i = e.toString)) && !a((o = n(i, e)))) return o
          if (s((i = e.valueOf)) && !a((o = n(i, e)))) return o
          if (t !== 'string' && s((i = e.toString)) && !a((o = n(i, e)))) return o
          throw r("Can't convert object to primitive value")
        }
      },
      (e, t, i) => {
        const n = i(7)
        const s = i(36)
        const a = i(40)
        const r = i(42)
        const o = i(28)
        const l = i(27)
        const c = s('wks')
        const d = n.Symbol
        const h = d && d.for
        const u = l ? d : (d && d.withoutSetter) || r
        e.exports = function (e) {
          if (!a(c, e) || (!o && typeof c[e] !== 'string')) {
            const t = `Symbol.${e}`
            o && a(d, e) ? (c[e] = d[e]) : (c[e] = l && h ? h(t) : u(t))
          }
          return c[e]
        }
      },
      (e, t, i) => {
        const n = i(37)
        const s = i(38)
        ;(e.exports = function (e, t) {
          return s[e] || (s[e] = void 0 !== t ? t : {})
        })('versions', []).push({
          version: '3.24.1',
          mode: n ? 'pure' : 'global',
          copyright: '© 2014-2022 Denis Pushkarev (zloirock.ru)',
          license: 'https://github.com/zloirock/core-js/blob/v3.24.1/LICENSE',
          source: 'https://github.com/zloirock/core-js'
        })
      },
      (e) => {
        e.exports = !1
      },
      (e, t, i) => {
        const n = i(7)
        const s = i(39)
        const a = '__core-js_shared__'
        const r = n[a] || s(a, {})
        e.exports = r
      },
      (e, t, i) => {
        const n = i(7)
        const s = Object.defineProperty
        e.exports = function (e, t) {
          try {
            s(n, e, { value: t, configurable: !0, writable: !0 })
          } catch (i) {
            n[e] = t
          }
          return t
        }
      },
      (e, t, i) => {
        const n = i(17)
        const s = i(41)
        const a = n({}.hasOwnProperty)
        e.exports =
          Object.hasOwn ||
          function hasOwn(e, t) {
            return a(s(e), t)
          }
      },
      (e, t, i) => {
        const n = i(19)
        const s = Object
        e.exports = function (e) {
          return s(n(e))
        }
      },
      (e, t, i) => {
        const n = i(17)
        let s = 0
        const a = Math.random()
        const r = n((1).toString)
        e.exports = function (e) {
          return `Symbol(${void 0 === e ? '' : e})_${r(++s + a, 36)}`
        }
      },
      (e, t, i) => {
        const n = i(9)
        const s = i(10)
        const a = i(44)
        e.exports =
          !n &&
          !s(function () {
            return (
              Object.defineProperty(a('div'), 'a', {
                get() {
                  return 7
                }
              }).a != 7
            )
          })
      },
      (e, t, i) => {
        const n = i(7)
        const s = i(22)
        const a = n.document
        const r = s(a) && s(a.createElement)
        e.exports = function (e) {
          return r ? a.createElement(e) : {}
        }
      },
      (e, t, i) => {
        const n = i(9)
        const s = i(46)
        const a = i(14)
        e.exports = n
          ? function (e, t, i) {
              return s.f(e, t, a(1, i))
            }
          : function (e, t, i) {
              e[t] = i
              return e
            }
      },
      (e, t, i) => {
        const n = i(9)
        const s = i(43)
        const a = i(47)
        const r = i(48)
        const o = i(20)
        const l = TypeError
        const c = Object.defineProperty
        const d = Object.getOwnPropertyDescriptor
        const h = 'enumerable'
        const u = 'configurable'
        const p = 'writable'
        t.f = n
          ? a
            ? function defineProperty(e, t, i) {
                r(e)
                t = o(t)
                r(i)
                if (
                  typeof e === 'function' &&
                  t === 'prototype' &&
                  'value' in i &&
                  p in i &&
                  !i.writable
                ) {
                  const n = d(e, t)
                  if (n && n.writable) {
                    e[t] = i.value
                    i = {
                      configurable: u in i ? i.configurable : n.configurable,
                      enumerable: h in i ? i.enumerable : n.enumerable,
                      writable: !1
                    }
                  }
                }
                return c(e, t, i)
              }
            : c
          : function defineProperty(e, t, i) {
              r(e)
              t = o(t)
              r(i)
              if (s)
                try {
                  return c(e, t, i)
                } catch (e) {}
              if ('get' in i || 'set' in i) throw l('Accessors not supported')
              'value' in i && (e[t] = i.value)
              return e
            }
      },
      (e, t, i) => {
        const n = i(9)
        const s = i(10)
        e.exports =
          n &&
          s(function () {
            return (
              Object.defineProperty(function () {}, 'prototype', { value: 42, writable: !1 })
                .prototype != 42
            )
          })
      },
      (e, t, i) => {
        const n = i(22)
        const s = String
        const a = TypeError
        e.exports = function (e) {
          if (n(e)) return e
          throw a(`${s(e)} is not an object`)
        }
      },
      (e, t, i) => {
        const n = i(23)
        const s = i(46)
        const a = i(50)
        const r = i(39)
        e.exports = function (e, t, i, o) {
          o || (o = {})
          let l = o.enumerable
          const c = void 0 !== o.name ? o.name : t
          n(i) && a(i, c, o)
          if (o.global) l ? (e[t] = i) : r(t, i)
          else {
            try {
              o.unsafe ? e[t] && (l = !0) : delete e[t]
            } catch (e) {}
            l
              ? (e[t] = i)
              : s.f(e, t, {
                  value: i,
                  enumerable: !1,
                  configurable: !o.nonConfigurable,
                  writable: !o.nonWritable
                })
          }
          return e
        }
      },
      (e, t, i) => {
        const n = i(10)
        const s = i(23)
        const a = i(40)
        const r = i(9)
        const o = i(51).CONFIGURABLE
        const l = i(52)
        const c = i(53)
        const d = c.enforce
        const h = c.get
        const u = Object.defineProperty
        const p =
          r &&
          !n(function () {
            return u(function () {}, 'length', { value: 8 }).length !== 8
          })
        const g = String(String).split('String')
        const f = (e.exports = function (e, t, i) {
          String(t).slice(0, 7) === 'Symbol(' &&
            (t = `[${String(t).replace(/^Symbol\(([^)]*)\)/, '$1')}]`)
          i && i.getter && (t = `get ${t}`)
          i && i.setter && (t = `set ${t}`)
          ;(!a(e, 'name') || (o && e.name !== t)) &&
            (r ? u(e, 'name', { value: t, configurable: !0 }) : (e.name = t))
          p && i && a(i, 'arity') && e.length !== i.arity && u(e, 'length', { value: i.arity })
          try {
            i && a(i, 'constructor') && i.constructor
              ? r && u(e, 'prototype', { writable: !1 })
              : e.prototype && (e.prototype = void 0)
          } catch (e) {}
          const n = d(e)
          a(n, 'source') || (n.source = g.join(typeof t === 'string' ? t : ''))
          return e
        })
        Function.prototype.toString = f(function toString() {
          return (s(this) && h(this).source) || l(this)
        }, 'toString')
      },
      (e, t, i) => {
        const n = i(9)
        const s = i(40)
        const a = Function.prototype
        const r = n && Object.getOwnPropertyDescriptor
        const o = s(a, 'name')
        const l = o && function something() {}.name === 'something'
        const c = o && (!n || (n && r(a, 'name').configurable))
        e.exports = { EXISTS: o, PROPER: l, CONFIGURABLE: c }
      },
      (e, t, i) => {
        const n = i(17)
        const s = i(23)
        const a = i(38)
        const r = n(Function.toString)
        s(a.inspectSource) ||
          (a.inspectSource = function (e) {
            return r(e)
          })
        e.exports = a.inspectSource
      },
      (e, t, i) => {
        let n
        let s
        let a
        const r = i(54)
        const o = i(7)
        const l = i(17)
        const c = i(22)
        const d = i(45)
        const h = i(40)
        const u = i(38)
        const p = i(55)
        const g = i(56)
        const f = 'Object already initialized'
        const m = o.TypeError
        const v = o.WeakMap
        if (r || u.state) {
          const _ = u.state || (u.state = new v())
          const b = l(_.get)
          const w = l(_.has)
          const P = l(_.set)
          n = function (e, t) {
            if (w(_, e)) throw new m(f)
            t.facade = e
            P(_, e, t)
            return t
          }
          s = function (e) {
            return b(_, e) || {}
          }
          a = function (e) {
            return w(_, e)
          }
        } else {
          const y = p('state')
          g[y] = !0
          n = function (e, t) {
            if (h(e, y)) throw new m(f)
            t.facade = e
            d(e, y, t)
            return t
          }
          s = function (e) {
            return h(e, y) ? e[y] : {}
          }
          a = function (e) {
            return h(e, y)
          }
        }
        e.exports = {
          set: n,
          get: s,
          has: a,
          enforce(e) {
            return a(e) ? s(e) : n(e, {})
          },
          getterFor(e) {
            return function (t) {
              let i
              if (!c(t) || (i = s(t)).type !== e) throw m(`Incompatible receiver, ${e} required`)
              return i
            }
          }
        }
      },
      (e, t, i) => {
        const n = i(7)
        const s = i(23)
        const a = i(52)
        const r = n.WeakMap
        e.exports = s(r) && /native code/.test(a(r))
      },
      (e, t, i) => {
        const n = i(36)
        const s = i(42)
        const a = n('keys')
        e.exports = function (e) {
          return a[e] || (a[e] = s(e))
        }
      },
      (e) => {
        e.exports = {}
      },
      (e, t, i) => {
        const n = i(40)
        const s = i(58)
        const a = i(8)
        const r = i(46)
        e.exports = function (e, t, i) {
          for (let o = s(t), l = r.f, c = a.f, d = 0; d < o.length; d++) {
            const h = o[d]
            n(e, h) || (i && n(i, h)) || l(e, h, c(t, h))
          }
        }
      },
      (e, t, i) => {
        const n = i(25)
        const s = i(17)
        const a = i(59)
        const r = i(68)
        const o = i(48)
        const l = s([].concat)
        e.exports =
          n('Reflect', 'ownKeys') ||
          function ownKeys(e) {
            const t = a.f(o(e))
            const i = r.f
            return i ? l(t, i(e)) : t
          }
      },
      (e, t, i) => {
        const n = i(60)
        const s = i(67).concat('length', 'prototype')
        t.f =
          Object.getOwnPropertyNames ||
          function getOwnPropertyNames(e) {
            return n(e, s)
          }
      },
      (e, t, i) => {
        const n = i(17)
        const s = i(40)
        const a = i(15)
        const r = i(61).indexOf
        const o = i(56)
        const l = n([].push)
        e.exports = function (e, t) {
          let i
          const n = a(e)
          let c = 0
          const d = []
          for (i in n) !s(o, i) && s(n, i) && l(d, i)
          for (; t.length > c; ) s(n, (i = t[c++])) && (~r(d, i) || l(d, i))
          return d
        }
      },
      (e, t, i) => {
        const n = i(15)
        const s = i(62)
        const a = i(65)
        const createMethod = function (e) {
          return function (t, i, r) {
            let o
            const l = n(t)
            const c = a(l)
            let d = s(r, c)
            if (e && i != i) {
              for (; c > d; ) if ((o = l[d++]) != o) return !0
            } else for (; c > d; d++) if ((e || d in l) && l[d] === i) return e || d || 0
            return !e && -1
          }
        }
        e.exports = { includes: createMethod(!0), indexOf: createMethod(!1) }
      },
      (e, t, i) => {
        const n = i(63)
        const s = Math.max
        const a = Math.min
        e.exports = function (e, t) {
          const i = n(e)
          return i < 0 ? s(i + t, 0) : a(i, t)
        }
      },
      (e, t, i) => {
        const n = i(64)
        e.exports = function (e) {
          const t = +e
          return t != t || t === 0 ? 0 : n(t)
        }
      },
      (e) => {
        const t = Math.ceil
        const i = Math.floor
        e.exports =
          Math.trunc ||
          function trunc(e) {
            const n = +e
            return (n > 0 ? i : t)(n)
          }
      },
      (e, t, i) => {
        const n = i(66)
        e.exports = function (e) {
          return n(e.length)
        }
      },
      (e, t, i) => {
        const n = i(63)
        const s = Math.min
        e.exports = function (e) {
          return e > 0 ? s(n(e), 9007199254740991) : 0
        }
      },
      (e) => {
        e.exports = [
          'constructor',
          'hasOwnProperty',
          'isPrototypeOf',
          'propertyIsEnumerable',
          'toLocaleString',
          'toString',
          'valueOf'
        ]
      },
      (e, t) => {
        t.f = Object.getOwnPropertySymbols
      },
      (e, t, i) => {
        const n = i(10)
        const s = i(23)
        const a = /#|\.prototype\./
        const isForced = function (e, t) {
          const i = o[r(e)]
          return i == c || (i != l && (s(t) ? n(t) : !!t))
        }
        var r = (isForced.normalize = function (e) {
          return String(e).replace(a, '.').toLowerCase()
        })
        var o = (isForced.data = {})
        var l = (isForced.NATIVE = 'N')
        var c = (isForced.POLYFILL = 'P')
        e.exports = isForced
      },
      (e, t, i) => {
        const n = i(35)
        const s = i(71)
        const a = i(46).f
        const r = n('unscopables')
        const o = Array.prototype
        o[r] == null && a(o, r, { configurable: !0, value: s(null) })
        e.exports = function (e) {
          o[r][e] = !0
        }
      },
      (e, t, i) => {
        let n
        const s = i(48)
        const a = i(72)
        const r = i(67)
        const o = i(56)
        const l = i(74)
        const c = i(44)
        const d = i(55)
        const h = d('IE_PROTO')
        const EmptyConstructor = function () {}
        const scriptTag = function (e) {
          return `<script>${e}</` + `script>`
        }
        const NullProtoObjectViaActiveX = function (e) {
          e.write(scriptTag(''))
          e.close()
          const t = e.parentWindow.Object
          e = null
          return t
        }
        var NullProtoObject = function () {
          try {
            n = new ActiveXObject('htmlfile')
          } catch (e) {}
          NullProtoObject =
            typeof document !== 'undefined'
              ? document.domain && n
                ? NullProtoObjectViaActiveX(n)
                : (function () {
                    let e
                    const t = c('iframe')
                    t.style.display = 'none'
                    l.appendChild(t)
                    t.src = String('javascript:')
                    ;(e = t.contentWindow.document).open()
                    e.write(scriptTag('document.F=Object'))
                    e.close()
                    return e.F
                  })()
              : NullProtoObjectViaActiveX(n)
          for (let e = r.length; e--; ) delete NullProtoObject.prototype[r[e]]
          return NullProtoObject()
        }
        o[h] = !0
        e.exports =
          Object.create ||
          function create(e, t) {
            let i
            if (e !== null) {
              EmptyConstructor.prototype = s(e)
              i = new EmptyConstructor()
              EmptyConstructor.prototype = null
              i[h] = e
            } else i = NullProtoObject()
            return void 0 === t ? i : a.f(i, t)
          }
      },
      (e, t, i) => {
        const n = i(9)
        const s = i(47)
        const a = i(46)
        const r = i(48)
        const o = i(15)
        const l = i(73)
        t.f =
          n && !s
            ? Object.defineProperties
            : function defineProperties(e, t) {
                r(e)
                for (var i, n = o(t), s = l(t), c = s.length, d = 0; c > d; )
                  a.f(e, (i = s[d++]), n[i])
                return e
              }
      },
      (e, t, i) => {
        const n = i(60)
        const s = i(67)
        e.exports =
          Object.keys ||
          function keys(e) {
            return n(e, s)
          }
      },
      (e, t, i) => {
        const n = i(25)
        e.exports = n('document', 'documentElement')
      },
      (e, t, i) => {
        const n = i(7)
        const s = i(17)
        e.exports = function (e, t) {
          return s(n[e].prototype[t])
        }
      },
      (e, t, i) => {
        i(77)
      },
      (e, t, i) => {
        const n = i(78)
        const s = i(65)
        const a = i(63)
        const r = n.aTypedArray
        ;(0, n.exportTypedArrayMethod)('at', function at(e) {
          const t = r(this)
          const i = s(t)
          const n = a(e)
          const o = n >= 0 ? n : i + n
          return o < 0 || o >= i ? void 0 : t[o]
        })
      },
      (e, t, i) => {
        let n
        let s
        let a
        const r = i(79)
        const o = i(9)
        const l = i(7)
        const c = i(23)
        const d = i(22)
        const h = i(40)
        const u = i(80)
        const p = i(33)
        const g = i(45)
        const f = i(49)
        const m = i(46).f
        const v = i(26)
        const _ = i(82)
        const b = i(84)
        const w = i(35)
        const P = i(42)
        const y = i(53)
        const S = y.enforce
        const A = y.get
        const E = l.Int8Array
        const x = E && E.prototype
        const C = l.Uint8ClampedArray
        const M = C && C.prototype
        let T = E && _(E)
        let k = x && _(x)
        const I = Object.prototype
        const D = l.TypeError
        const L = w('toStringTag')
        const R = P('TYPED_ARRAY_TAG')
        const O = 'TypedArrayConstructor'
        let N = r && !!b && u(l.opera) !== 'Opera'
        let B = !1
        const G = {
          Int8Array: 1,
          Uint8Array: 1,
          Uint8ClampedArray: 1,
          Int16Array: 2,
          Uint16Array: 2,
          Int32Array: 4,
          Uint32Array: 4,
          Float32Array: 4,
          Float64Array: 8
        }
        const V = { BigInt64Array: 8, BigUint64Array: 8 }
        var getTypedArrayConstructor = function (e) {
          const t = _(e)
          if (d(t)) {
            const i = A(t)
            return i && h(i, O) ? i.TypedArrayConstructor : getTypedArrayConstructor(t)
          }
        }
        const isTypedArray = function (e) {
          if (!d(e)) return !1
          const t = u(e)
          return h(G, t) || h(V, t)
        }
        for (n in G) (a = (s = l[n]) && s.prototype) ? (S(a).TypedArrayConstructor = s) : (N = !1)
        for (n in V) (a = (s = l[n]) && s.prototype) && (S(a).TypedArrayConstructor = s)
        if (!N || !c(T) || T === Function.prototype) {
          T = function TypedArray() {
            throw D('Incorrect invocation')
          }
          if (N) for (n in G) l[n] && b(l[n], T)
        }
        if (!N || !k || k === I) {
          k = T.prototype
          if (N) for (n in G) l[n] && b(l[n].prototype, k)
        }
        N && _(M) !== k && b(M, k)
        if (o && !h(k, L)) {
          B = !0
          m(k, L, {
            get() {
              return d(this) ? this[R] : void 0
            }
          })
          for (n in G) l[n] && g(l[n], R, n)
        }
        e.exports = {
          NATIVE_ARRAY_BUFFER_VIEWS: N,
          TYPED_ARRAY_TAG: B && R,
          aTypedArray(e) {
            if (isTypedArray(e)) return e
            throw D('Target is not a typed array')
          },
          aTypedArrayConstructor(e) {
            if (c(e) && (!b || v(T, e))) return e
            throw D(`${p(e)} is not a typed array constructor`)
          },
          exportTypedArrayMethod(e, t, i, n) {
            if (o) {
              if (i)
                for (const s in G) {
                  const a = l[s]
                  if (a && h(a.prototype, e))
                    try {
                      delete a.prototype[e]
                    } catch (i) {
                      try {
                        a.prototype[e] = t
                      } catch (e) {}
                    }
                }
              ;(k[e] && !i) || f(k, e, i ? t : (N && x[e]) || t, n)
            }
          },
          exportTypedArrayStaticMethod(e, t, i) {
            let n
            let s
            if (o) {
              if (b) {
                if (i)
                  for (n in G)
                    if ((s = l[n]) && h(s, e))
                      try {
                        delete s[e]
                      } catch (e) {}
                if (T[e] && !i) return
                try {
                  return f(T, e, i ? t : (N && T[e]) || t)
                } catch (e) {}
              }
              for (n in G) !(s = l[n]) || (s[e] && !i) || f(s, e, t)
            }
          },
          getTypedArrayConstructor,
          isView: function isView(e) {
            if (!d(e)) return !1
            const t = u(e)
            return t === 'DataView' || h(G, t) || h(V, t)
          },
          isTypedArray,
          TypedArray: T,
          TypedArrayPrototype: k
        }
      },
      (e) => {
        e.exports = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined'
      },
      (e, t, i) => {
        const n = i(81)
        const s = i(23)
        const a = i(18)
        const r = i(35)('toStringTag')
        const o = Object
        const l =
          a(
            (function () {
              return arguments
            })()
          ) == 'Arguments'
        e.exports = n
          ? a
          : function (e) {
              let t
              let i
              let n
              return void 0 === e
                ? 'Undefined'
                : e === null
                ? 'Null'
                : typeof (i = (function (e, t) {
                    try {
                      return e[t]
                    } catch (e) {}
                  })((t = o(e)), r)) === 'string'
                ? i
                : l
                ? a(t)
                : (n = a(t)) == 'Object' && s(t.callee)
                ? 'Arguments'
                : n
            }
      },
      (e, t, i) => {
        const n = {}
        n[i(35)('toStringTag')] = 'z'
        e.exports = String(n) === '[object z]'
      },
      (e, t, i) => {
        const n = i(40)
        const s = i(23)
        const a = i(41)
        const r = i(55)
        const o = i(83)
        const l = r('IE_PROTO')
        const c = Object
        const d = c.prototype
        e.exports = o
          ? c.getPrototypeOf
          : function (e) {
              const t = a(e)
              if (n(t, l)) return t[l]
              const i = t.constructor
              return s(i) && t instanceof i ? i.prototype : t instanceof c ? d : null
            }
      },
      (e, t, i) => {
        const n = i(10)
        e.exports = !n(function () {
          function F() {}
          F.prototype.constructor = null
          return Object.getPrototypeOf(new F()) !== F.prototype
        })
      },
      (e, t, i) => {
        const n = i(17)
        const s = i(48)
        const a = i(85)
        e.exports =
          Object.setPrototypeOf ||
          ('__proto__' in {}
            ? (function () {
                let e
                let t = !1
                const i = {}
                try {
                  ;(e = n(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set))(
                    i,
                    []
                  )
                  t = i instanceof Array
                } catch (e) {}
                return function setPrototypeOf(i, n) {
                  s(i)
                  a(n)
                  t ? e(i, n) : (i.__proto__ = n)
                  return i
                }
              })()
            : void 0)
      },
      (e, t, i) => {
        const n = i(23)
        const s = String
        const a = TypeError
        e.exports = function (e) {
          if (typeof e === 'object' || n(e)) return e
          throw a(`Can't set ${s(e)} as a prototype`)
        }
      },
      (e, t, i) => {
        i(87)
        i(93)
        i(95)
        i(117)
        i(119)
        const n = i(128)
        e.exports = n.structuredClone
      },
      (e, t, i) => {
        const n = i(15)
        const s = i(70)
        const a = i(88)
        const r = i(53)
        const o = i(46).f
        const l = i(89)
        const c = i(37)
        const d = i(9)
        const h = 'Array Iterator'
        const u = r.set
        const p = r.getterFor(h)
        e.exports = l(
          Array,
          'Array',
          function (e, t) {
            u(this, { type: h, target: n(e), index: 0, kind: t })
          },
          function () {
            const e = p(this)
            const t = e.target
            const i = e.kind
            const n = e.index++
            if (!t || n >= t.length) {
              e.target = void 0
              return { value: void 0, done: !0 }
            }
            return i == 'keys'
              ? { value: n, done: !1 }
              : i == 'values'
              ? { value: t[n], done: !1 }
              : { value: [n, t[n]], done: !1 }
          },
          'values'
        )
        const g = (a.Arguments = a.Array)
        s('keys')
        s('values')
        s('entries')
        if (!c && d && g.name !== 'values')
          try {
            o(g, 'name', { value: 'values' })
          } catch (e) {}
      },
      (e) => {
        e.exports = {}
      },
      (e, t, i) => {
        const n = i(6)
        const s = i(11)
        const a = i(37)
        const r = i(51)
        const o = i(23)
        const l = i(90)
        const c = i(82)
        const d = i(84)
        const h = i(92)
        const u = i(45)
        const p = i(49)
        const g = i(35)
        const f = i(88)
        const m = i(91)
        const v = r.PROPER
        const _ = r.CONFIGURABLE
        const b = m.IteratorPrototype
        const w = m.BUGGY_SAFARI_ITERATORS
        const P = g('iterator')
        const y = 'keys'
        const S = 'values'
        const A = 'entries'
        const returnThis = function () {
          return this
        }
        e.exports = function (e, t, i, r, g, m, E) {
          l(i, t, r)
          let x
          let C
          let M
          const getIterationMethod = function (e) {
            if (e === g && L) return L
            if (!w && e in I) return I[e]
            switch (e) {
              case y:
                return function keys() {
                  return new i(this, e)
                }
              case S:
                return function values() {
                  return new i(this, e)
                }
              case A:
                return function entries() {
                  return new i(this, e)
                }
            }
            return function () {
              return new i(this)
            }
          }
          const T = `${t} Iterator`
          let k = !1
          var I = e.prototype
          const D = I[P] || I['@@iterator'] || (g && I[g])
          var L = (!w && D) || getIterationMethod(g)
          const R = (t == 'Array' && I.entries) || D
          if (R && (x = c(R.call(new e()))) !== Object.prototype && x.next) {
            a || c(x) === b || (d ? d(x, b) : o(x[P]) || p(x, P, returnThis))
            h(x, T, !0, !0)
            a && (f[T] = returnThis)
          }
          if (v && g == S && D && D.name !== S)
            if (!a && _) u(I, 'name', S)
            else {
              k = !0
              L = function values() {
                return s(D, this)
              }
            }
          if (g) {
            C = {
              values: getIterationMethod(S),
              keys: m ? L : getIterationMethod(y),
              entries: getIterationMethod(A)
            }
            if (E) for (M in C) (w || k || !(M in I)) && p(I, M, C[M])
            else n({ target: t, proto: !0, forced: w || k }, C)
          }
          ;(a && !E) || I[P] === L || p(I, P, L, { name: g })
          f[t] = L
          return C
        }
      },
      (e, t, i) => {
        const n = i(91).IteratorPrototype
        const s = i(71)
        const a = i(14)
        const r = i(92)
        const o = i(88)
        const returnThis = function () {
          return this
        }
        e.exports = function (e, t, i, l) {
          const c = `${t} Iterator`
          e.prototype = s(n, { next: a(+!l, i) })
          r(e, c, !1, !0)
          o[c] = returnThis
          return e
        }
      },
      (e, t, i) => {
        let n
        let s
        let a
        const r = i(10)
        const o = i(23)
        const l = i(71)
        const c = i(82)
        const d = i(49)
        const h = i(35)
        const u = i(37)
        const p = h('iterator')
        let g = !1
        ;[].keys &&
          ('next' in (a = [].keys()) ? (s = c(c(a))) !== Object.prototype && (n = s) : (g = !0))
        n == null ||
        r(function () {
          const e = {}
          return n[p].call(e) !== e
        })
          ? (n = {})
          : u && (n = l(n))
        o(n[p]) ||
          d(n, p, function () {
            return this
          })
        e.exports = { IteratorPrototype: n, BUGGY_SAFARI_ITERATORS: g }
      },
      (e, t, i) => {
        const n = i(46).f
        const s = i(40)
        const a = i(35)('toStringTag')
        e.exports = function (e, t, i) {
          e && !i && (e = e.prototype)
          e && !s(e, a) && n(e, a, { configurable: !0, value: t })
        }
      },
      (e, t, i) => {
        const n = i(81)
        const s = i(49)
        const a = i(94)
        n || s(Object.prototype, 'toString', a, { unsafe: !0 })
      },
      (e, t, i) => {
        const n = i(81)
        const s = i(80)
        e.exports = n
          ? {}.toString
          : function toString() {
              return `[object ${s(this)}]`
            }
      },
      (e, t, i) => {
        i(96)
      },
      (e, t, i) => {
        i(97)(
          'Map',
          function (e) {
            return function Map() {
              return e(this, arguments.length ? arguments[0] : void 0)
            }
          },
          i(114)
        )
      },
      (e, t, i) => {
        const n = i(6)
        const s = i(7)
        const a = i(17)
        const r = i(69)
        const o = i(49)
        const l = i(98)
        const c = i(105)
        const d = i(111)
        const h = i(23)
        const u = i(22)
        const p = i(10)
        const g = i(112)
        const f = i(92)
        const m = i(113)
        e.exports = function (e, t, i) {
          const v = e.indexOf('Map') !== -1
          const _ = e.indexOf('Weak') !== -1
          const b = v ? 'set' : 'add'
          const w = s[e]
          const P = w && w.prototype
          let y = w
          const S = {}
          const fixMethod = function (e) {
            const t = a(P[e])
            o(
              P,
              e,
              e == 'add'
                ? function add(e) {
                    t(this, e === 0 ? 0 : e)
                    return this
                  }
                : e == 'delete'
                ? function (e) {
                    return !(_ && !u(e)) && t(this, e === 0 ? 0 : e)
                  }
                : e == 'get'
                ? function get(e) {
                    return _ && !u(e) ? void 0 : t(this, e === 0 ? 0 : e)
                  }
                : e == 'has'
                ? function has(e) {
                    return !(_ && !u(e)) && t(this, e === 0 ? 0 : e)
                  }
                : function set(e, i) {
                    t(this, e === 0 ? 0 : e, i)
                    return this
                  }
            )
          }
          if (
            r(
              e,
              !h(w) ||
                !(
                  _ ||
                  (P.forEach &&
                    !p(function () {
                      new w().entries().next()
                    }))
                )
            )
          ) {
            y = i.getConstructor(t, e, v, b)
            l.enable()
          } else if (r(e, !0)) {
            const A = new y()
            const E = A[b](_ ? {} : -0, 1) != A
            const x = p(function () {
              A.has(1)
            })
            const C = g(function (e) {
              new w(e)
            })
            const M =
              !_ &&
              p(function () {
                for (var e = new w(), t = 5; t--; ) e[b](t, t)
                return !e.has(-0)
              })
            if (!C) {
              ;(y = t(function (e, t) {
                d(e, P)
                const i = m(new w(), e, y)
                t != null && c(t, i[b], { that: i, AS_ENTRIES: v })
                return i
              })).prototype = P
              P.constructor = y
            }
            if (x || M) {
              fixMethod('delete')
              fixMethod('has')
              v && fixMethod('get')
            }
            ;(M || E) && fixMethod(b)
            _ && P.clear && delete P.clear
          }
          S[e] = y
          n({ global: !0, constructor: !0, forced: y != w }, S)
          f(y, e)
          _ || i.setStrong(y, e, v)
          return y
        }
      },
      (e, t, i) => {
        const n = i(6)
        const s = i(17)
        const a = i(56)
        const r = i(22)
        const o = i(40)
        const l = i(46).f
        const c = i(59)
        const d = i(99)
        const h = i(102)
        const u = i(42)
        const p = i(104)
        let g = !1
        const f = u('meta')
        let m = 0
        const setMetadata = function (e) {
          l(e, f, { value: { objectID: `O${m++}`, weakData: {} } })
        }
        var v = (e.exports = {
          enable() {
            v.enable = function () {}
            g = !0
            const e = c.f
            const t = s([].splice)
            const i = {}
            i[f] = 1
            if (e(i).length) {
              c.f = function (i) {
                for (var n = e(i), s = 0, a = n.length; s < a; s++)
                  if (n[s] === f) {
                    t(n, s, 1)
                    break
                  }
                return n
              }
              n({ target: 'Object', stat: !0, forced: !0 }, { getOwnPropertyNames: d.f })
            }
          },
          fastKey(e, t) {
            if (!r(e)) return typeof e === 'symbol' ? e : (typeof e === 'string' ? 'S' : 'P') + e
            if (!o(e, f)) {
              if (!h(e)) return 'F'
              if (!t) return 'E'
              setMetadata(e)
            }
            return e[f].objectID
          },
          getWeakData(e, t) {
            if (!o(e, f)) {
              if (!h(e)) return !0
              if (!t) return !1
              setMetadata(e)
            }
            return e[f].weakData
          },
          onFreeze(e) {
            p && g && h(e) && !o(e, f) && setMetadata(e)
            return e
          }
        })
        a[f] = !0
      },
      (e, t, i) => {
        const n = i(18)
        const s = i(15)
        const a = i(59).f
        const r = i(100)
        const o =
          typeof window === 'object' && window && Object.getOwnPropertyNames
            ? Object.getOwnPropertyNames(window)
            : []
        e.exports.f = function getOwnPropertyNames(e) {
          return o && n(e) == 'Window'
            ? (function (e) {
                try {
                  return a(e)
                } catch (e) {
                  return r(o)
                }
              })(e)
            : a(s(e))
        }
      },
      (e, t, i) => {
        const n = i(62)
        const s = i(65)
        const a = i(101)
        const r = Array
        const o = Math.max
        e.exports = function (e, t, i) {
          for (
            var l = s(e), c = n(t, l), d = n(void 0 === i ? l : i, l), h = r(o(d - c, 0)), u = 0;
            c < d;
            c++, u++
          )
            a(h, u, e[c])
          h.length = u
          return h
        }
      },
      (e, t, i) => {
        const n = i(20)
        const s = i(46)
        const a = i(14)
        e.exports = function (e, t, i) {
          const r = n(t)
          r in e ? s.f(e, r, a(0, i)) : (e[r] = i)
        }
      },
      (e, t, i) => {
        const n = i(10)
        const s = i(22)
        const a = i(18)
        const r = i(103)
        const o = Object.isExtensible
        const l = n(function () {
          o(1)
        })
        e.exports =
          l || r
            ? function isExtensible(e) {
                return !!s(e) && (!r || a(e) != 'ArrayBuffer') && (!o || o(e))
              }
            : o
      },
      (e, t, i) => {
        const n = i(10)
        e.exports = n(function () {
          if (typeof ArrayBuffer === 'function') {
            const e = new ArrayBuffer(8)
            Object.isExtensible(e) && Object.defineProperty(e, 'a', { value: 8 })
          }
        })
      },
      (e, t, i) => {
        const n = i(10)
        e.exports = !n(function () {
          return Object.isExtensible(Object.preventExtensions({}))
        })
      },
      (e, t, i) => {
        const n = i(106)
        const s = i(11)
        const a = i(48)
        const r = i(33)
        const o = i(107)
        const l = i(65)
        const c = i(26)
        const d = i(108)
        const h = i(109)
        const u = i(110)
        const p = TypeError
        const Result = function (e, t) {
          this.stopped = e
          this.result = t
        }
        const g = Result.prototype
        e.exports = function (e, t, i) {
          let f
          let m
          let v
          let _
          let b
          let w
          let P
          const y = i && i.that
          const S = !(!i || !i.AS_ENTRIES)
          const A = !(!i || !i.IS_RECORD)
          const E = !(!i || !i.IS_ITERATOR)
          const x = !(!i || !i.INTERRUPTED)
          const C = n(t, y)
          const stop = function (e) {
            f && u(f, 'normal', e)
            return new Result(!0, e)
          }
          const callFn = function (e) {
            if (S) {
              a(e)
              return x ? C(e[0], e[1], stop) : C(e[0], e[1])
            }
            return x ? C(e, stop) : C(e)
          }
          if (A) f = e.iterator
          else if (E) f = e
          else {
            if (!(m = h(e))) throw p(`${r(e)} is not iterable`)
            if (o(m)) {
              for (v = 0, _ = l(e); _ > v; v++) if ((b = callFn(e[v])) && c(g, b)) return b
              return new Result(!1)
            }
            f = d(e, m)
          }
          w = A ? e.next : f.next
          for (; !(P = s(w, f)).done; ) {
            try {
              b = callFn(P.value)
            } catch (e) {
              u(f, 'throw', e)
            }
            if (typeof b === 'object' && b && c(g, b)) return b
          }
          return new Result(!1)
        }
      },
      (e, t, i) => {
        const n = i(17)
        const s = i(32)
        const a = i(12)
        const r = n(n.bind)
        e.exports = function (e, t) {
          s(e)
          return void 0 === t
            ? e
            : a
            ? r(e, t)
            : function () {
                return e.apply(t, arguments)
              }
        }
      },
      (e, t, i) => {
        const n = i(35)
        const s = i(88)
        const a = n('iterator')
        const r = Array.prototype
        e.exports = function (e) {
          return void 0 !== e && (s.Array === e || r[a] === e)
        }
      },
      (e, t, i) => {
        const n = i(11)
        const s = i(32)
        const a = i(48)
        const r = i(33)
        const o = i(109)
        const l = TypeError
        e.exports = function (e, t) {
          const i = arguments.length < 2 ? o(e) : t
          if (s(i)) return a(n(i, e))
          throw l(`${r(e)} is not iterable`)
        }
      },
      (e, t, i) => {
        const n = i(80)
        const s = i(31)
        const a = i(88)
        const r = i(35)('iterator')
        e.exports = function (e) {
          if (e != null) return s(e, r) || s(e, '@@iterator') || a[n(e)]
        }
      },
      (e, t, i) => {
        const n = i(11)
        const s = i(48)
        const a = i(31)
        e.exports = function (e, t, i) {
          let r
          let o
          s(e)
          try {
            if (!(r = a(e, 'return'))) {
              if (t === 'throw') throw i
              return i
            }
            r = n(r, e)
          } catch (e) {
            o = !0
            r = e
          }
          if (t === 'throw') throw i
          if (o) throw r
          s(r)
          return i
        }
      },
      (e, t, i) => {
        const n = i(26)
        const s = TypeError
        e.exports = function (e, t) {
          if (n(t, e)) return e
          throw s('Incorrect invocation')
        }
      },
      (e, t, i) => {
        const n = i(35)('iterator')
        let s = !1
        try {
          let a = 0
          const r = {
            next() {
              return { done: !!a++ }
            },
            return() {
              s = !0
            }
          }
          r[n] = function () {
            return this
          }
          Array.from(r, function () {
            throw 2
          })
        } catch (e) {}
        e.exports = function (e, t) {
          if (!t && !s) return !1
          let i = !1
          try {
            const a = {}
            a[n] = function () {
              return {
                next() {
                  return { done: (i = !0) }
                }
              }
            }
            e(a)
          } catch (e) {}
          return i
        }
      },
      (e, t, i) => {
        const n = i(23)
        const s = i(22)
        const a = i(84)
        e.exports = function (e, t, i) {
          let r
          let o
          a &&
            n((r = t.constructor)) &&
            r !== i &&
            s((o = r.prototype)) &&
            o !== i.prototype &&
            a(e, o)
          return e
        }
      },
      (e, t, i) => {
        const n = i(46).f
        const s = i(71)
        const a = i(115)
        const r = i(106)
        const o = i(111)
        const l = i(105)
        const c = i(89)
        const d = i(116)
        const h = i(9)
        const u = i(98).fastKey
        const p = i(53)
        const g = p.set
        const f = p.getterFor
        e.exports = {
          getConstructor(e, t, i, c) {
            const d = e(function (e, n) {
              o(e, p)
              g(e, { type: t, index: s(null), first: void 0, last: void 0, size: 0 })
              h || (e.size = 0)
              n != null && l(n, e[c], { that: e, AS_ENTRIES: i })
            })
            var p = d.prototype
            const m = f(t)
            const define = function (e, t, i) {
              let n
              let s
              const a = m(e)
              let r = getEntry(e, t)
              if (r) r.value = i
              else {
                a.last = r = {
                  index: (s = u(t, !0)),
                  key: t,
                  value: i,
                  previous: (n = a.last),
                  next: void 0,
                  removed: !1
                }
                a.first || (a.first = r)
                n && (n.next = r)
                h ? a.size++ : e.size++
                s !== 'F' && (a.index[s] = r)
              }
              return e
            }
            var getEntry = function (e, t) {
              let i
              const n = m(e)
              const s = u(t)
              if (s !== 'F') return n.index[s]
              for (i = n.first; i; i = i.next) if (i.key == t) return i
            }
            a(p, {
              clear: function clear() {
                for (var e = m(this), t = e.index, i = e.first; i; ) {
                  i.removed = !0
                  i.previous && (i.previous = i.previous.next = void 0)
                  delete t[i.index]
                  i = i.next
                }
                e.first = e.last = void 0
                h ? (e.size = 0) : (this.size = 0)
              },
              delete(e) {
                const t = this
                const i = m(t)
                const n = getEntry(t, e)
                if (n) {
                  const s = n.next
                  const a = n.previous
                  delete i.index[n.index]
                  n.removed = !0
                  a && (a.next = s)
                  s && (s.previous = a)
                  i.first == n && (i.first = s)
                  i.last == n && (i.last = a)
                  h ? i.size-- : t.size--
                }
                return !!n
              },
              forEach: function forEach(e) {
                for (
                  var t, i = m(this), n = r(e, arguments.length > 1 ? arguments[1] : void 0);
                  (t = t ? t.next : i.first);

                ) {
                  n(t.value, t.key, this)
                  for (; t && t.removed; ) t = t.previous
                }
              },
              has: function has(e) {
                return !!getEntry(this, e)
              }
            })
            a(
              p,
              i
                ? {
                    get: function get(e) {
                      const t = getEntry(this, e)
                      return t && t.value
                    },
                    set: function set(e, t) {
                      return define(this, e === 0 ? 0 : e, t)
                    }
                  }
                : {
                    add: function add(e) {
                      return define(this, (e = e === 0 ? 0 : e), e)
                    }
                  }
            )
            h &&
              n(p, 'size', {
                get() {
                  return m(this).size
                }
              })
            return d
          },
          setStrong(e, t, i) {
            const n = `${t} Iterator`
            const s = f(t)
            const a = f(n)
            c(
              e,
              t,
              function (e, t) {
                g(this, { type: n, target: e, state: s(e), kind: t, last: void 0 })
              },
              function () {
                for (var e = a(this), t = e.kind, i = e.last; i && i.removed; ) i = i.previous
                if (!e.target || !(e.last = i = i ? i.next : e.state.first)) {
                  e.target = void 0
                  return { value: void 0, done: !0 }
                }
                return t == 'keys'
                  ? { value: i.key, done: !1 }
                  : t == 'values'
                  ? { value: i.value, done: !1 }
                  : { value: [i.key, i.value], done: !1 }
              },
              i ? 'entries' : 'values',
              !i,
              !0
            )
            d(t)
          }
        }
      },
      (e, t, i) => {
        const n = i(49)
        e.exports = function (e, t, i) {
          for (const s in t) n(e, s, t[s], i)
          return e
        }
      },
      (e, t, i) => {
        const n = i(25)
        const s = i(46)
        const a = i(35)
        const r = i(9)
        const o = a('species')
        e.exports = function (e) {
          const t = n(e)
          const i = s.f
          r &&
            t &&
            !t[o] &&
            i(t, o, {
              configurable: !0,
              get() {
                return this
              }
            })
        }
      },
      (e, t, i) => {
        i(118)
      },
      (e, t, i) => {
        i(97)(
          'Set',
          function (e) {
            return function Set() {
              return e(this, arguments.length ? arguments[0] : void 0)
            }
          },
          i(114)
        )
      },
      (e, t, i) => {
        let n
        const s = i(37)
        const a = i(6)
        const r = i(7)
        const o = i(25)
        const l = i(17)
        const c = i(10)
        const d = i(42)
        const h = i(23)
        const u = i(120)
        const p = i(22)
        const g = i(24)
        const f = i(105)
        const m = i(48)
        const v = i(80)
        const _ = i(40)
        const b = i(101)
        const w = i(45)
        const P = i(65)
        const y = i(121)
        const S = i(122)
        const A = i(124)
        const E = i(29)
        const x = i(125)
        const C = i(126)
        const M = i(127)
        const T = r.Object
        const k = r.Date
        const I = r.Error
        const D = r.EvalError
        const L = r.RangeError
        const R = r.ReferenceError
        const O = r.SyntaxError
        const N = r.TypeError
        const B = r.URIError
        const G = r.PerformanceMark
        const V = r.WebAssembly
        const W = (V && V.CompileError) || I
        const j = (V && V.LinkError) || I
        const U = (V && V.RuntimeError) || I
        const z = o('DOMException')
        const H = o('Set')
        const q = o('Map')
        const $ = q.prototype
        const X = l($.has)
        const K = l($.get)
        const Y = l($.set)
        const Q = l(H.prototype.add)
        const J = o('Object', 'keys')
        const Z = l([].push)
        const ee = l((!0).valueOf)
        const te = l((1).valueOf)
        const ie = l(''.valueOf)
        const ne = l(k.prototype.getTime)
        const se = d('structuredClone')
        const ae = 'DataCloneError'
        const re = 'Transferring'
        const checkBasicSemantic = function (e) {
          return (
            !c(function () {
              const t = new r.Set([7])
              const i = e(t)
              const n = e(T(7))
              return i == t || !i.has(7) || typeof n !== 'object' || n != 7
            }) && e
          )
        }
        const checkErrorsCloning = function (e, t) {
          return !c(function () {
            const i = new t()
            const n = e({ a: i, b: i })
            return !(n && n.a === n.b && n.a instanceof t && n.a.stack === i.stack)
          })
        }
        const oe = r.structuredClone
        const le =
          s ||
          !checkErrorsCloning(oe, I) ||
          !checkErrorsCloning(oe, z) ||
          !((n = oe),
          !c(function () {
            const e = n(new r.AggregateError([1], se, { cause: 3 }))
            return e.name != 'AggregateError' || e.errors[0] != 1 || e.message != se || e.cause != 3
          }))
        const ce =
          !oe &&
          checkBasicSemantic(function (e) {
            return new G(se, { detail: e }).detail
          })
        const de = checkBasicSemantic(oe) || ce
        const throwUncloneable = function (e) {
          throw new z(`Uncloneable type: ${e}`, ae)
        }
        const throwUnpolyfillable = function (e, t) {
          throw new z(`${t || 'Cloning'} of ${e} cannot be properly polyfilled in this engine`, ae)
        }
        var structuredCloneInternal = function (e, t) {
          g(e) && throwUncloneable('Symbol')
          if (!p(e)) return e
          if (t) {
            if (X(t, e)) return K(t, e)
          } else t = new q()
          let i
          let n
          let s
          let a
          let l
          let c
          let d
          let f
          let m
          let y
          const E = v(e)
          let x = !1
          switch (E) {
            case 'Array':
              s = []
              x = !0
              break
            case 'Object':
              s = {}
              x = !0
              break
            case 'Map':
              s = new q()
              x = !0
              break
            case 'Set':
              s = new H()
              x = !0
              break
            case 'RegExp':
              s = new RegExp(e.source, S(e))
              break
            case 'Error':
              switch ((n = e.name)) {
                case 'AggregateError':
                  s = o('AggregateError')([])
                  break
                case 'EvalError':
                  s = D()
                  break
                case 'RangeError':
                  s = L()
                  break
                case 'ReferenceError':
                  s = R()
                  break
                case 'SyntaxError':
                  s = O()
                  break
                case 'TypeError':
                  s = N()
                  break
                case 'URIError':
                  s = B()
                  break
                case 'CompileError':
                  s = W()
                  break
                case 'LinkError':
                  s = j()
                  break
                case 'RuntimeError':
                  s = U()
                  break
                default:
                  s = I()
              }
              x = !0
              break
            case 'DOMException':
              s = new z(e.message, e.name)
              x = !0
              break
            case 'DataView':
            case 'Int8Array':
            case 'Uint8Array':
            case 'Uint8ClampedArray':
            case 'Int16Array':
            case 'Uint16Array':
            case 'Int32Array':
            case 'Uint32Array':
            case 'Float32Array':
            case 'Float64Array':
            case 'BigInt64Array':
            case 'BigUint64Array':
              i = r[E]
              p(i) || throwUnpolyfillable(E)
              s = new i(
                structuredCloneInternal(e.buffer, t),
                e.byteOffset,
                E === 'DataView' ? e.byteLength : e.length
              )
              break
            case 'DOMQuad':
              try {
                s = new DOMQuad(
                  structuredCloneInternal(e.p1, t),
                  structuredCloneInternal(e.p2, t),
                  structuredCloneInternal(e.p3, t),
                  structuredCloneInternal(e.p4, t)
                )
              } catch (t) {
                de ? (s = de(e)) : throwUnpolyfillable(E)
              }
              break
            case 'FileList':
              i = r.DataTransfer
              if (u(i)) {
                a = new i()
                for (l = 0, c = P(e); l < c; l++) a.items.add(structuredCloneInternal(e[l], t))
                s = a.files
              } else de ? (s = de(e)) : throwUnpolyfillable(E)
              break
            case 'ImageData':
              try {
                s = new ImageData(structuredCloneInternal(e.data, t), e.width, e.height, {
                  colorSpace: e.colorSpace
                })
              } catch (t) {
                de ? (s = de(e)) : throwUnpolyfillable(E)
              }
              break
            default:
              if (de) s = de(e)
              else
                switch (E) {
                  case 'BigInt':
                    s = T(e.valueOf())
                    break
                  case 'Boolean':
                    s = T(ee(e))
                    break
                  case 'Number':
                    s = T(te(e))
                    break
                  case 'String':
                    s = T(ie(e))
                    break
                  case 'Date':
                    s = new k(ne(e))
                    break
                  case 'ArrayBuffer':
                    ;(i = r.DataView) || typeof e.slice === 'function' || throwUnpolyfillable(E)
                    try {
                      if (typeof e.slice === 'function') s = e.slice(0)
                      else {
                        c = e.byteLength
                        s = new ArrayBuffer(c)
                        m = new i(e)
                        y = new i(s)
                        for (l = 0; l < c; l++) y.setUint8(l, m.getUint8(l))
                      }
                    } catch (e) {
                      throw new z('ArrayBuffer is detached', ae)
                    }
                    break
                  case 'SharedArrayBuffer':
                    s = e
                    break
                  case 'Blob':
                    try {
                      s = e.slice(0, e.size, e.type)
                    } catch (e) {
                      throwUnpolyfillable(E)
                    }
                    break
                  case 'DOMPoint':
                  case 'DOMPointReadOnly':
                    i = r[E]
                    try {
                      s = i.fromPoint ? i.fromPoint(e) : new i(e.x, e.y, e.z, e.w)
                    } catch (e) {
                      throwUnpolyfillable(E)
                    }
                    break
                  case 'DOMRect':
                  case 'DOMRectReadOnly':
                    i = r[E]
                    try {
                      s = i.fromRect ? i.fromRect(e) : new i(e.x, e.y, e.width, e.height)
                    } catch (e) {
                      throwUnpolyfillable(E)
                    }
                    break
                  case 'DOMMatrix':
                  case 'DOMMatrixReadOnly':
                    i = r[E]
                    try {
                      s = i.fromMatrix ? i.fromMatrix(e) : new i(e)
                    } catch (e) {
                      throwUnpolyfillable(E)
                    }
                    break
                  case 'AudioData':
                  case 'VideoFrame':
                    h(e.clone) || throwUnpolyfillable(E)
                    try {
                      s = e.clone()
                    } catch (e) {
                      throwUncloneable(E)
                    }
                    break
                  case 'File':
                    try {
                      s = new File([e], e.name, e)
                    } catch (e) {
                      throwUnpolyfillable(E)
                    }
                    break
                  case 'CryptoKey':
                  case 'GPUCompilationMessage':
                  case 'GPUCompilationInfo':
                  case 'ImageBitmap':
                  case 'RTCCertificate':
                  case 'WebAssembly.Module':
                    throwUnpolyfillable(E)
                  default:
                    throwUncloneable(E)
                }
          }
          Y(t, e, s)
          if (x)
            switch (E) {
              case 'Array':
              case 'Object':
                d = J(e)
                for (l = 0, c = P(d); l < c; l++) {
                  f = d[l]
                  b(s, f, structuredCloneInternal(e[f], t))
                }
                break
              case 'Map':
                e.forEach(function (e, i) {
                  Y(s, structuredCloneInternal(i, t), structuredCloneInternal(e, t))
                })
                break
              case 'Set':
                e.forEach(function (e) {
                  Q(s, structuredCloneInternal(e, t))
                })
                break
              case 'Error':
                w(s, 'message', structuredCloneInternal(e.message, t))
                _(e, 'cause') && w(s, 'cause', structuredCloneInternal(e.cause, t))
                n == 'AggregateError' && (s.errors = structuredCloneInternal(e.errors, t))
              case 'DOMException':
                A && w(s, 'stack', structuredCloneInternal(e.stack, t))
            }
          return s
        }
        const he =
          oe &&
          !c(function () {
            if ((C && E > 92) || (M && E > 94) || (x && E > 97)) return !1
            const e = new ArrayBuffer(8)
            const t = oe(e, { transfer: [e] })
            return e.byteLength != 0 || t.byteLength != 8
          })
        const tryToTransfer = function (e, t) {
          if (!p(e)) throw N('Transfer option cannot be converted to a sequence')
          const i = []
          f(e, function (e) {
            Z(i, m(e))
          })
          let n
          let s
          let a
          let o
          let l
          let c
          let d = 0
          const g = P(i)
          if (he) {
            o = oe(i, { transfer: i })
            for (; d < g; ) Y(t, i[d], o[d++])
          } else
            for (; d < g; ) {
              n = i[d++]
              if (X(t, n)) throw new z('Duplicate transferable', ae)
              switch ((s = v(n))) {
                case 'ImageBitmap':
                  a = r.OffscreenCanvas
                  u(a) || throwUnpolyfillable(s, re)
                  try {
                    ;(c = new a(n.width, n.height))
                      .getContext('bitmaprenderer')
                      .transferFromImageBitmap(n)
                    l = c.transferToImageBitmap()
                  } catch (e) {}
                  break
                case 'AudioData':
                case 'VideoFrame':
                  ;(h(n.clone) && h(n.close)) || throwUnpolyfillable(s, re)
                  try {
                    l = n.clone()
                    n.close()
                  } catch (e) {}
                  break
                case 'ArrayBuffer':
                case 'MessagePort':
                case 'OffscreenCanvas':
                case 'ReadableStream':
                case 'TransformStream':
                case 'WritableStream':
                  throwUnpolyfillable(s, re)
              }
              if (void 0 === l) throw new z(`This object cannot be transferred: ${s}`, ae)
              Y(t, n, l)
            }
        }
        a(
          { global: !0, enumerable: !0, sham: !he, forced: le },
          {
            structuredClone: function structuredClone(e) {
              let t
              const i =
                y(arguments.length, 1) > 1 && arguments[1] != null ? m(arguments[1]) : void 0
              const n = i ? i.transfer : void 0
              if (void 0 !== n) {
                t = new q()
                tryToTransfer(n, t)
              }
              return structuredCloneInternal(e, t)
            }
          }
        )
      },
      (e, t, i) => {
        const n = i(17)
        const s = i(10)
        const a = i(23)
        const r = i(80)
        const o = i(25)
        const l = i(52)
        const noop = function () {}
        const c = []
        const d = o('Reflect', 'construct')
        const h = /^\s*(?:class|function)\b/
        const u = n(h.exec)
        const p = !h.exec(noop)
        const g = function isConstructor(e) {
          if (!a(e)) return !1
          try {
            d(noop, c, e)
            return !0
          } catch (e) {
            return !1
          }
        }
        const f = function isConstructor(e) {
          if (!a(e)) return !1
          switch (r(e)) {
            case 'AsyncFunction':
            case 'GeneratorFunction':
            case 'AsyncGeneratorFunction':
              return !1
          }
          try {
            return p || !!u(h, l(e))
          } catch (e) {
            return !0
          }
        }
        f.sham = !0
        e.exports =
          !d ||
          s(function () {
            let e
            return (
              g(g.call) ||
              !g(Object) ||
              !g(function () {
                e = !0
              }) ||
              e
            )
          })
            ? f
            : g
      },
      (e) => {
        const t = TypeError
        e.exports = function (e, i) {
          if (e < i) throw t('Not enough arguments')
          return e
        }
      },
      (e, t, i) => {
        const n = i(11)
        const s = i(40)
        const a = i(26)
        const r = i(123)
        const o = RegExp.prototype
        e.exports = function (e) {
          const t = e.flags
          return void 0 !== t || 'flags' in o || s(e, 'flags') || !a(o, e) ? t : n(r, e)
        }
      },
      (e, t, i) => {
        const n = i(48)
        e.exports = function () {
          const e = n(this)
          let t = ''
          e.hasIndices && (t += 'd')
          e.global && (t += 'g')
          e.ignoreCase && (t += 'i')
          e.multiline && (t += 'm')
          e.dotAll && (t += 's')
          e.unicode && (t += 'u')
          e.unicodeSets && (t += 'v')
          e.sticky && (t += 'y')
          return t
        }
      },
      (e, t, i) => {
        const n = i(10)
        const s = i(14)
        e.exports = !n(function () {
          const e = Error('a')
          if (!('stack' in e)) return !0
          Object.defineProperty(e, 'stack', s(1, 7))
          return e.stack !== 7
        })
      },
      (e, t, i) => {
        const n = i(126)
        const s = i(127)
        e.exports = !n && !s && typeof window === 'object' && typeof document === 'object'
      },
      (e) => {
        e.exports = typeof Deno === 'object' && Deno && typeof Deno.version === 'object'
      },
      (e, t, i) => {
        const n = i(18)
        const s = i(7)
        e.exports = n(s.process) == 'process'
      },
      (e, t, i) => {
        const n = i(7)
        e.exports = n
      },
      (__unused_webpack_module, exports, __w_pdfjs_require__) => {
        Object.defineProperty(exports, '__esModule', { value: !0 })
        exports.build =
          exports.RenderTask =
          exports.PDFWorkerUtil =
          exports.PDFWorker =
          exports.PDFPageProxy =
          exports.PDFDocumentProxy =
          exports.PDFDocumentLoadingTask =
          exports.PDFDataRangeTransport =
          exports.LoopbackPort =
          exports.DefaultStandardFontDataFactory =
          exports.DefaultCanvasFactory =
          exports.DefaultCMapReaderFactory =
            void 0
        exports.getDocument = getDocument
        exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory
        exports.version = void 0
        const _util = __w_pdfjs_require__(1)
        const _annotation_storage = __w_pdfjs_require__(130)
        const _display_utils = __w_pdfjs_require__(133)
        const _font_loader = __w_pdfjs_require__(136)
        const _canvas = __w_pdfjs_require__(137)
        const _worker_options = __w_pdfjs_require__(142)
        const _is_node = __w_pdfjs_require__(3)
        const _message_handler = __w_pdfjs_require__(143)
        const _metadata = __w_pdfjs_require__(144)
        const _optional_content_config = __w_pdfjs_require__(145)
        const _transport_stream = __w_pdfjs_require__(146)
        const _xfa_text = __w_pdfjs_require__(147)
        function _classPrivateMethodInitSpec(e, t) {
          _checkPrivateRedeclaration(e, t)
          t.add(e)
        }
        function _classPrivateMethodGet(e, t, i) {
          if (!t.has(e)) throw new TypeError('attempted to get private field on non-instance')
          return i
        }
        function _classPrivateFieldInitSpec(e, t, i) {
          _checkPrivateRedeclaration(e, t)
          t.set(e, i)
        }
        function _checkPrivateRedeclaration(e, t) {
          if (t.has(e))
            throw new TypeError('Cannot initialize the same private elements twice on an object')
        }
        function _classPrivateFieldSet(e, t, i) {
          _classApplyDescriptorSet(e, _classExtractFieldDescriptor(e, t, 'set'), i)
          return i
        }
        function _classPrivateFieldGet(e, t) {
          return _classApplyDescriptorGet(e, _classExtractFieldDescriptor(e, t, 'get'))
        }
        function _classExtractFieldDescriptor(e, t, i) {
          if (!t.has(e)) throw new TypeError(`attempted to ${i} private field on non-instance`)
          return t.get(e)
        }
        function _classStaticPrivateFieldSpecSet(e, t, i, n) {
          _classCheckPrivateStaticAccess(e, t)
          _classCheckPrivateStaticFieldDescriptor(i, 'set')
          _classApplyDescriptorSet(e, i, n)
          return n
        }
        function _classApplyDescriptorSet(e, t, i) {
          if (t.set) t.set.call(e, i)
          else {
            if (!t.writable) throw new TypeError('attempted to set read only private field')
            t.value = i
          }
        }
        function _classStaticPrivateFieldSpecGet(e, t, i) {
          _classCheckPrivateStaticAccess(e, t)
          _classCheckPrivateStaticFieldDescriptor(i, 'get')
          return _classApplyDescriptorGet(e, i)
        }
        function _classCheckPrivateStaticFieldDescriptor(e, t) {
          if (void 0 === e)
            throw new TypeError(`attempted to ${t} private static field before its declaration`)
        }
        function _classCheckPrivateStaticAccess(e, t) {
          if (e !== t) throw new TypeError('Private static access of wrong provenance')
        }
        function _classApplyDescriptorGet(e, t) {
          return t.get ? t.get.call(e) : t.value
        }
        const DEFAULT_RANGE_CHUNK_SIZE = 65536
        const RENDERING_CANCELLED_TIMEOUT = 100
        let DefaultCanvasFactory = _display_utils.DOMCanvasFactory
        exports.DefaultCanvasFactory = DefaultCanvasFactory
        let DefaultCMapReaderFactory = _display_utils.DOMCMapReaderFactory
        exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory
        let DefaultStandardFontDataFactory = _display_utils.DOMStandardFontDataFactory
        let createPDFNetworkStream
        exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory
        if (_is_node.isNodeJS) {
          const {
            NodeCanvasFactory: e,
            NodeCMapReaderFactory: t,
            NodeStandardFontDataFactory: i
          } = __w_pdfjs_require__(148)
          exports.DefaultCanvasFactory = DefaultCanvasFactory = e
          exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory = t
          exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory = i
        }
        function setPDFNetworkStreamFactory(e) {
          createPDFNetworkStream = e
        }
        function getDocument(e) {
          const t = new PDFDocumentLoadingTask()
          let i
          if (typeof e === 'string' || e instanceof URL) i = { url: e }
          else if ((0, _util.isArrayBuffer)(e)) i = { data: e }
          else if (e instanceof PDFDataRangeTransport) i = { range: e }
          else {
            if (typeof e !== 'object')
              throw new Error(
                'Invalid parameter in getDocument, need either string, URL, TypedArray, or parameter object.'
              )
            if (!e.url && !e.data && !e.range)
              throw new Error('Invalid parameter object: need either .data, .range or .url')
            i = e
          }
          const n = Object.create(null)
          let s = null
          let a = null
          for (const e in i) {
            const t = i[e]
            switch (e) {
              case 'url':
                if (typeof window !== 'undefined')
                  try {
                    n[e] = new URL(t, window.location).href
                    continue
                  } catch (e) {
                    ;(0, _util.warn)(`Cannot create valid URL: "${e}".`)
                  }
                else if (typeof t === 'string' || t instanceof URL) {
                  n[e] = t.toString()
                  continue
                }
                throw new Error(
                  'Invalid PDF url data: either string or URL-object is expected in the url property.'
                )
              case 'range':
                s = t
                continue
              case 'worker':
                a = t
                continue
              case 'data':
                if (_is_node.isNodeJS && typeof Buffer !== 'undefined' && t instanceof Buffer)
                  n[e] = new Uint8Array(t)
                else {
                  if (t instanceof Uint8Array) break
                  if (typeof t === 'string') n[e] = (0, _util.stringToBytes)(t)
                  else if (typeof t !== 'object' || t === null || isNaN(t.length)) {
                    if (!(0, _util.isArrayBuffer)(t))
                      throw new Error(
                        'Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.'
                      )
                    n[e] = new Uint8Array(t)
                  } else n[e] = new Uint8Array(t)
                }
                continue
            }
            n[e] = t
          }
          n.CMapReaderFactory = n.CMapReaderFactory || DefaultCMapReaderFactory
          n.StandardFontDataFactory = n.StandardFontDataFactory || DefaultStandardFontDataFactory
          n.ignoreErrors = !0 !== n.stopAtErrors
          n.fontExtraProperties = !0 === n.fontExtraProperties
          n.pdfBug = !0 === n.pdfBug
          n.enableXfa = !0 === n.enableXfa
          ;(!Number.isInteger(n.rangeChunkSize) || n.rangeChunkSize < 1) &&
            (n.rangeChunkSize = DEFAULT_RANGE_CHUNK_SIZE)
          ;(typeof n.docBaseUrl !== 'string' || (0, _display_utils.isDataScheme)(n.docBaseUrl)) &&
            (n.docBaseUrl = null)
          ;(!Number.isInteger(n.maxImageSize) || n.maxImageSize < -1) && (n.maxImageSize = -1)
          typeof n.cMapUrl !== 'string' && (n.cMapUrl = null)
          typeof n.standardFontDataUrl !== 'string' && (n.standardFontDataUrl = null)
          typeof n.useWorkerFetch !== 'boolean' &&
            (n.useWorkerFetch =
              n.CMapReaderFactory === _display_utils.DOMCMapReaderFactory &&
              n.StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory)
          typeof n.isEvalSupported !== 'boolean' && (n.isEvalSupported = !0)
          typeof n.disableFontFace !== 'boolean' && (n.disableFontFace = _is_node.isNodeJS)
          typeof n.useSystemFonts !== 'boolean' &&
            (n.useSystemFonts = !_is_node.isNodeJS && !n.disableFontFace)
          ;(typeof n.ownerDocument === 'object' && n.ownerDocument !== null) ||
            (n.ownerDocument = globalThis.document)
          typeof n.disableRange !== 'boolean' && (n.disableRange = !1)
          typeof n.disableStream !== 'boolean' && (n.disableStream = !1)
          typeof n.disableAutoFetch !== 'boolean' && (n.disableAutoFetch = !1)
          ;(0, _util.setVerbosityLevel)(n.verbosity)
          if (!a) {
            const e = {
              verbosity: n.verbosity,
              port: _worker_options.GlobalWorkerOptions.workerPort
            }
            a = e.port ? PDFWorker.fromPort(e) : new PDFWorker(e)
            t._worker = a
          }
          const r = t.docId
          a.promise
            .then(function () {
              if (t.destroyed) throw new Error('Loading aborted')
              const e = _fetchDocument(a, n, s, r)
              const i = new Promise(function (e) {
                let t
                s
                  ? (t = new _transport_stream.PDFDataTransportStream(
                      {
                        length: n.length,
                        initialData: n.initialData,
                        progressiveDone: n.progressiveDone,
                        contentDispositionFilename: n.contentDispositionFilename,
                        disableRange: n.disableRange,
                        disableStream: n.disableStream
                      },
                      s
                    ))
                  : n.data ||
                    (t = createPDFNetworkStream({
                      url: n.url,
                      length: n.length,
                      httpHeaders: n.httpHeaders,
                      withCredentials: n.withCredentials,
                      rangeChunkSize: n.rangeChunkSize,
                      disableRange: n.disableRange,
                      disableStream: n.disableStream
                    }))
                e(t)
              })
              return Promise.all([e, i]).then(function (e) {
                const [i, s] = e
                if (t.destroyed) throw new Error('Loading aborted')
                const o = new _message_handler.MessageHandler(r, i, a.port)
                const l = new WorkerTransport(o, t, s, n)
                t._transport = l
                o.send('Ready', null)
              })
            })
            .catch(t._capability.reject)
          return t
        }
        async function _fetchDocument(e, t, i, n) {
          if (e.destroyed) throw new Error('Worker was destroyed')
          if (i) {
            t.length = i.length
            t.initialData = i.initialData
            t.progressiveDone = i.progressiveDone
            t.contentDispositionFilename = i.contentDispositionFilename
          }
          const s = await e.messageHandler.sendWithPromise('GetDocRequest', {
            docId: n,
            apiVersion: '2.16.0',
            source: {
              data: t.data,
              url: t.url,
              password: t.password,
              disableAutoFetch: t.disableAutoFetch,
              rangeChunkSize: t.rangeChunkSize,
              length: t.length
            },
            maxImageSize: t.maxImageSize,
            disableFontFace: t.disableFontFace,
            docBaseUrl: t.docBaseUrl,
            ignoreErrors: t.ignoreErrors,
            isEvalSupported: t.isEvalSupported,
            fontExtraProperties: t.fontExtraProperties,
            enableXfa: t.enableXfa,
            useSystemFonts: t.useSystemFonts,
            cMapUrl: t.useWorkerFetch ? t.cMapUrl : null,
            standardFontDataUrl: t.useWorkerFetch ? t.standardFontDataUrl : null
          })
          t.data && (t.data = null)
          if (e.destroyed) throw new Error('Worker was destroyed')
          return s
        }
        class PDFDocumentLoadingTask {
          constructor() {
            let e
            let t
            this._capability = (0, _util.createPromiseCapability)()
            this._transport = null
            this._worker = null
            this.docId = `d${
              (_classStaticPrivateFieldSpecSet(
                PDFDocumentLoadingTask,
                PDFDocumentLoadingTask,
                _docId,
                ((e = _classStaticPrivateFieldSpecGet(
                  PDFDocumentLoadingTask,
                  PDFDocumentLoadingTask,
                  _docId
                )),
                (t = e++),
                e)
              ),
              t)
            }`
            this.destroyed = !1
            this.onPassword = null
            this.onProgress = null
            this.onUnsupportedFeature = null
          }

          get promise() {
            return this._capability.promise
          }

          async destroy() {
            let e
            this.destroyed = !0
            await ((e = this._transport) === null || void 0 === e ? void 0 : e.destroy())
            this._transport = null
            if (this._worker) {
              this._worker.destroy()
              this._worker = null
            }
          }
        }
        exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask
        var _docId = { writable: !0, value: 0 }
        class PDFDataRangeTransport {
          constructor(e, t) {
            const i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
            const n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null
            this.length = e
            this.initialData = t
            this.progressiveDone = i
            this.contentDispositionFilename = n
            this._rangeListeners = []
            this._progressListeners = []
            this._progressiveReadListeners = []
            this._progressiveDoneListeners = []
            this._readyCapability = (0, _util.createPromiseCapability)()
          }

          addRangeListener(e) {
            this._rangeListeners.push(e)
          }

          addProgressListener(e) {
            this._progressListeners.push(e)
          }

          addProgressiveReadListener(e) {
            this._progressiveReadListeners.push(e)
          }

          addProgressiveDoneListener(e) {
            this._progressiveDoneListeners.push(e)
          }

          onDataRange(e, t) {
            for (const i of this._rangeListeners) i(e, t)
          }

          onDataProgress(e, t) {
            this._readyCapability.promise.then(() => {
              for (const i of this._progressListeners) i(e, t)
            })
          }

          onDataProgressiveRead(e) {
            this._readyCapability.promise.then(() => {
              for (const t of this._progressiveReadListeners) t(e)
            })
          }

          onDataProgressiveDone() {
            this._readyCapability.promise.then(() => {
              for (const e of this._progressiveDoneListeners) e()
            })
          }

          transportReady() {
            this._readyCapability.resolve()
          }

          requestDataRange(e, t) {
            ;(0, _util.unreachable)('Abstract method PDFDataRangeTransport.requestDataRange')
          }

          abort() {}
        }
        exports.PDFDataRangeTransport = PDFDataRangeTransport
        class PDFDocumentProxy {
          constructor(e, t) {
            this._pdfInfo = e
            this._transport = t
            Object.defineProperty(this, 'fingerprint', {
              get() {
                ;(0, _display_utils.deprecated)(
                  '`PDFDocumentProxy.fingerprint`, please use `PDFDocumentProxy.fingerprints` instead.'
                )
                return this.fingerprints[0]
              }
            })
            Object.defineProperty(this, 'getStats', {
              value: async () => {
                ;(0, _display_utils.deprecated)(
                  '`PDFDocumentProxy.getStats`, please use the `PDFDocumentProxy.stats`-getter instead.'
                )
                return this.stats || { streamTypes: {}, fontTypes: {} }
              }
            })
          }

          get annotationStorage() {
            return this._transport.annotationStorage
          }

          get numPages() {
            return this._pdfInfo.numPages
          }

          get fingerprints() {
            return this._pdfInfo.fingerprints
          }

          get stats() {
            return this._transport.stats
          }

          get isPureXfa() {
            return !!this._transport._htmlForXfa
          }

          get allXfaHtml() {
            return this._transport._htmlForXfa
          }

          getPage(e) {
            return this._transport.getPage(e)
          }

          getPageIndex(e) {
            return this._transport.getPageIndex(e)
          }

          getDestinations() {
            return this._transport.getDestinations()
          }

          getDestination(e) {
            return this._transport.getDestination(e)
          }

          getPageLabels() {
            return this._transport.getPageLabels()
          }

          getPageLayout() {
            return this._transport.getPageLayout()
          }

          getPageMode() {
            return this._transport.getPageMode()
          }

          getViewerPreferences() {
            return this._transport.getViewerPreferences()
          }

          getOpenAction() {
            return this._transport.getOpenAction()
          }

          getAttachments() {
            return this._transport.getAttachments()
          }

          getJavaScript() {
            return this._transport.getJavaScript()
          }

          getJSActions() {
            return this._transport.getDocJSActions()
          }

          getOutline() {
            return this._transport.getOutline()
          }

          getOptionalContentConfig() {
            return this._transport.getOptionalContentConfig()
          }

          getPermissions() {
            return this._transport.getPermissions()
          }

          getMetadata() {
            return this._transport.getMetadata()
          }

          getMarkInfo() {
            return this._transport.getMarkInfo()
          }

          getData() {
            return this._transport.getData()
          }

          getDownloadInfo() {
            return this._transport.downloadInfoCapability.promise
          }

          cleanup() {
            const e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
            return this._transport.startCleanup(e || this.isPureXfa)
          }

          destroy() {
            return this.loadingTask.destroy()
          }

          get loadingParams() {
            return this._transport.loadingParams
          }

          get loadingTask() {
            return this._transport.loadingTask
          }

          saveDocument() {
            this._transport.annotationStorage.size <= 0 &&
              (0, _display_utils.deprecated)(
                'saveDocument called while `annotationStorage` is empty, please use the getData-method instead.'
              )
            return this._transport.saveDocument()
          }

          getFieldObjects() {
            return this._transport.getFieldObjects()
          }

          hasJSActions() {
            return this._transport.hasJSActions()
          }

          getCalculationOrderIds() {
            return this._transport.getCalculationOrderIds()
          }
        }
        exports.PDFDocumentProxy = PDFDocumentProxy
        class PDFPageProxy {
          constructor(e, t, i, n) {
            const s = arguments.length > 4 && void 0 !== arguments[4] && arguments[4]
            this._pageIndex = e
            this._pageInfo = t
            this._ownerDocument = n
            this._transport = i
            this._stats = s ? new _display_utils.StatTimer() : null
            this._pdfBug = s
            this.commonObjs = i.commonObjs
            this.objs = new PDFObjects()
            this._bitmaps = new Set()
            this.cleanupAfterRender = !1
            this.pendingCleanup = !1
            this._intentStates = new Map()
            this._annotationPromises = new Map()
            this.destroyed = !1
          }

          get pageNumber() {
            return this._pageIndex + 1
          }

          get rotate() {
            return this._pageInfo.rotate
          }

          get ref() {
            return this._pageInfo.ref
          }

          get userUnit() {
            return this._pageInfo.userUnit
          }

          get view() {
            return this._pageInfo.view
          }

          getViewport() {
            const {
              scale: e,
              rotation: t = this.rotate,
              offsetX: i = 0,
              offsetY: n = 0,
              dontFlip: s = !1
            } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
            return new _display_utils.PageViewport({
              viewBox: this.view,
              scale: e,
              rotation: t,
              offsetX: i,
              offsetY: n,
              dontFlip: s
            })
          }

          getAnnotations() {
            const { intent: e = 'display' } =
              arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
            const t = this._transport.getRenderingIntent(e)
            let i = this._annotationPromises.get(t.cacheKey)
            if (!i) {
              i = this._transport.getAnnotations(this._pageIndex, t.renderingIntent)
              this._annotationPromises.set(t.cacheKey, i)
              i = i.then((e) => {
                for (const t of e) {
                  void 0 !== t.titleObj &&
                    Object.defineProperty(t, 'title', {
                      get() {
                        ;(0, _display_utils.deprecated)(
                          '`title`-property on annotation, please use `titleObj` instead.'
                        )
                        return t.titleObj.str
                      }
                    })
                  void 0 !== t.contentsObj &&
                    Object.defineProperty(t, 'contents', {
                      get() {
                        ;(0, _display_utils.deprecated)(
                          '`contents`-property on annotation, please use `contentsObj` instead.'
                        )
                        return t.contentsObj.str
                      }
                    })
                }
                return e
              })
            }
            return i
          }

          getJSActions() {
            return (
              this._jsActionsPromise ||
              (this._jsActionsPromise = this._transport.getPageJSActions(this._pageIndex))
            )
          }

          async getXfa() {
            let e
            return (
              ((e = this._transport._htmlForXfa) === null || void 0 === e
                ? void 0
                : e.children[this._pageIndex]) || null
            )
          }

          render(e) {
            let t
            let i
            let n
            let {
              canvasContext: s,
              viewport: a,
              intent: r = 'display',
              annotationMode: o = _util.AnnotationMode.ENABLE,
              transform: l = null,
              imageLayer: c = null,
              canvasFactory: d = null,
              background: h = null,
              optionalContentConfigPromise: u = null,
              annotationCanvasMap: p = null,
              pageColors: g = null,
              printAnnotationStorage: f = null
            } = e
            if (
              void 0 !==
              ((t = arguments[0]) === null || void 0 === t ? void 0 : t.renderInteractiveForms)
            ) {
              ;(0, _display_utils.deprecated)(
                'render no longer accepts the `renderInteractiveForms`-option, please use the `annotationMode`-option instead.'
              )
              !0 === arguments[0].renderInteractiveForms &&
                o === _util.AnnotationMode.ENABLE &&
                (o = _util.AnnotationMode.ENABLE_FORMS)
            }
            if (
              void 0 !==
              ((i = arguments[0]) === null || void 0 === i ? void 0 : i.includeAnnotationStorage)
            ) {
              ;(0, _display_utils.deprecated)(
                'render no longer accepts the `includeAnnotationStorage`-option, please use the `annotationMode`-option instead.'
              )
              !0 === arguments[0].includeAnnotationStorage &&
                o === _util.AnnotationMode.ENABLE &&
                (o = _util.AnnotationMode.ENABLE_STORAGE)
            }
            this._stats && this._stats.time('Overall')
            const m = this._transport.getRenderingIntent(r, o, f)
            this.pendingCleanup = !1
            u || (u = this._transport.getOptionalContentConfig())
            let v = this._intentStates.get(m.cacheKey)
            if (!v) {
              v = Object.create(null)
              this._intentStates.set(m.cacheKey, v)
            }
            if (v.streamReaderCancelTimeout) {
              clearTimeout(v.streamReaderCancelTimeout)
              v.streamReaderCancelTimeout = null
            }
            const _ = d || new DefaultCanvasFactory({ ownerDocument: this._ownerDocument })
            const b = !!(m.renderingIntent & _util.RenderingIntentFlag.PRINT)
            if (!v.displayReadyCapability) {
              v.displayReadyCapability = (0, _util.createPromiseCapability)()
              v.operatorList = { fnArray: [], argsArray: [], lastChunk: !1, separateAnnots: null }
              this._stats && this._stats.time('Page Request')
              this._pumpOperatorList(m)
            }
            const complete = (e) => {
              v.renderTasks.delete(w)
              ;(this.cleanupAfterRender || b) && (this.pendingCleanup = !0)
              this._tryCleanup()
              if (e) {
                w.capability.reject(e)
                this._abortOperatorList({
                  intentState: v,
                  reason: e instanceof Error ? e : new Error(e)
                })
              } else w.capability.resolve()
              if (this._stats) {
                this._stats.timeEnd('Rendering')
                this._stats.timeEnd('Overall')
              }
            }
            const w = new InternalRenderTask({
              callback: complete,
              params: {
                canvasContext: s,
                viewport: a,
                transform: l,
                imageLayer: c,
                background: h
              },
              objs: this.objs,
              commonObjs: this.commonObjs,
              annotationCanvasMap: p,
              operatorList: v.operatorList,
              pageIndex: this._pageIndex,
              canvasFactory: _,
              useRequestAnimationFrame: !b,
              pdfBug: this._pdfBug,
              pageColors: g
            })
            ;((n = v).renderTasks || (n.renderTasks = new Set())).add(w)
            const P = w.task
            Promise.all([v.displayReadyCapability.promise, u])
              .then((e) => {
                const [t, i] = e
                if (this.pendingCleanup) complete()
                else {
                  this._stats && this._stats.time('Rendering')
                  w.initializeGraphics({ transparency: t, optionalContentConfig: i })
                  w.operatorListChanged()
                }
              })
              .catch(complete)
            return P
          }

          getOperatorList() {
            const {
              intent: e = 'display',
              annotationMode: t = _util.AnnotationMode.ENABLE,
              printAnnotationStorage: i = null
            } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
            const n = this._transport.getRenderingIntent(e, t, i, !0)
            let s
            let a = this._intentStates.get(n.cacheKey)
            if (!a) {
              a = Object.create(null)
              this._intentStates.set(n.cacheKey, a)
            }
            if (!a.opListReadCapability) {
              let r
              s = Object.create(null)
              s.operatorListChanged = function operatorListChanged() {
                if (a.operatorList.lastChunk) {
                  a.opListReadCapability.resolve(a.operatorList)
                  a.renderTasks.delete(s)
                }
              }
              a.opListReadCapability = (0, _util.createPromiseCapability)()
              ;((r = a).renderTasks || (r.renderTasks = new Set())).add(s)
              a.operatorList = { fnArray: [], argsArray: [], lastChunk: !1, separateAnnots: null }
              this._stats && this._stats.time('Page Request')
              this._pumpOperatorList(n)
            }
            return a.opListReadCapability.promise
          }

          streamTextContent() {
            const { disableCombineTextItems: e = !1, includeMarkedContent: t = !1 } =
              arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
            return this._transport.messageHandler.sendWithStream(
              'GetTextContent',
              {
                pageIndex: this._pageIndex,
                combineTextItems: !0 !== e,
                includeMarkedContent: !0 === t
              },
              { highWaterMark: 100, size: (e) => e.items.length }
            )
          }

          getTextContent() {
            const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
            if (this._transport._htmlForXfa)
              return this.getXfa().then((e) => _xfa_text.XfaText.textContent(e))
            const t = this.streamTextContent(e)
            return new Promise(function (e, i) {
              const n = t.getReader()
              const s = { items: [], styles: Object.create(null) }
              !(function pump() {
                n.read().then(function (t) {
                  const { value: i, done: n } = t
                  if (n) e(s)
                  else {
                    Object.assign(s.styles, i.styles)
                    s.items.push(...i.items)
                    pump()
                  }
                }, i)
              })()
            })
          }

          getStructTree() {
            return (
              this._structTreePromise ||
              (this._structTreePromise = this._transport.getStructTree(this._pageIndex))
            )
          }

          _destroy() {
            this.destroyed = !0
            const e = []
            for (const t of this._intentStates.values()) {
              this._abortOperatorList({
                intentState: t,
                reason: new Error('Page was destroyed.'),
                force: !0
              })
              if (!t.opListReadCapability)
                for (const i of t.renderTasks) {
                  e.push(i.completed)
                  i.cancel()
                }
            }
            this.objs.clear()
            for (const e of this._bitmaps) e.close()
            this._bitmaps.clear()
            this._annotationPromises.clear()
            this._jsActionsPromise = null
            this._structTreePromise = null
            this.pendingCleanup = !1
            return Promise.all(e)
          }

          cleanup() {
            const e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
            this.pendingCleanup = !0
            return this._tryCleanup(e)
          }

          _tryCleanup() {
            const e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
            if (!this.pendingCleanup) return !1
            for (const { renderTasks: e, operatorList: t } of this._intentStates.values())
              if (e.size > 0 || !t.lastChunk) return !1
            this._intentStates.clear()
            this.objs.clear()
            this._annotationPromises.clear()
            this._jsActionsPromise = null
            this._structTreePromise = null
            e && this._stats && (this._stats = new _display_utils.StatTimer())
            for (const e of this._bitmaps) e.close()
            this._bitmaps.clear()
            this.pendingCleanup = !1
            return !0
          }

          _startRenderPage(e, t) {
            const i = this._intentStates.get(t)
            if (i) {
              this._stats && this._stats.timeEnd('Page Request')
              i.displayReadyCapability && i.displayReadyCapability.resolve(e)
            }
          }

          _renderPageChunk(e, t) {
            for (let i = 0, n = e.length; i < n; i++) {
              t.operatorList.fnArray.push(e.fnArray[i])
              t.operatorList.argsArray.push(e.argsArray[i])
            }
            t.operatorList.lastChunk = e.lastChunk
            t.operatorList.separateAnnots = e.separateAnnots
            for (const e of t.renderTasks) e.operatorListChanged()
            e.lastChunk && this._tryCleanup()
          }

          _pumpOperatorList(e) {
            const { renderingIntent: t, cacheKey: i, annotationStorageMap: n } = e
            const s = this._transport.messageHandler
              .sendWithStream('GetOperatorList', {
                pageIndex: this._pageIndex,
                intent: t,
                cacheKey: i,
                annotationStorage: n
              })
              .getReader()
            const a = this._intentStates.get(i)
            a.streamReader = s
            const pump = () => {
              s.read().then(
                (e) => {
                  const { value: t, done: i } = e
                  if (i) a.streamReader = null
                  else if (!this._transport.destroyed) {
                    this._renderPageChunk(t, a)
                    pump()
                  }
                },
                (e) => {
                  a.streamReader = null
                  if (!this._transport.destroyed) {
                    if (a.operatorList) {
                      a.operatorList.lastChunk = !0
                      for (const e of a.renderTasks) e.operatorListChanged()
                      this._tryCleanup()
                    }
                    if (a.displayReadyCapability) a.displayReadyCapability.reject(e)
                    else {
                      if (!a.opListReadCapability) throw e
                      a.opListReadCapability.reject(e)
                    }
                  }
                }
              )
            }
            pump()
          }

          _abortOperatorList(e) {
            const { intentState: t, reason: i, force: n = !1 } = e
            if (t.streamReader) {
              if (!n) {
                if (t.renderTasks.size > 0) return
                if (i instanceof _display_utils.RenderingCancelledException) {
                  t.streamReaderCancelTimeout = setTimeout(() => {
                    this._abortOperatorList({ intentState: t, reason: i, force: !0 })
                    t.streamReaderCancelTimeout = null
                  }, RENDERING_CANCELLED_TIMEOUT)
                  return
                }
              }
              t.streamReader.cancel(new _util.AbortException(i.message)).catch(() => {})
              t.streamReader = null
              if (!this._transport.destroyed) {
                for (const [e, i] of this._intentStates)
                  if (i === t) {
                    this._intentStates.delete(e)
                    break
                  }
                this.cleanup()
              }
            }
          }

          get stats() {
            return this._stats
          }
        }
        exports.PDFPageProxy = PDFPageProxy
        class LoopbackPort {
          constructor() {
            this._listeners = []
            this._deferred = Promise.resolve()
          }

          postMessage(e, t) {
            const i = { data: structuredClone(e, t) }
            this._deferred.then(() => {
              for (const e of this._listeners) e.call(this, i)
            })
          }

          addEventListener(e, t) {
            this._listeners.push(t)
          }

          removeEventListener(e, t) {
            const i = this._listeners.indexOf(t)
            this._listeners.splice(i, 1)
          }

          terminate() {
            this._listeners.length = 0
          }
        }
        exports.LoopbackPort = LoopbackPort
        const PDFWorkerUtil = { isWorkerDisabled: !1, fallbackWorkerSrc: null, fakeWorkerId: 0 }
        exports.PDFWorkerUtil = PDFWorkerUtil
        if (_is_node.isNodeJS && typeof require === 'function') {
          PDFWorkerUtil.isWorkerDisabled = !0
          PDFWorkerUtil.fallbackWorkerSrc = './pdf.worker.js'
        } else if (typeof document === 'object') {
          let _document
          let _document$currentScri
          const e =
            (_document = document) === null ||
            void 0 === _document ||
            (_document$currentScri = _document.currentScript) === null ||
            void 0 === _document$currentScri
              ? void 0
              : _document$currentScri.src
          e &&
            (PDFWorkerUtil.fallbackWorkerSrc = e.replace(
              /(\.(?:min\.)?js)(\?.*)?$/i,
              '.worker$1$2'
            ))
        }
        PDFWorkerUtil.isSameOrigin = function (e, t) {
          let i
          try {
            i = new URL(e)
            if (!i.origin || i.origin === 'null') return !1
          } catch (e) {
            return !1
          }
          const n = new URL(t, i)
          return i.origin === n.origin
        }
        PDFWorkerUtil.createCDNWrapper = function (e) {
          const t = `importScripts("${e}");`
          return URL.createObjectURL(new Blob([t]))
        }
        class PDFWorker {
          constructor() {
            const {
              name: e = null,
              port: t = null,
              verbosity: i = (0, _util.getVerbosityLevel)()
            } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
            if (t && _classStaticPrivateFieldSpecGet(PDFWorker, PDFWorker, _workerPorts).has(t))
              throw new Error('Cannot use more than one PDFWorker per port.')
            this.name = e
            this.destroyed = !1
            this.verbosity = i
            this._readyCapability = (0, _util.createPromiseCapability)()
            this._port = null
            this._webWorker = null
            this._messageHandler = null
            if (t) {
              _classStaticPrivateFieldSpecGet(PDFWorker, PDFWorker, _workerPorts).set(t, this)
              this._initializeFromPort(t)
            } else this._initialize()
          }

          get promise() {
            return this._readyCapability.promise
          }

          get port() {
            return this._port
          }

          get messageHandler() {
            return this._messageHandler
          }

          _initializeFromPort(e) {
            this._port = e
            this._messageHandler = new _message_handler.MessageHandler('main', 'worker', e)
            this._messageHandler.on('ready', function () {})
            this._readyCapability.resolve()
          }

          _initialize() {
            if (!PDFWorkerUtil.isWorkerDisabled && !PDFWorker._mainThreadWorkerMessageHandler) {
              let { workerSrc: e } = PDFWorker
              try {
                PDFWorkerUtil.isSameOrigin(window.location.href, e) ||
                  (e = PDFWorkerUtil.createCDNWrapper(new URL(e, window.location).href))
                const t = new Worker(e)
                const i = new _message_handler.MessageHandler('main', 'worker', t)
                const terminateEarly = () => {
                  t.removeEventListener('error', onWorkerError)
                  i.destroy()
                  t.terminate()
                  this.destroyed
                    ? this._readyCapability.reject(new Error('Worker was destroyed'))
                    : this._setupFakeWorker()
                }
                const onWorkerError = () => {
                  this._webWorker || terminateEarly()
                }
                t.addEventListener('error', onWorkerError)
                i.on('test', (e) => {
                  t.removeEventListener('error', onWorkerError)
                  if (this.destroyed) terminateEarly()
                  else if (e) {
                    this._messageHandler = i
                    this._port = t
                    this._webWorker = t
                    this._readyCapability.resolve()
                    i.send('configure', { verbosity: this.verbosity })
                  } else {
                    this._setupFakeWorker()
                    i.destroy()
                    t.terminate()
                  }
                })
                i.on('ready', (e) => {
                  t.removeEventListener('error', onWorkerError)
                  if (this.destroyed) terminateEarly()
                  else
                    try {
                      sendTest()
                    } catch (e) {
                      this._setupFakeWorker()
                    }
                })
                const sendTest = () => {
                  const e = new Uint8Array()
                  i.send('test', e, [e.buffer])
                }
                sendTest()
                return
              } catch (e) {
                ;(0, _util.info)('The worker has been disabled.')
              }
            }
            this._setupFakeWorker()
          }

          _setupFakeWorker() {
            if (!PDFWorkerUtil.isWorkerDisabled) {
              ;(0, _util.warn)('Setting up fake worker.')
              PDFWorkerUtil.isWorkerDisabled = !0
            }
            PDFWorker._setupFakeWorkerGlobal
              .then((e) => {
                if (this.destroyed) {
                  this._readyCapability.reject(new Error('Worker was destroyed'))
                  return
                }
                const t = new LoopbackPort()
                this._port = t
                const i = `fake${PDFWorkerUtil.fakeWorkerId++}`
                const n = new _message_handler.MessageHandler(`${i}_worker`, i, t)
                e.setup(n, t)
                const s = new _message_handler.MessageHandler(i, `${i}_worker`, t)
                this._messageHandler = s
                this._readyCapability.resolve()
                s.send('configure', { verbosity: this.verbosity })
              })
              .catch((e) => {
                this._readyCapability.reject(
                  new Error(`Setting up fake worker failed: "${e.message}".`)
                )
              })
          }

          destroy() {
            this.destroyed = !0
            if (this._webWorker) {
              this._webWorker.terminate()
              this._webWorker = null
            }
            _classStaticPrivateFieldSpecGet(PDFWorker, PDFWorker, _workerPorts).delete(this._port)
            this._port = null
            if (this._messageHandler) {
              this._messageHandler.destroy()
              this._messageHandler = null
            }
          }

          static fromPort(e) {
            if (e == null || !e.port)
              throw new Error('PDFWorker.fromPort - invalid method signature.')
            return _classStaticPrivateFieldSpecGet(this, PDFWorker, _workerPorts).has(e.port)
              ? _classStaticPrivateFieldSpecGet(this, PDFWorker, _workerPorts).get(e.port)
              : new PDFWorker(e)
          }

          static get workerSrc() {
            if (_worker_options.GlobalWorkerOptions.workerSrc)
              return _worker_options.GlobalWorkerOptions.workerSrc
            if (PDFWorkerUtil.fallbackWorkerSrc !== null) {
              _is_node.isNodeJS ||
                (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.')
              return PDFWorkerUtil.fallbackWorkerSrc
            }
            throw new Error('No "GlobalWorkerOptions.workerSrc" specified.')
          }

          static get _mainThreadWorkerMessageHandler() {
            try {
              let e
              return (
                ((e = globalThis.pdfjsWorker) === null || void 0 === e
                  ? void 0
                  : e.WorkerMessageHandler) || null
              )
            } catch (e) {
              return null
            }
          }

          static get _setupFakeWorkerGlobal() {
            const loader = async () => {
              const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler
              if (mainWorkerMessageHandler) return mainWorkerMessageHandler
              if (_is_node.isNodeJS && typeof require === 'function') {
                const worker = eval('require')(this.workerSrc)
                return worker.WorkerMessageHandler
              }
              await (0, _display_utils.loadScript)(this.workerSrc)
              return window.pdfjsWorker.WorkerMessageHandler
            }
            return (0, _util.shadow)(this, '_setupFakeWorkerGlobal', loader())
          }
        }
        exports.PDFWorker = PDFWorker
        var _workerPorts = { writable: !0, value: new WeakMap() }
        PDFWorker.getWorkerSrc = function () {
          ;(0, _display_utils.deprecated)(
            '`PDFWorker.getWorkerSrc()`, please use `PDFWorker.workerSrc` instead.'
          )
          return this.workerSrc
        }
        const _docStats = new WeakMap()
        const _pageCache = new WeakMap()
        const _pagePromises = new WeakMap()
        const _metadataPromise = new WeakMap()
        class WorkerTransport {
          constructor(e, t, i, n) {
            _classPrivateFieldInitSpec(this, _docStats, { writable: !0, value: null })
            _classPrivateFieldInitSpec(this, _pageCache, { writable: !0, value: new Map() })
            _classPrivateFieldInitSpec(this, _pagePromises, { writable: !0, value: new Map() })
            _classPrivateFieldInitSpec(this, _metadataPromise, { writable: !0, value: null })
            this.messageHandler = e
            this.loadingTask = t
            this.commonObjs = new PDFObjects()
            this.fontLoader = new _font_loader.FontLoader({
              docId: t.docId,
              onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
              ownerDocument: n.ownerDocument,
              styleElement: n.styleElement
            })
            this._params = n
            if (!n.useWorkerFetch) {
              this.CMapReaderFactory = new n.CMapReaderFactory({
                baseUrl: n.cMapUrl,
                isCompressed: n.cMapPacked
              })
              this.StandardFontDataFactory = new n.StandardFontDataFactory({
                baseUrl: n.standardFontDataUrl
              })
            }
            this.destroyed = !1
            this.destroyCapability = null
            this._passwordCapability = null
            this._networkStream = i
            this._fullReader = null
            this._lastProgress = null
            this.downloadInfoCapability = (0, _util.createPromiseCapability)()
            this.setupMessageHandler()
          }

          get annotationStorage() {
            return (0, _util.shadow)(
              this,
              'annotationStorage',
              new _annotation_storage.AnnotationStorage()
            )
          }

          get stats() {
            return _classPrivateFieldGet(this, _docStats)
          }

          getRenderingIntent(e) {
            const t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : _util.AnnotationMode.ENABLE
            const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
            const n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]
            let s = _util.RenderingIntentFlag.DISPLAY
            let a = null
            switch (e) {
              case 'any':
                s = _util.RenderingIntentFlag.ANY
                break
              case 'display':
                break
              case 'print':
                s = _util.RenderingIntentFlag.PRINT
                break
              default:
                ;(0, _util.warn)(`getRenderingIntent - invalid intent: ${e}`)
            }
            switch (t) {
              case _util.AnnotationMode.DISABLE:
                s += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE
                break
              case _util.AnnotationMode.ENABLE:
                break
              case _util.AnnotationMode.ENABLE_FORMS:
                s += _util.RenderingIntentFlag.ANNOTATIONS_FORMS
                break
              case _util.AnnotationMode.ENABLE_STORAGE:
                s += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE
                a = (
                  s & _util.RenderingIntentFlag.PRINT &&
                  i instanceof _annotation_storage.PrintAnnotationStorage
                    ? i
                    : this.annotationStorage
                ).serializable
                break
              default:
                ;(0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${t}`)
            }
            n && (s += _util.RenderingIntentFlag.OPLIST)
            return {
              renderingIntent: s,
              cacheKey: `${s}_${_annotation_storage.AnnotationStorage.getHash(a)}`,
              annotationStorageMap: a
            }
          }

          destroy() {
            if (this.destroyCapability) return this.destroyCapability.promise
            this.destroyed = !0
            this.destroyCapability = (0, _util.createPromiseCapability)()
            this._passwordCapability &&
              this._passwordCapability.reject(
                new Error('Worker was destroyed during onPassword callback')
              )
            const e = []
            for (const t of _classPrivateFieldGet(this, _pageCache).values()) e.push(t._destroy())
            _classPrivateFieldGet(this, _pageCache).clear()
            _classPrivateFieldGet(this, _pagePromises).clear()
            this.hasOwnProperty('annotationStorage') && this.annotationStorage.resetModified()
            const t = this.messageHandler.sendWithPromise('Terminate', null)
            e.push(t)
            Promise.all(e).then(() => {
              this.commonObjs.clear()
              this.fontLoader.clear()
              _classPrivateFieldSet(this, _metadataPromise, null)
              this._getFieldObjectsPromise = null
              this._hasJSActionsPromise = null
              this._networkStream &&
                this._networkStream.cancelAllRequests(
                  new _util.AbortException('Worker was terminated.')
                )
              if (this.messageHandler) {
                this.messageHandler.destroy()
                this.messageHandler = null
              }
              this.destroyCapability.resolve()
            }, this.destroyCapability.reject)
            return this.destroyCapability.promise
          }

          setupMessageHandler() {
            const { messageHandler: e, loadingTask: t } = this
            e.on('GetReader', (e, t) => {
              ;(0, _util.assert)(
                this._networkStream,
                'GetReader - no `IPDFStream` instance available.'
              )
              this._fullReader = this._networkStream.getFullReader()
              this._fullReader.onProgress = (e) => {
                this._lastProgress = { loaded: e.loaded, total: e.total }
              }
              t.onPull = () => {
                this._fullReader
                  .read()
                  .then(function (e) {
                    const { value: i, done: n } = e
                    if (n) t.close()
                    else {
                      ;(0, _util.assert)(
                        (0, _util.isArrayBuffer)(i),
                        'GetReader - expected an ArrayBuffer.'
                      )
                      t.enqueue(new Uint8Array(i), 1, [i])
                    }
                  })
                  .catch((e) => {
                    t.error(e)
                  })
              }
              t.onCancel = (e) => {
                this._fullReader.cancel(e)
                t.ready.catch((e) => {
                  if (!this.destroyed) throw e
                })
              }
            })
            e.on('ReaderHeadersReady', (e) => {
              const i = (0, _util.createPromiseCapability)()
              const n = this._fullReader
              n.headersReady.then(() => {
                if (!n.isStreamingSupported || !n.isRangeSupported) {
                  if (this._lastProgress) {
                    let e
                    ;(e = t.onProgress) === null || void 0 === e || e.call(t, this._lastProgress)
                  }
                  n.onProgress = (e) => {
                    let i
                    ;(i = t.onProgress) === null ||
                      void 0 === i ||
                      i.call(t, { loaded: e.loaded, total: e.total })
                  }
                }
                i.resolve({
                  isStreamingSupported: n.isStreamingSupported,
                  isRangeSupported: n.isRangeSupported,
                  contentLength: n.contentLength
                })
              }, i.reject)
              return i.promise
            })
            e.on('GetRangeReader', (e, t) => {
              ;(0, _util.assert)(
                this._networkStream,
                'GetRangeReader - no `IPDFStream` instance available.'
              )
              const i = this._networkStream.getRangeReader(e.begin, e.end)
              if (i) {
                t.onPull = () => {
                  i.read()
                    .then(function (e) {
                      const { value: i, done: n } = e
                      if (n) t.close()
                      else {
                        ;(0, _util.assert)(
                          (0, _util.isArrayBuffer)(i),
                          'GetRangeReader - expected an ArrayBuffer.'
                        )
                        t.enqueue(new Uint8Array(i), 1, [i])
                      }
                    })
                    .catch((e) => {
                      t.error(e)
                    })
                }
                t.onCancel = (e) => {
                  i.cancel(e)
                  t.ready.catch((e) => {
                    if (!this.destroyed) throw e
                  })
                }
              } else t.close()
            })
            e.on('GetDoc', (e) => {
              const { pdfInfo: i } = e
              this._numPages = i.numPages
              this._htmlForXfa = i.htmlForXfa
              delete i.htmlForXfa
              t._capability.resolve(new PDFDocumentProxy(i, this))
            })
            e.on('DocException', function (e) {
              let i
              switch (e.name) {
                case 'PasswordException':
                  i = new _util.PasswordException(e.message, e.code)
                  break
                case 'InvalidPDFException':
                  i = new _util.InvalidPDFException(e.message)
                  break
                case 'MissingPDFException':
                  i = new _util.MissingPDFException(e.message)
                  break
                case 'UnexpectedResponseException':
                  i = new _util.UnexpectedResponseException(e.message, e.status)
                  break
                case 'UnknownErrorException':
                  i = new _util.UnknownErrorException(e.message, e.details)
                  break
                default:
                  ;(0, _util.unreachable)('DocException - expected a valid Error.')
              }
              t._capability.reject(i)
            })
            e.on('PasswordRequest', (e) => {
              this._passwordCapability = (0, _util.createPromiseCapability)()
              if (t.onPassword) {
                const updatePassword = (e) => {
                  e instanceof Error
                    ? this._passwordCapability.reject(e)
                    : this._passwordCapability.resolve({ password: e })
                }
                try {
                  t.onPassword(updatePassword, e.code)
                } catch (e) {
                  this._passwordCapability.reject(e)
                }
              } else this._passwordCapability.reject(new _util.PasswordException(e.message, e.code))
              return this._passwordCapability.promise
            })
            e.on('DataLoaded', (e) => {
              let i
              ;(i = t.onProgress) === null ||
                void 0 === i ||
                i.call(t, { loaded: e.length, total: e.length })
              this.downloadInfoCapability.resolve(e)
            })
            e.on('StartRenderPage', (e) => {
              if (this.destroyed) return
              _classPrivateFieldGet(this, _pageCache)
                .get(e.pageIndex)
                ._startRenderPage(e.transparency, e.cacheKey)
            })
            e.on('commonobj', (t) => {
              let i
              const [n, s, a] = t
              if (!this.destroyed && !this.commonObjs.has(n))
                switch (s) {
                  case 'Font':
                    const t = this._params
                    if ('error' in a) {
                      const e = a.error
                      ;(0, _util.warn)(`Error during font loading: ${e}`)
                      this.commonObjs.resolve(n, e)
                      break
                    }
                    let r = null
                    t.pdfBug &&
                      (i = globalThis.FontInspector) !== null &&
                      void 0 !== i &&
                      i.enabled &&
                      (r = {
                        registerFont(e, t) {
                          globalThis.FontInspector.fontAdded(e, t)
                        }
                      })
                    const o = new _font_loader.FontFaceObject(a, {
                      isEvalSupported: t.isEvalSupported,
                      disableFontFace: t.disableFontFace,
                      ignoreErrors: t.ignoreErrors,
                      onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
                      fontRegistry: r
                    })
                    this.fontLoader
                      .bind(o)
                      .catch((t) => e.sendWithPromise('FontFallback', { id: n }))
                      .finally(() => {
                        !t.fontExtraProperties && o.data && (o.data = null)
                        this.commonObjs.resolve(n, o)
                      })
                    break
                  case 'FontPath':
                  case 'Image':
                    this.commonObjs.resolve(n, a)
                    break
                  default:
                    throw new Error(`Got unknown common object type ${s}`)
                }
            })
            e.on('obj', (e) => {
              const [t, i, n, s] = e
              if (this.destroyed) return
              const a = _classPrivateFieldGet(this, _pageCache).get(i)
              if (!a.objs.has(t))
                switch (n) {
                  case 'Image':
                    a.objs.resolve(t, s)
                    const e = 8e6
                    if (s) {
                      let t
                      if (s.bitmap) {
                        const { bitmap: e, width: i, height: n } = s
                        t = i * n * 4
                        a._bitmaps.add(e)
                      } else {
                        let r
                        t = ((r = s.data) === null || void 0 === r ? void 0 : r.length) || 0
                      }
                      t > e && (a.cleanupAfterRender = !0)
                    }
                    break
                  case 'Pattern':
                    a.objs.resolve(t, s)
                    break
                  default:
                    throw new Error(`Got unknown object type ${n}`)
                }
            })
            e.on('DocProgress', (e) => {
              let i
              this.destroyed ||
                (i = t.onProgress) === null ||
                void 0 === i ||
                i.call(t, { loaded: e.loaded, total: e.total })
            })
            e.on('DocStats', (e) => {
              this.destroyed ||
                _classPrivateFieldSet(
                  this,
                  _docStats,
                  Object.freeze({
                    streamTypes: Object.freeze(e.streamTypes),
                    fontTypes: Object.freeze(e.fontTypes)
                  })
                )
            })
            e.on('UnsupportedFeature', this._onUnsupportedFeature.bind(this))
            e.on('FetchBuiltInCMap', (e) =>
              this.destroyed
                ? Promise.reject(new Error('Worker was destroyed.'))
                : this.CMapReaderFactory
                ? this.CMapReaderFactory.fetch(e)
                : Promise.reject(
                    new Error(
                      'CMapReaderFactory not initialized, see the `useWorkerFetch` parameter.'
                    )
                  )
            )
            e.on('FetchStandardFontData', (e) =>
              this.destroyed
                ? Promise.reject(new Error('Worker was destroyed.'))
                : this.StandardFontDataFactory
                ? this.StandardFontDataFactory.fetch(e)
                : Promise.reject(
                    new Error(
                      'StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.'
                    )
                  )
            )
          }

          _onUnsupportedFeature(e) {
            let t
            let i
            const { featureId: n } = e
            this.destroyed ||
              (t = (i = this.loadingTask).onUnsupportedFeature) === null ||
              void 0 === t ||
              t.call(i, n)
          }

          getData() {
            return this.messageHandler.sendWithPromise('GetData', null)
          }

          getPage(e) {
            if (!Number.isInteger(e) || e <= 0 || e > this._numPages)
              return Promise.reject(new Error('Invalid page request.'))
            const t = e - 1
            const i = _classPrivateFieldGet(this, _pagePromises).get(t)
            if (i) return i
            const n = this.messageHandler.sendWithPromise('GetPage', { pageIndex: t }).then((e) => {
              if (this.destroyed) throw new Error('Transport destroyed')
              const i = new PDFPageProxy(
                t,
                e,
                this,
                this._params.ownerDocument,
                this._params.pdfBug
              )
              _classPrivateFieldGet(this, _pageCache).set(t, i)
              return i
            })
            _classPrivateFieldGet(this, _pagePromises).set(t, n)
            return n
          }

          getPageIndex(e) {
            return typeof e !== 'object' ||
              e === null ||
              !Number.isInteger(e.num) ||
              e.num < 0 ||
              !Number.isInteger(e.gen) ||
              e.gen < 0
              ? Promise.reject(new Error('Invalid pageIndex request.'))
              : this.messageHandler.sendWithPromise('GetPageIndex', { num: e.num, gen: e.gen })
          }

          getAnnotations(e, t) {
            return this.messageHandler.sendWithPromise('GetAnnotations', {
              pageIndex: e,
              intent: t
            })
          }

          saveDocument() {
            let e
            let t
            return this.messageHandler
              .sendWithPromise('SaveDocument', {
                isPureXfa: !!this._htmlForXfa,
                numPages: this._numPages,
                annotationStorage: this.annotationStorage.serializable,
                filename:
                  (e = (t = this._fullReader) === null || void 0 === t ? void 0 : t.filename) !==
                    null && void 0 !== e
                    ? e
                    : null
              })
              .finally(() => {
                this.annotationStorage.resetModified()
              })
          }

          getFieldObjects() {
            return (
              this._getFieldObjectsPromise ||
              (this._getFieldObjectsPromise = this.messageHandler.sendWithPromise(
                'GetFieldObjects',
                null
              ))
            )
          }

          hasJSActions() {
            return (
              this._hasJSActionsPromise ||
              (this._hasJSActionsPromise = this.messageHandler.sendWithPromise(
                'HasJSActions',
                null
              ))
            )
          }

          getCalculationOrderIds() {
            return this.messageHandler.sendWithPromise('GetCalculationOrderIds', null)
          }

          getDestinations() {
            return this.messageHandler.sendWithPromise('GetDestinations', null)
          }

          getDestination(e) {
            return typeof e !== 'string'
              ? Promise.reject(new Error('Invalid destination request.'))
              : this.messageHandler.sendWithPromise('GetDestination', { id: e })
          }

          getPageLabels() {
            return this.messageHandler.sendWithPromise('GetPageLabels', null)
          }

          getPageLayout() {
            return this.messageHandler.sendWithPromise('GetPageLayout', null)
          }

          getPageMode() {
            return this.messageHandler.sendWithPromise('GetPageMode', null)
          }

          getViewerPreferences() {
            return this.messageHandler.sendWithPromise('GetViewerPreferences', null)
          }

          getOpenAction() {
            return this.messageHandler.sendWithPromise('GetOpenAction', null)
          }

          getAttachments() {
            return this.messageHandler.sendWithPromise('GetAttachments', null)
          }

          getJavaScript() {
            return this.messageHandler.sendWithPromise('GetJavaScript', null)
          }

          getDocJSActions() {
            return this.messageHandler.sendWithPromise('GetDocJSActions', null)
          }

          getPageJSActions(e) {
            return this.messageHandler.sendWithPromise('GetPageJSActions', { pageIndex: e })
          }

          getStructTree(e) {
            return this.messageHandler.sendWithPromise('GetStructTree', { pageIndex: e })
          }

          getOutline() {
            return this.messageHandler.sendWithPromise('GetOutline', null)
          }

          getOptionalContentConfig() {
            return this.messageHandler
              .sendWithPromise('GetOptionalContentConfig', null)
              .then((e) => new _optional_content_config.OptionalContentConfig(e))
          }

          getPermissions() {
            return this.messageHandler.sendWithPromise('GetPermissions', null)
          }

          getMetadata() {
            return (
              _classPrivateFieldGet(this, _metadataPromise) ||
              _classPrivateFieldSet(
                this,
                _metadataPromise,
                this.messageHandler.sendWithPromise('GetMetadata', null).then((e) => {
                  let t
                  let i
                  let n
                  let s
                  return {
                    info: e[0],
                    metadata: e[1] ? new _metadata.Metadata(e[1]) : null,
                    contentDispositionFilename:
                      (t =
                        (i = this._fullReader) === null || void 0 === i ? void 0 : i.filename) !==
                        null && void 0 !== t
                        ? t
                        : null,
                    contentLength:
                      (n =
                        (s = this._fullReader) === null || void 0 === s
                          ? void 0
                          : s.contentLength) !== null && void 0 !== n
                        ? n
                        : null
                  }
                })
              )
            )
          }

          getMarkInfo() {
            return this.messageHandler.sendWithPromise('GetMarkInfo', null)
          }

          async startCleanup() {
            const e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
            await this.messageHandler.sendWithPromise('Cleanup', null)
            if (!this.destroyed) {
              for (const e of _classPrivateFieldGet(this, _pageCache).values()) {
                if (!e.cleanup())
                  throw new Error(`startCleanup: Page ${e.pageNumber} is currently rendering.`)
              }
              this.commonObjs.clear()
              e || this.fontLoader.clear()
              _classPrivateFieldSet(this, _metadataPromise, null)
              this._getFieldObjectsPromise = null
              this._hasJSActionsPromise = null
            }
          }

          get loadingParams() {
            const e = this._params
            return (0, _util.shadow)(this, 'loadingParams', {
              disableAutoFetch: e.disableAutoFetch,
              enableXfa: e.enableXfa
            })
          }
        }
        const _objs = new WeakMap()
        const _ensureObj = new WeakSet()
        class PDFObjects {
          constructor() {
            _classPrivateMethodInitSpec(this, _ensureObj)
            _classPrivateFieldInitSpec(this, _objs, { writable: !0, value: Object.create(null) })
          }

          get(e) {
            const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
            if (t) {
              const i = _classPrivateMethodGet(this, _ensureObj, _ensureObj2).call(this, e)
              i.capability.promise.then(() => t(i.data))
              return null
            }
            const i = _classPrivateFieldGet(this, _objs)[e]
            if (i == null || !i.capability.settled)
              throw new Error(`Requesting object that isn't resolved yet ${e}.`)
            return i.data
          }

          has(e) {
            const t = _classPrivateFieldGet(this, _objs)[e]
            return (t == null ? void 0 : t.capability.settled) || !1
          }

          resolve(e) {
            const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
            const i = _classPrivateMethodGet(this, _ensureObj, _ensureObj2).call(this, e)
            i.data = t
            i.capability.resolve()
          }

          clear() {
            _classPrivateFieldSet(this, _objs, Object.create(null))
          }
        }
        function _ensureObj2(e) {
          const t = _classPrivateFieldGet(this, _objs)[e]
          return (
            t ||
            (_classPrivateFieldGet(this, _objs)[e] = {
              capability: (0, _util.createPromiseCapability)(),
              data: null
            })
          )
        }
        const _internalRenderTask = new WeakMap()
        class RenderTask {
          constructor(e) {
            _classPrivateFieldInitSpec(this, _internalRenderTask, { writable: !0, value: null })
            _classPrivateFieldSet(this, _internalRenderTask, e)
            this.onContinue = null
          }

          get promise() {
            return _classPrivateFieldGet(this, _internalRenderTask).capability.promise
          }

          cancel() {
            _classPrivateFieldGet(this, _internalRenderTask).cancel()
          }

          get separateAnnots() {
            const { separateAnnots: e } = _classPrivateFieldGet(
              this,
              _internalRenderTask
            ).operatorList
            if (!e) return !1
            const { annotationCanvasMap: t } = _classPrivateFieldGet(this, _internalRenderTask)
            return e.form || (e.canvas && (t == null ? void 0 : t.size) > 0)
          }
        }
        exports.RenderTask = RenderTask
        class InternalRenderTask {
          constructor(e) {
            const {
              callback: t,
              params: i,
              objs: n,
              commonObjs: s,
              annotationCanvasMap: a,
              operatorList: r,
              pageIndex: o,
              canvasFactory: l,
              useRequestAnimationFrame: c = !1,
              pdfBug: d = !1,
              pageColors: h = null
            } = e
            this.callback = t
            this.params = i
            this.objs = n
            this.commonObjs = s
            this.annotationCanvasMap = a
            this.operatorListIdx = null
            this.operatorList = r
            this._pageIndex = o
            this.canvasFactory = l
            this._pdfBug = d
            this.pageColors = h
            this.running = !1
            this.graphicsReadyCallback = null
            this.graphicsReady = !1
            this._useRequestAnimationFrame = !0 === c && typeof window !== 'undefined'
            this.cancelled = !1
            this.capability = (0, _util.createPromiseCapability)()
            this.task = new RenderTask(this)
            this._cancelBound = this.cancel.bind(this)
            this._continueBound = this._continue.bind(this)
            this._scheduleNextBound = this._scheduleNext.bind(this)
            this._nextBound = this._next.bind(this)
            this._canvas = i.canvasContext.canvas
          }

          get completed() {
            return this.capability.promise.catch(function () {})
          }

          initializeGraphics(e) {
            let t
            const { transparency: i = !1, optionalContentConfig: n } = e
            if (this.cancelled) return
            if (this._canvas) {
              if (
                _classStaticPrivateFieldSpecGet(
                  InternalRenderTask,
                  InternalRenderTask,
                  _canvasInUse
                ).has(this._canvas)
              )
                throw new Error(
                  'Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.'
                )
              _classStaticPrivateFieldSpecGet(
                InternalRenderTask,
                InternalRenderTask,
                _canvasInUse
              ).add(this._canvas)
            }
            if (
              this._pdfBug &&
              (t = globalThis.StepperManager) !== null &&
              void 0 !== t &&
              t.enabled
            ) {
              this.stepper = globalThis.StepperManager.create(this._pageIndex)
              this.stepper.init(this.operatorList)
              this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint()
            }
            const {
              canvasContext: s,
              viewport: a,
              transform: r,
              imageLayer: o,
              background: l
            } = this.params
            this.gfx = new _canvas.CanvasGraphics(
              s,
              this.commonObjs,
              this.objs,
              this.canvasFactory,
              o,
              n,
              this.annotationCanvasMap,
              this.pageColors
            )
            this.gfx.beginDrawing({ transform: r, viewport: a, transparency: i, background: l })
            this.operatorListIdx = 0
            this.graphicsReady = !0
            this.graphicsReadyCallback && this.graphicsReadyCallback()
          }

          cancel() {
            const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
            this.running = !1
            this.cancelled = !0
            this.gfx && this.gfx.endDrawing()
            this._canvas &&
              _classStaticPrivateFieldSpecGet(
                InternalRenderTask,
                InternalRenderTask,
                _canvasInUse
              ).delete(this._canvas)
            this.callback(
              e ||
                new _display_utils.RenderingCancelledException(
                  `Rendering cancelled, page ${this._pageIndex + 1}`,
                  'canvas'
                )
            )
          }

          operatorListChanged() {
            if (this.graphicsReady) {
              this.stepper && this.stepper.updateOperatorList(this.operatorList)
              this.running || this._continue()
            } else this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound)
          }

          _continue() {
            this.running = !0
            this.cancelled ||
              (this.task.onContinue
                ? this.task.onContinue(this._scheduleNextBound)
                : this._scheduleNext())
          }

          _scheduleNext() {
            this._useRequestAnimationFrame
              ? window.requestAnimationFrame(() => {
                  this._nextBound().catch(this._cancelBound)
                })
              : Promise.resolve().then(this._nextBound).catch(this._cancelBound)
          }

          async _next() {
            if (!this.cancelled) {
              this.operatorListIdx = this.gfx.executeOperatorList(
                this.operatorList,
                this.operatorListIdx,
                this._continueBound,
                this.stepper
              )
              if (this.operatorListIdx === this.operatorList.argsArray.length) {
                this.running = !1
                if (this.operatorList.lastChunk) {
                  this.gfx.endDrawing()
                  this._canvas &&
                    _classStaticPrivateFieldSpecGet(
                      InternalRenderTask,
                      InternalRenderTask,
                      _canvasInUse
                    ).delete(this._canvas)
                  this.callback()
                }
              }
            }
          }
        }
        var _canvasInUse = { writable: !0, value: new WeakSet() }
        const version = '2.16.0'
        exports.version = version
        const build = 'a5460d6'
        exports.build = build
      },
      (e, t, i) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.PrintAnnotationStorage = t.AnnotationStorage = void 0
        const n = i(1)
        const s = i(131)
        const a = i(135)
        function _classPrivateFieldSet(e, t, i) {
          !(function _classApplyDescriptorSet(e, t, i) {
            if (t.set) t.set.call(e, i)
            else {
              if (!t.writable) throw new TypeError('attempted to set read only private field')
              t.value = i
            }
          })(e, _classExtractFieldDescriptor(e, t, 'set'), i)
          return i
        }
        function _classExtractFieldDescriptor(e, t, i) {
          if (!t.has(e)) throw new TypeError(`attempted to ${i} private field on non-instance`)
          return t.get(e)
        }
        function _checkPrivateRedeclaration(e, t) {
          if (t.has(e))
            throw new TypeError('Cannot initialize the same private elements twice on an object')
        }
        const r = new WeakSet()
        class AnnotationStorage {
          constructor() {
            !(function _classPrivateMethodInitSpec(e, t) {
              _checkPrivateRedeclaration(e, t)
              t.add(e)
            })(this, r)
            this._storage = new Map()
            this._modified = !1
            this.onSetModified = null
            this.onResetModified = null
            this.onAnnotationEditor = null
          }

          getValue(e, t) {
            const i = this._storage.get(e)
            return void 0 === i ? t : Object.assign(t, i)
          }

          getRawValue(e) {
            return this._storage.get(e)
          }

          remove(e) {
            this._storage.delete(e)
            this._storage.size === 0 && this.resetModified()
            if (typeof this.onAnnotationEditor === 'function') {
              for (const e of this._storage.values()) if (e instanceof s.AnnotationEditor) return
              this.onAnnotationEditor(null)
            }
          }

          setValue(e, t) {
            const i = this._storage.get(e)
            let n = !1
            if (void 0 !== i) {
              for (const [e, s] of Object.entries(t))
                if (i[e] !== s) {
                  n = !0
                  i[e] = s
                }
            } else {
              n = !0
              this._storage.set(e, t)
            }
            n &&
              (function _classPrivateMethodGet(e, t, i) {
                if (!t.has(e)) throw new TypeError('attempted to get private field on non-instance')
                return i
              })(this, r, _setModified2).call(this)
            t instanceof s.AnnotationEditor &&
              typeof this.onAnnotationEditor === 'function' &&
              this.onAnnotationEditor(t.constructor._type)
          }

          has(e) {
            return this._storage.has(e)
          }

          getAll() {
            return this._storage.size > 0 ? (0, n.objectFromMap)(this._storage) : null
          }

          get size() {
            return this._storage.size
          }

          resetModified() {
            if (this._modified) {
              this._modified = !1
              typeof this.onResetModified === 'function' && this.onResetModified()
            }
          }

          get print() {
            return new PrintAnnotationStorage(this)
          }

          get serializable() {
            if (this._storage.size === 0) return null
            const e = new Map()
            for (const [t, i] of this._storage) {
              const n = i instanceof s.AnnotationEditor ? i.serialize() : i
              n && e.set(t, n)
            }
            return e
          }

          static getHash(e) {
            if (!e) return ''
            const t = new a.MurmurHash3_64()
            for (const [i, n] of e) t.update(`${i}:${JSON.stringify(n)}`)
            return t.hexdigest()
          }
        }
        t.AnnotationStorage = AnnotationStorage
        function _setModified2() {
          if (!this._modified) {
            this._modified = !0
            typeof this.onSetModified === 'function' && this.onSetModified()
          }
        }
        const o = new WeakMap()
        class PrintAnnotationStorage extends AnnotationStorage {
          constructor(e) {
            super()
            !(function _classPrivateFieldInitSpec(e, t, i) {
              _checkPrivateRedeclaration(e, t)
              t.set(e, i)
            })(this, o, { writable: !0, value: null })
            _classPrivateFieldSet(this, o, structuredClone(e.serializable))
          }

          get print() {
            ;(0, n.unreachable)('Should not call PrintAnnotationStorage.print')
          }

          get serializable() {
            return (function _classPrivateFieldGet(e, t) {
              return (function _classApplyDescriptorGet(e, t) {
                return t.get ? t.get.call(e) : t.value
              })(e, _classExtractFieldDescriptor(e, t, 'get'))
            })(this, o)
          }
        }
        t.PrintAnnotationStorage = PrintAnnotationStorage
      },
      (e, t, i) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.AnnotationEditor = void 0
        const n = i(132)
        const s = i(1)
        function _defineProperty(e, t, i) {
          t in e
            ? Object.defineProperty(e, t, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
              })
            : (e[t] = i)
          return e
        }
        function _classPrivateFieldInitSpec(e, t, i) {
          !(function _checkPrivateRedeclaration(e, t) {
            if (t.has(e))
              throw new TypeError('Cannot initialize the same private elements twice on an object')
          })(e, t)
          t.set(e, i)
        }
        function _classPrivateFieldSet(e, t, i) {
          !(function _classApplyDescriptorSet(e, t, i) {
            if (t.set) t.set.call(e, i)
            else {
              if (!t.writable) throw new TypeError('attempted to set read only private field')
              t.value = i
            }
          })(e, _classExtractFieldDescriptor(e, t, 'set'), i)
          return i
        }
        function _classPrivateFieldGet(e, t) {
          return (function _classApplyDescriptorGet(e, t) {
            if (t.get) return t.get.call(e)
            return t.value
          })(e, _classExtractFieldDescriptor(e, t, 'get'))
        }
        function _classExtractFieldDescriptor(e, t, i) {
          if (!t.has(e)) throw new TypeError(`attempted to ${i} private field on non-instance`)
          return t.get(e)
        }
        const a = new WeakMap()
        const r = new WeakMap()
        const o = new WeakMap()
        const l = new WeakMap()
        const c = new WeakMap()
        const d = new WeakMap()
        class AnnotationEditor {
          constructor(e) {
            _classPrivateFieldInitSpec(this, a, { writable: !0, value: this.focusin.bind(this) })
            _classPrivateFieldInitSpec(this, r, { writable: !0, value: this.focusout.bind(this) })
            _classPrivateFieldInitSpec(this, o, { writable: !0, value: !1 })
            _classPrivateFieldInitSpec(this, l, { writable: !0, value: !1 })
            _classPrivateFieldInitSpec(this, c, { writable: !0, value: !1 })
            _classPrivateFieldInitSpec(this, d, {
              writable: !0,
              value: AnnotationEditor._zIndex++
            })
            this.constructor === AnnotationEditor &&
              (0, s.unreachable)('Cannot initialize AnnotationEditor.')
            this.parent = e.parent
            this.id = e.id
            this.width = this.height = null
            this.pageIndex = e.parent.pageIndex
            this.name = e.name
            this.div = null
            const [t, i] = this.parent.viewportBaseDimensions
            this.x = e.x / t
            this.y = e.y / i
            this.rotation = this.parent.viewport.rotation
            this.isAttachedToDOM = !1
          }

          static get _defaultLineColor() {
            return (0, s.shadow)(
              this,
              '_defaultLineColor',
              this._colorManager.getHexCode('CanvasText')
            )
          }

          setInBackground() {
            this.div.style.zIndex = 0
          }

          setInForeground() {
            this.div.style.zIndex = _classPrivateFieldGet(this, d)
          }

          focusin(e) {
            _classPrivateFieldGet(this, o)
              ? _classPrivateFieldSet(this, o, !1)
              : this.parent.setSelected(this)
          }

          focusout(e) {
            if (!this.isAttachedToDOM) return
            const t = e.relatedTarget
            if (t == null || !t.closest(`#${this.id}`)) {
              e.preventDefault()
              this.parent.isMultipleSelection || this.commitOrRemove()
            }
          }

          commitOrRemove() {
            this.isEmpty() ? this.remove() : this.commit()
          }

          commit() {
            this.parent.addToAnnotationStorage(this)
          }

          dragstart(e) {
            const t = this.parent.div.getBoundingClientRect()
            this.startX = e.clientX - t.x
            this.startY = e.clientY - t.y
            e.dataTransfer.setData('text/plain', this.id)
            e.dataTransfer.effectAllowed = 'move'
          }

          setAt(e, t, i, n) {
            const [s, a] = this.parent.viewportBaseDimensions
            ;[i, n] = this.screenToPageTranslation(i, n)
            this.x = (e + i) / s
            this.y = (t + n) / a
            this.div.style.left = `${100 * this.x}%`
            this.div.style.top = `${100 * this.y}%`
          }

          translate(e, t) {
            const [i, n] = this.parent.viewportBaseDimensions
            ;[e, t] = this.screenToPageTranslation(e, t)
            this.x += e / i
            this.y += t / n
            this.div.style.left = `${100 * this.x}%`
            this.div.style.top = `${100 * this.y}%`
          }

          screenToPageTranslation(e, t) {
            const { rotation: i } = this.parent.viewport
            switch (i) {
              case 90:
                return [t, -e]
              case 180:
                return [-e, -t]
              case 270:
                return [-t, e]
              default:
                return [e, t]
            }
          }

          setDims(e, t) {
            const [i, n] = this.parent.viewportBaseDimensions
            this.div.style.width = `${(100 * e) / i}%`
            this.div.style.height = `${(100 * t) / n}%`
          }

          getInitialTranslation() {
            return [0, 0]
          }

          render() {
            this.div = document.createElement('div')
            this.div.setAttribute('data-editor-rotation', (360 - this.rotation) % 360)
            this.div.className = this.name
            this.div.setAttribute('id', this.id)
            this.div.setAttribute('tabIndex', 0)
            this.setInForeground()
            this.div.addEventListener('focusin', _classPrivateFieldGet(this, a))
            this.div.addEventListener('focusout', _classPrivateFieldGet(this, r))
            const [e, t] = this.getInitialTranslation()
            this.translate(e, t)
            ;(0, n.bindEvents)(this, this.div, ['dragstart', 'pointerdown'])
            return this.div
          }

          pointerdown(e) {
            const t = n.KeyboardManager.platform.isMac
            if (e.button !== 0 || (e.ctrlKey && t)) e.preventDefault()
            else {
              ;(e.ctrlKey && !t) || e.shiftKey || (e.metaKey && t)
                ? this.parent.toggleSelected(this)
                : this.parent.setSelected(this)
              _classPrivateFieldSet(this, o, !0)
            }
          }

          getRect(e, t) {
            const [i, n] = this.parent.viewportBaseDimensions
            const [s, a] = this.parent.pageDimensions
            const r = (s * e) / i
            const o = (a * t) / n
            const l = this.x * s
            const c = this.y * a
            const d = this.width * s
            const h = this.height * a
            switch (this.rotation) {
              case 0:
                return [l + r, a - c - o - h, l + r + d, a - c - o]
              case 90:
                return [l + o, a - c + r, l + o + h, a - c + r + d]
              case 180:
                return [l - r - d, a - c + o, l - r, a - c + o + h]
              case 270:
                return [l - o - h, a - c - r - d, l - o, a - c - r]
              default:
                throw new Error('Invalid rotation')
            }
          }

          getRectInCurrentCoords(e, t) {
            const [i, n, s, a] = e
            const r = s - i
            const o = a - n
            switch (this.rotation) {
              case 0:
                return [i, t - a, r, o]
              case 90:
                return [i, t - n, o, r]
              case 180:
                return [s, t - n, r, o]
              case 270:
                return [s, t - a, o, r]
              default:
                throw new Error('Invalid rotation')
            }
          }

          onceAdded() {}

          isEmpty() {
            return !1
          }

          enableEditMode() {
            _classPrivateFieldSet(this, c, !0)
          }

          disableEditMode() {
            _classPrivateFieldSet(this, c, !1)
          }

          isInEditMode() {
            return _classPrivateFieldGet(this, c)
          }

          shouldGetKeyboardEvents() {
            return !1
          }

          needsToBeRebuilt() {
            return this.div && !this.isAttachedToDOM
          }

          rebuild() {
            let e
            ;(e = this.div) === null ||
              void 0 === e ||
              e.addEventListener('focusin', _classPrivateFieldGet(this, a))
          }

          serialize() {
            ;(0, s.unreachable)('An editor must be serializable')
          }

          static deserialize(e, t) {
            const i = new this.prototype.constructor({ parent: t, id: t.getNextId() })
            i.rotation = e.rotation
            const [n, s] = t.pageDimensions
            const [a, r, o, l] = i.getRectInCurrentCoords(e.rect, s)
            i.x = a / n
            i.y = r / s
            i.width = o / n
            i.height = l / s
            return i
          }

          remove() {
            this.div.removeEventListener('focusin', _classPrivateFieldGet(this, a))
            this.div.removeEventListener('focusout', _classPrivateFieldGet(this, r))
            this.isEmpty() || this.commit()
            this.parent.remove(this)
          }

          select() {
            let e
            ;(e = this.div) === null || void 0 === e || e.classList.add('selectedEditor')
          }

          unselect() {
            let e
            ;(e = this.div) === null || void 0 === e || e.classList.remove('selectedEditor')
          }

          updateParams(e, t) {}

          disableEditing() {}

          enableEditing() {}

          get propertiesToUpdate() {
            return {}
          }

          get contentDiv() {
            return this.div
          }

          get isEditing() {
            return _classPrivateFieldGet(this, l)
          }

          set isEditing(e) {
            _classPrivateFieldSet(this, l, e)
            if (e) {
              this.parent.setSelected(this)
              this.parent.setActiveEditor(this)
            } else this.parent.setActiveEditor(null)
          }
        }
        t.AnnotationEditor = AnnotationEditor
        _defineProperty(AnnotationEditor, '_colorManager', new n.ColorManager())
        _defineProperty(AnnotationEditor, '_zIndex', 1)
      },
      (e, t, i) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.KeyboardManager = t.CommandManager = t.ColorManager = t.AnnotationEditorUIManager = void 0
        t.bindEvents = function bindEvents(e, t, i) {
          for (const n of i) t.addEventListener(n, e[n].bind(e))
        }
        t.opacityToHex = function opacityToHex(e) {
          return Math.round(Math.min(255, Math.max(1, 255 * e)))
            .toString(16)
            .padStart(2, '0')
        }
        const n = i(1)
        const s = i(133)
        function _defineProperty(e, t, i) {
          t in e
            ? Object.defineProperty(e, t, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
              })
            : (e[t] = i)
          return e
        }
        function _classPrivateMethodInitSpec(e, t) {
          _checkPrivateRedeclaration(e, t)
          t.add(e)
        }
        function _classPrivateMethodGet(e, t, i) {
          if (!t.has(e)) throw new TypeError('attempted to get private field on non-instance')
          return i
        }
        function _classPrivateFieldInitSpec(e, t, i) {
          _checkPrivateRedeclaration(e, t)
          t.set(e, i)
        }
        function _checkPrivateRedeclaration(e, t) {
          if (t.has(e))
            throw new TypeError('Cannot initialize the same private elements twice on an object')
        }
        function _classPrivateFieldSet(e, t, i) {
          !(function _classApplyDescriptorSet(e, t, i) {
            if (t.set) t.set.call(e, i)
            else {
              if (!t.writable) throw new TypeError('attempted to set read only private field')
              t.value = i
            }
          })(e, _classExtractFieldDescriptor(e, t, 'set'), i)
          return i
        }
        function _classPrivateFieldGet(e, t) {
          return (function _classApplyDescriptorGet(e, t) {
            if (t.get) return t.get.call(e)
            return t.value
          })(e, _classExtractFieldDescriptor(e, t, 'get'))
        }
        function _classExtractFieldDescriptor(e, t, i) {
          if (!t.has(e)) throw new TypeError(`attempted to ${i} private field on non-instance`)
          return t.get(e)
        }
        const a = new WeakMap()
        class IdManager {
          constructor() {
            _classPrivateFieldInitSpec(this, a, { writable: !0, value: 0 })
          }

          getId() {
            let e
            let t
            return `${n.AnnotationEditorPrefix}${
              (_classPrivateFieldSet(this, a, ((e = _classPrivateFieldGet(this, a)), (t = e++), e)),
              t)
            }`
          }
        }
        const r = new WeakMap()
        const o = new WeakMap()
        const l = new WeakMap()
        const c = new WeakMap()
        class CommandManager {
          constructor() {
            const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 128
            _classPrivateFieldInitSpec(this, r, { writable: !0, value: [] })
            _classPrivateFieldInitSpec(this, o, { writable: !0, value: !1 })
            _classPrivateFieldInitSpec(this, l, { writable: !0, value: void 0 })
            _classPrivateFieldInitSpec(this, c, { writable: !0, value: -1 })
            _classPrivateFieldSet(this, l, e)
          }

          add(e) {
            const {
              cmd: t,
              undo: i,
              mustExec: n,
              type: s = NaN,
              overwriteIfSameType: a = !1,
              keepUndo: d = !1
            } = e
            n && t()
            if (_classPrivateFieldGet(this, o)) return
            const h = { cmd: t, undo: i, type: s }
            if (_classPrivateFieldGet(this, c) === -1) {
              _classPrivateFieldGet(this, r).length > 0 &&
                (_classPrivateFieldGet(this, r).length = 0)
              _classPrivateFieldSet(this, c, 0)
              _classPrivateFieldGet(this, r).push(h)
              return
            }
            if (a && _classPrivateFieldGet(this, r)[_classPrivateFieldGet(this, c)].type === s) {
              d && (h.undo = _classPrivateFieldGet(this, r)[_classPrivateFieldGet(this, c)].undo)
              _classPrivateFieldGet(this, r)[_classPrivateFieldGet(this, c)] = h
              return
            }
            const u = _classPrivateFieldGet(this, c) + 1
            if (u === _classPrivateFieldGet(this, l)) _classPrivateFieldGet(this, r).splice(0, 1)
            else {
              _classPrivateFieldSet(this, c, u)
              u < _classPrivateFieldGet(this, r).length && _classPrivateFieldGet(this, r).splice(u)
            }
            _classPrivateFieldGet(this, r).push(h)
          }

          undo() {
            if (_classPrivateFieldGet(this, c) !== -1) {
              _classPrivateFieldSet(this, o, !0)
              _classPrivateFieldGet(this, r)[_classPrivateFieldGet(this, c)].undo()
              _classPrivateFieldSet(this, o, !1)
              _classPrivateFieldSet(this, c, _classPrivateFieldGet(this, c) - 1)
            }
          }

          redo() {
            if (_classPrivateFieldGet(this, c) < _classPrivateFieldGet(this, r).length - 1) {
              _classPrivateFieldSet(this, c, _classPrivateFieldGet(this, c) + 1)
              _classPrivateFieldSet(this, o, !0)
              _classPrivateFieldGet(this, r)[_classPrivateFieldGet(this, c)].cmd()
              _classPrivateFieldSet(this, o, !1)
            }
          }

          hasSomethingToUndo() {
            return _classPrivateFieldGet(this, c) !== -1
          }

          hasSomethingToRedo() {
            return _classPrivateFieldGet(this, c) < _classPrivateFieldGet(this, r).length - 1
          }

          destroy() {
            _classPrivateFieldSet(this, r, null)
          }
        }
        t.CommandManager = CommandManager
        const d = new WeakSet()
        class KeyboardManager {
          constructor(e) {
            _classPrivateMethodInitSpec(this, d)
            this.buffer = []
            this.callbacks = new Map()
            this.allKeys = new Set()
            const t = KeyboardManager.platform.isMac
            for (const [i, n] of e)
              for (const e of i) {
                const i = e.startsWith('mac+')
                if (t && i) {
                  this.callbacks.set(e.slice(4), n)
                  this.allKeys.add(e.split('+').at(-1))
                } else if (!t && !i) {
                  this.callbacks.set(e, n)
                  this.allKeys.add(e.split('+').at(-1))
                }
              }
          }

          static get platform() {
            const e = typeof navigator !== 'undefined' ? navigator.platform : ''
            return (0, n.shadow)(this, 'platform', {
              isWin: e.includes('Win'),
              isMac: e.includes('Mac')
            })
          }

          exec(e, t) {
            if (!this.allKeys.has(t.key)) return
            const i = this.callbacks.get(_classPrivateMethodGet(this, d, _serialize2).call(this, t))
            if (i) {
              i.bind(e)()
              t.stopPropagation()
              t.preventDefault()
            }
          }
        }
        t.KeyboardManager = KeyboardManager
        function _serialize2(e) {
          e.altKey && this.buffer.push('alt')
          e.ctrlKey && this.buffer.push('ctrl')
          e.metaKey && this.buffer.push('meta')
          e.shiftKey && this.buffer.push('shift')
          this.buffer.push(e.key)
          const t = this.buffer.join('+')
          this.buffer.length = 0
          return t
        }
        const h = new WeakMap()
        class ClipboardManager {
          constructor() {
            _classPrivateFieldInitSpec(this, h, { writable: !0, value: null })
          }

          copy(e) {
            if (e) {
              Array.isArray(e)
                ? _classPrivateFieldSet(
                    this,
                    h,
                    e.map((e) => e.serialize())
                  )
                : _classPrivateFieldSet(this, h, [e.serialize()])
              _classPrivateFieldSet(
                this,
                h,
                _classPrivateFieldGet(this, h).filter((e) => !!e)
              )
              _classPrivateFieldGet(this, h).length === 0 && _classPrivateFieldSet(this, h, null)
            }
          }

          paste() {
            return _classPrivateFieldGet(this, h)
          }

          isEmpty() {
            return _classPrivateFieldGet(this, h) === null
          }

          destroy() {
            _classPrivateFieldSet(this, h, null)
          }
        }
        class ColorManager {
          get _colors() {
            const e = new Map([
              ['CanvasText', null],
              ['Canvas', null]
            ])
            ;(0, s.getColorValues)(e)
            return (0, n.shadow)(this, '_colors', e)
          }

          convert(e) {
            const t = (0, s.getRGB)(e)
            if (!window.matchMedia('(forced-colors: active)').matches) return t
            for (const [e, i] of this._colors)
              if (i.every((e, i) => e === t[i])) return ColorManager._colorsMapping.get(e)
            return t
          }

          getHexCode(e) {
            const t = this._colors.get(e)
            return t ? n.Util.makeHexColor(...t) : e
          }
        }
        t.ColorManager = ColorManager
        _defineProperty(
          ColorManager,
          '_colorsMapping',
          new Map([
            ['CanvasText', [0, 0, 0]],
            ['Canvas', [255, 255, 255]]
          ])
        )
        const u = new WeakMap()
        const p = new WeakMap()
        const g = new WeakMap()
        const f = new WeakMap()
        const m = new WeakMap()
        const v = new WeakMap()
        const _ = new WeakMap()
        const b = new WeakMap()
        const w = new WeakMap()
        const P = new WeakMap()
        const y = new WeakMap()
        const S = new WeakMap()
        const A = new WeakMap()
        const E = new WeakMap()
        const x = new WeakMap()
        const C = new WeakMap()
        const M = new WeakMap()
        const T = new WeakSet()
        const k = new WeakSet()
        const I = new WeakSet()
        const D = new WeakSet()
        const L = new WeakSet()
        const R = new WeakSet()
        const O = new WeakSet()
        const N = new WeakSet()
        const B = new WeakSet()
        class AnnotationEditorUIManager {
          constructor(e, t) {
            _classPrivateMethodInitSpec(this, B)
            _classPrivateMethodInitSpec(this, N)
            _classPrivateMethodInitSpec(this, O)
            _classPrivateMethodInitSpec(this, R)
            _classPrivateMethodInitSpec(this, L)
            _classPrivateMethodInitSpec(this, D)
            _classPrivateMethodInitSpec(this, I)
            _classPrivateMethodInitSpec(this, k)
            _classPrivateMethodInitSpec(this, T)
            _classPrivateFieldInitSpec(this, u, { writable: !0, value: null })
            _classPrivateFieldInitSpec(this, p, { writable: !0, value: new Map() })
            _classPrivateFieldInitSpec(this, g, { writable: !0, value: new Map() })
            _classPrivateFieldInitSpec(this, f, { writable: !0, value: new ClipboardManager() })
            _classPrivateFieldInitSpec(this, m, { writable: !0, value: new CommandManager() })
            _classPrivateFieldInitSpec(this, v, { writable: !0, value: 0 })
            _classPrivateFieldInitSpec(this, _, { writable: !0, value: null })
            _classPrivateFieldInitSpec(this, b, { writable: !0, value: null })
            _classPrivateFieldInitSpec(this, w, { writable: !0, value: new IdManager() })
            _classPrivateFieldInitSpec(this, P, { writable: !0, value: !1 })
            _classPrivateFieldInitSpec(this, y, {
              writable: !0,
              value: n.AnnotationEditorType.NONE
            })
            _classPrivateFieldInitSpec(this, S, { writable: !0, value: new Set() })
            _classPrivateFieldInitSpec(this, A, { writable: !0, value: this.keydown.bind(this) })
            _classPrivateFieldInitSpec(this, E, {
              writable: !0,
              value: this.onEditingAction.bind(this)
            })
            _classPrivateFieldInitSpec(this, x, {
              writable: !0,
              value: this.onPageChanging.bind(this)
            })
            _classPrivateFieldInitSpec(this, C, {
              writable: !0,
              value: {
                isEditing: !1,
                isEmpty: !0,
                hasEmptyClipboard: !0,
                hasSomethingToUndo: !1,
                hasSomethingToRedo: !1,
                hasSelectedEditor: !1
              }
            })
            _classPrivateFieldInitSpec(this, M, { writable: !0, value: null })
            _classPrivateFieldSet(this, M, e)
            _classPrivateFieldSet(this, b, t)
            _classPrivateFieldGet(this, b)._on('editingaction', _classPrivateFieldGet(this, E))
            _classPrivateFieldGet(this, b)._on('pagechanging', _classPrivateFieldGet(this, x))
          }

          destroy() {
            _classPrivateMethodGet(this, k, _removeKeyboardManager2).call(this)
            _classPrivateFieldGet(this, b)._off('editingaction', _classPrivateFieldGet(this, E))
            _classPrivateFieldGet(this, b)._off('pagechanging', _classPrivateFieldGet(this, x))
            for (const e of _classPrivateFieldGet(this, g).values()) e.destroy()
            _classPrivateFieldGet(this, g).clear()
            _classPrivateFieldGet(this, p).clear()
            _classPrivateFieldSet(this, u, null)
            _classPrivateFieldGet(this, S).clear()
            _classPrivateFieldGet(this, f).destroy()
            _classPrivateFieldGet(this, m).destroy()
          }

          onPageChanging(e) {
            const { pageNumber: t } = e
            _classPrivateFieldSet(this, v, t - 1)
          }

          focusMainContainer() {
            _classPrivateFieldGet(this, M).focus()
          }

          keydown(e) {
            let t
            ;((t = this.getActive()) !== null && void 0 !== t && t.shouldGetKeyboardEvents()) ||
              AnnotationEditorUIManager._keyboardManager.exec(this, e)
          }

          onEditingAction(e) {
            ;['undo', 'redo', 'cut', 'copy', 'paste', 'delete', 'selectAll'].includes(e.name) &&
              this[e.name]()
          }

          setEditingState(e) {
            if (e) {
              _classPrivateMethodGet(this, T, _addKeyboardManager2).call(this)
              _classPrivateMethodGet(this, I, _dispatchUpdateStates2).call(this, {
                isEditing: _classPrivateFieldGet(this, y) !== n.AnnotationEditorType.NONE,
                isEmpty: _classPrivateMethodGet(this, N, _isEmpty2).call(this),
                hasSomethingToUndo: _classPrivateFieldGet(this, m).hasSomethingToUndo(),
                hasSomethingToRedo: _classPrivateFieldGet(this, m).hasSomethingToRedo(),
                hasSelectedEditor: !1,
                hasEmptyClipboard: _classPrivateFieldGet(this, f).isEmpty()
              })
            } else {
              _classPrivateMethodGet(this, k, _removeKeyboardManager2).call(this)
              _classPrivateMethodGet(this, I, _dispatchUpdateStates2).call(this, {
                isEditing: !1
              })
            }
          }

          registerEditorTypes(e) {
            _classPrivateFieldSet(this, _, e)
            for (const e of _classPrivateFieldGet(this, _))
              _classPrivateMethodGet(this, D, _dispatchUpdateUI2).call(
                this,
                e.defaultPropertiesToUpdate
              )
          }

          getId() {
            return _classPrivateFieldGet(this, w).getId()
          }

          addLayer(e) {
            _classPrivateFieldGet(this, g).set(e.pageIndex, e)
            _classPrivateFieldGet(this, P) ? e.enable() : e.disable()
          }

          removeLayer(e) {
            _classPrivateFieldGet(this, g).delete(e.pageIndex)
          }

          updateMode(e) {
            _classPrivateFieldSet(this, y, e)
            if (e === n.AnnotationEditorType.NONE) {
              this.setEditingState(!1)
              _classPrivateMethodGet(this, R, _disableAll2).call(this)
            } else {
              this.setEditingState(!0)
              _classPrivateMethodGet(this, L, _enableAll2).call(this)
              for (const t of _classPrivateFieldGet(this, g).values()) t.updateMode(e)
            }
          }

          updateToolbar(e) {
            e !== _classPrivateFieldGet(this, y) &&
              _classPrivateFieldGet(this, b).dispatch('switchannotationeditormode', {
                source: this,
                mode: e
              })
          }

          updateParams(e, t) {
            for (const i of _classPrivateFieldGet(this, S)) i.updateParams(e, t)
            for (const i of _classPrivateFieldGet(this, _)) i.updateDefaultParams(e, t)
          }

          getEditors(e) {
            const t = []
            for (const i of _classPrivateFieldGet(this, p).values()) i.pageIndex === e && t.push(i)
            return t
          }

          getEditor(e) {
            return _classPrivateFieldGet(this, p).get(e)
          }

          addEditor(e) {
            _classPrivateFieldGet(this, p).set(e.id, e)
          }

          removeEditor(e) {
            _classPrivateFieldGet(this, p).delete(e.id)
            this.unselect(e)
          }

          setActiveEditor(e) {
            if (_classPrivateFieldGet(this, u) !== e) {
              _classPrivateFieldSet(this, u, e)
              e &&
                _classPrivateMethodGet(this, D, _dispatchUpdateUI2).call(this, e.propertiesToUpdate)
            }
          }

          toggleSelected(e) {
            if (_classPrivateFieldGet(this, S).has(e)) {
              _classPrivateFieldGet(this, S).delete(e)
              e.unselect()
              _classPrivateMethodGet(this, I, _dispatchUpdateStates2).call(this, {
                hasSelectedEditor: this.hasSelection
              })
            } else {
              _classPrivateFieldGet(this, S).add(e)
              e.select()
              _classPrivateMethodGet(this, D, _dispatchUpdateUI2).call(this, e.propertiesToUpdate)
              _classPrivateMethodGet(this, I, _dispatchUpdateStates2).call(this, {
                hasSelectedEditor: !0
              })
            }
          }

          setSelected(e) {
            for (const t of _classPrivateFieldGet(this, S)) t !== e && t.unselect()
            _classPrivateFieldGet(this, S).clear()
            _classPrivateFieldGet(this, S).add(e)
            e.select()
            _classPrivateMethodGet(this, D, _dispatchUpdateUI2).call(this, e.propertiesToUpdate)
            _classPrivateMethodGet(this, I, _dispatchUpdateStates2).call(this, {
              hasSelectedEditor: !0
            })
          }

          isSelected(e) {
            return _classPrivateFieldGet(this, S).has(e)
          }

          unselect(e) {
            e.unselect()
            _classPrivateFieldGet(this, S).delete(e)
            _classPrivateMethodGet(this, I, _dispatchUpdateStates2).call(this, {
              hasSelectedEditor: this.hasSelection
            })
          }

          get hasSelection() {
            return _classPrivateFieldGet(this, S).size !== 0
          }

          undo() {
            _classPrivateFieldGet(this, m).undo()
            _classPrivateMethodGet(this, I, _dispatchUpdateStates2).call(this, {
              hasSomethingToUndo: _classPrivateFieldGet(this, m).hasSomethingToUndo(),
              hasSomethingToRedo: !0,
              isEmpty: _classPrivateMethodGet(this, N, _isEmpty2).call(this)
            })
          }

          redo() {
            _classPrivateFieldGet(this, m).redo()
            _classPrivateMethodGet(this, I, _dispatchUpdateStates2).call(this, {
              hasSomethingToUndo: !0,
              hasSomethingToRedo: _classPrivateFieldGet(this, m).hasSomethingToRedo(),
              isEmpty: _classPrivateMethodGet(this, N, _isEmpty2).call(this)
            })
          }

          addCommands(e) {
            _classPrivateFieldGet(this, m).add(e)
            _classPrivateMethodGet(this, I, _dispatchUpdateStates2).call(this, {
              hasSomethingToUndo: !0,
              hasSomethingToRedo: !1,
              isEmpty: _classPrivateMethodGet(this, N, _isEmpty2).call(this)
            })
          }

          delete() {
            _classPrivateFieldGet(this, u) && _classPrivateFieldGet(this, u).commitOrRemove()
            if (!this.hasSelection) return
            const e = [..._classPrivateFieldGet(this, S)]
            this.addCommands({
              cmd: () => {
                for (const t of e) t.remove()
              },
              undo: () => {
                for (const t of e) _classPrivateMethodGet(this, O, _addEditorToLayer2).call(this, t)
              },
              mustExec: !0
            })
          }

          copy() {
            _classPrivateFieldGet(this, u) && _classPrivateFieldGet(this, u).commitOrRemove()
            if (this.hasSelection) {
              const e = []
              for (const t of _classPrivateFieldGet(this, S)) t.isEmpty() || e.push(t)
              if (e.length === 0) return
              _classPrivateFieldGet(this, f).copy(e)
              _classPrivateMethodGet(this, I, _dispatchUpdateStates2).call(this, {
                hasEmptyClipboard: !1
              })
            }
          }

          cut() {
            this.copy()
            this.delete()
          }

          paste() {
            if (_classPrivateFieldGet(this, f).isEmpty()) return
            this.unselectAll()
            const e = _classPrivateFieldGet(this, g).get(_classPrivateFieldGet(this, v))
            const t = _classPrivateFieldGet(this, f)
              .paste()
              .map((t) => e.deserialize(t))
            this.addCommands({
              cmd: () => {
                for (const e of t) _classPrivateMethodGet(this, O, _addEditorToLayer2).call(this, e)
                _classPrivateMethodGet(this, B, _selectEditors2).call(this, t)
              },
              undo: () => {
                for (const e of t) e.remove()
              },
              mustExec: !0
            })
          }

          selectAll() {
            for (const e of _classPrivateFieldGet(this, S)) e.commit()
            _classPrivateMethodGet(this, B, _selectEditors2).call(
              this,
              _classPrivateFieldGet(this, p).values()
            )
          }

          unselectAll() {
            if (_classPrivateFieldGet(this, u)) _classPrivateFieldGet(this, u).commitOrRemove()
            else if (_classPrivateMethodGet(this, B, _selectEditors2).size !== 0) {
              for (const e of _classPrivateFieldGet(this, S)) e.unselect()
              _classPrivateFieldGet(this, S).clear()
              _classPrivateMethodGet(this, I, _dispatchUpdateStates2).call(this, {
                hasSelectedEditor: !1
              })
            }
          }

          isActive(e) {
            return _classPrivateFieldGet(this, u) === e
          }

          getActive() {
            return _classPrivateFieldGet(this, u)
          }

          getMode() {
            return _classPrivateFieldGet(this, y)
          }
        }
        t.AnnotationEditorUIManager = AnnotationEditorUIManager
        function _addKeyboardManager2() {
          _classPrivateFieldGet(this, M).addEventListener('keydown', _classPrivateFieldGet(this, A))
        }
        function _removeKeyboardManager2() {
          _classPrivateFieldGet(this, M).removeEventListener(
            'keydown',
            _classPrivateFieldGet(this, A)
          )
        }
        function _dispatchUpdateStates2(e) {
          Object.entries(e).some((e) => {
            const [t, i] = e
            return _classPrivateFieldGet(this, C)[t] !== i
          }) &&
            _classPrivateFieldGet(this, b).dispatch('annotationeditorstateschanged', {
              source: this,
              details: Object.assign(_classPrivateFieldGet(this, C), e)
            })
        }
        function _dispatchUpdateUI2(e) {
          _classPrivateFieldGet(this, b).dispatch('annotationeditorparamschanged', {
            source: this,
            details: e
          })
        }
        function _enableAll2() {
          if (!_classPrivateFieldGet(this, P)) {
            _classPrivateFieldSet(this, P, !0)
            for (const e of _classPrivateFieldGet(this, g).values()) e.enable()
          }
        }
        function _disableAll2() {
          this.unselectAll()
          if (_classPrivateFieldGet(this, P)) {
            _classPrivateFieldSet(this, P, !1)
            for (const e of _classPrivateFieldGet(this, g).values()) e.disable()
          }
        }
        function _addEditorToLayer2(e) {
          const t = _classPrivateFieldGet(this, g).get(e.pageIndex)
          t ? t.addOrRebuild(e) : this.addEditor(e)
        }
        function _isEmpty2() {
          if (_classPrivateFieldGet(this, p).size === 0) return !0
          if (_classPrivateFieldGet(this, p).size === 1)
            for (const e of _classPrivateFieldGet(this, p).values()) return e.isEmpty()
          return !1
        }
        function _selectEditors2(e) {
          _classPrivateFieldGet(this, S).clear()
          for (const t of e)
            if (!t.isEmpty()) {
              _classPrivateFieldGet(this, S).add(t)
              t.select()
            }
          _classPrivateMethodGet(this, I, _dispatchUpdateStates2).call(this, {
            hasSelectedEditor: !0
          })
        }
        _defineProperty(
          AnnotationEditorUIManager,
          '_keyboardManager',
          new KeyboardManager([
            [['ctrl+a', 'mac+meta+a'], AnnotationEditorUIManager.prototype.selectAll],
            [['ctrl+c', 'mac+meta+c'], AnnotationEditorUIManager.prototype.copy],
            [['ctrl+v', 'mac+meta+v'], AnnotationEditorUIManager.prototype.paste],
            [['ctrl+x', 'mac+meta+x'], AnnotationEditorUIManager.prototype.cut],
            [['ctrl+z', 'mac+meta+z'], AnnotationEditorUIManager.prototype.undo],
            [
              ['ctrl+y', 'ctrl+shift+Z', 'mac+meta+shift+Z'],
              AnnotationEditorUIManager.prototype.redo
            ],
            [
              [
                'Backspace',
                'alt+Backspace',
                'ctrl+Backspace',
                'shift+Backspace',
                'mac+Backspace',
                'mac+alt+Backspace',
                'mac+ctrl+Backspace',
                'Delete',
                'ctrl+Delete',
                'shift+Delete'
              ],
              AnnotationEditorUIManager.prototype.delete
            ],
            [['Escape', 'mac+Escape'], AnnotationEditorUIManager.prototype.unselectAll]
          ])
        )
      },
      (e, t, i) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.StatTimer =
          t.RenderingCancelledException =
          t.PixelsPerInch =
          t.PageViewport =
          t.PDFDateString =
          t.DOMStandardFontDataFactory =
          t.DOMSVGFactory =
          t.DOMCanvasFactory =
          t.DOMCMapReaderFactory =
          t.AnnotationPrefix =
            void 0
        t.deprecated = function deprecated(e) {
          console.log(`Deprecated API usage: ${e}`)
        }
        t.getColorValues = function getColorValues(e) {
          const t = document.createElement('span')
          t.style.visibility = 'hidden'
          document.body.append(t)
          for (const i of e.keys()) {
            t.style.color = i
            const n = window.getComputedStyle(t).color
            e.set(i, getRGB(n))
          }
          t.remove()
        }
        t.getCurrentTransform = function getCurrentTransform(e) {
          const { a: t, b: i, c: n, d: s, e: a, f: r } = e.getTransform()
          return [t, i, n, s, a, r]
        }
        t.getCurrentTransformInverse = function getCurrentTransformInverse(e) {
          const { a: t, b: i, c: n, d: s, e: a, f: r } = e.getTransform().invertSelf()
          return [t, i, n, s, a, r]
        }
        t.getFilenameFromUrl = function getFilenameFromUrl(e) {
          const t = e.indexOf('#')
          const i = e.indexOf('?')
          const n = Math.min(t > 0 ? t : e.length, i > 0 ? i : e.length)
          return e.substring(e.lastIndexOf('/', n) + 1, n)
        }
        t.getPdfFilenameFromUrl = function getPdfFilenameFromUrl(e) {
          const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'document.pdf'
          if (typeof e !== 'string') return t
          if (isDataScheme(e)) {
            ;(0, s.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.')
            return t
          }
          const i = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/
          const n = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i
          const a = i.exec(e)
          let r = n.exec(a[1]) || n.exec(a[2]) || n.exec(a[3])
          if (r) {
            r = r[0]
            if (r.includes('%'))
              try {
                r = n.exec(decodeURIComponent(r))[0]
              } catch (e) {}
          }
          return r || t
        }
        t.getRGB = getRGB
        t.getXfaPageViewport = function getXfaPageViewport(e, t) {
          const { scale: i = 1, rotation: n = 0 } = t
          const { width: s, height: a } = e.attributes.style
          const r = [0, 0, parseInt(s), parseInt(a)]
          return new PageViewport({ viewBox: r, scale: i, rotation: n })
        }
        t.isDataScheme = isDataScheme
        t.isPdfFile = function isPdfFile(e) {
          return typeof e === 'string' && /\.pdf$/i.test(e)
        }
        t.isValidFetchUrl = isValidFetchUrl
        t.loadScript = function loadScript(e) {
          const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
          return new Promise((i, n) => {
            const s = document.createElement('script')
            s.src = e
            s.onload = function (e) {
              t && s.remove()
              i(e)
            }
            s.onerror = function () {
              n(new Error(`Cannot load script at: ${s.src}`))
            }
            ;(document.head || document.documentElement).append(s)
          })
        }
        const n = i(134)
        var s = i(1)
        function _defineProperty(e, t, i) {
          t in e
            ? Object.defineProperty(e, t, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
              })
            : (e[t] = i)
          return e
        }
        t.AnnotationPrefix = 'pdfjs_internal_id_'
        class PixelsPerInch {}
        t.PixelsPerInch = PixelsPerInch
        _defineProperty(PixelsPerInch, 'CSS', 96)
        _defineProperty(PixelsPerInch, 'PDF', 72)
        _defineProperty(PixelsPerInch, 'PDF_TO_CSS_UNITS', PixelsPerInch.CSS / PixelsPerInch.PDF)
        class DOMCanvasFactory extends n.BaseCanvasFactory {
          constructor() {
            const { ownerDocument: e = globalThis.document } =
              arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
            super()
            this._document = e
          }

          _createCanvas(e, t) {
            const i = this._document.createElement('canvas')
            i.width = e
            i.height = t
            return i
          }
        }
        t.DOMCanvasFactory = DOMCanvasFactory
        async function fetchData(e) {
          const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
          if (isValidFetchUrl(e, document.baseURI)) {
            const i = await fetch(e)
            if (!i.ok) throw new Error(i.statusText)
            return t ? new Uint8Array(await i.arrayBuffer()) : (0, s.stringToBytes)(await i.text())
          }
          return new Promise((i, n) => {
            const a = new XMLHttpRequest()
            a.open('GET', e, !0)
            t && (a.responseType = 'arraybuffer')
            a.onreadystatechange = () => {
              if (a.readyState === XMLHttpRequest.DONE) {
                if (a.status === 200 || a.status === 0) {
                  let e
                  t && a.response
                    ? (e = new Uint8Array(a.response))
                    : !t && a.responseText && (e = (0, s.stringToBytes)(a.responseText))
                  if (e) {
                    i(e)
                    return
                  }
                }
                n(new Error(a.statusText))
              }
            }
            a.send(null)
          })
        }
        class DOMCMapReaderFactory extends n.BaseCMapReaderFactory {
          _fetchData(e, t) {
            return fetchData(e, this.isCompressed).then((e) => ({
              cMapData: e,
              compressionType: t
            }))
          }
        }
        t.DOMCMapReaderFactory = DOMCMapReaderFactory
        class DOMStandardFontDataFactory extends n.BaseStandardFontDataFactory {
          _fetchData(e) {
            return fetchData(e, !0)
          }
        }
        t.DOMStandardFontDataFactory = DOMStandardFontDataFactory
        class DOMSVGFactory extends n.BaseSVGFactory {
          _createSVG(e) {
            return document.createElementNS('http://www.w3.org/2000/svg', e)
          }
        }
        t.DOMSVGFactory = DOMSVGFactory
        class PageViewport {
          constructor(e) {
            let {
              viewBox: t,
              scale: i,
              rotation: n,
              offsetX: s = 0,
              offsetY: a = 0,
              dontFlip: r = !1
            } = e
            this.viewBox = t
            this.scale = i
            this.rotation = n
            this.offsetX = s
            this.offsetY = a
            const o = (t[2] + t[0]) / 2
            const l = (t[3] + t[1]) / 2
            let c
            let d
            let h
            let u
            let p
            let g
            let f
            let m
            n %= 360
            n < 0 && (n += 360)
            switch (n) {
              case 180:
                c = -1
                d = 0
                h = 0
                u = 1
                break
              case 90:
                c = 0
                d = 1
                h = 1
                u = 0
                break
              case 270:
                c = 0
                d = -1
                h = -1
                u = 0
                break
              case 0:
                c = 1
                d = 0
                h = 0
                u = -1
                break
              default:
                throw new Error('PageViewport: Invalid rotation, must be a multiple of 90 degrees.')
            }
            if (r) {
              h = -h
              u = -u
            }
            if (c === 0) {
              p = Math.abs(l - t[1]) * i + s
              g = Math.abs(o - t[0]) * i + a
              f = Math.abs(t[3] - t[1]) * i
              m = Math.abs(t[2] - t[0]) * i
            } else {
              p = Math.abs(o - t[0]) * i + s
              g = Math.abs(l - t[1]) * i + a
              f = Math.abs(t[2] - t[0]) * i
              m = Math.abs(t[3] - t[1]) * i
            }
            this.transform = [
              c * i,
              d * i,
              h * i,
              u * i,
              p - c * i * o - h * i * l,
              g - d * i * o - u * i * l
            ]
            this.width = f
            this.height = m
          }

          clone() {
            const {
              scale: e = this.scale,
              rotation: t = this.rotation,
              offsetX: i = this.offsetX,
              offsetY: n = this.offsetY,
              dontFlip: s = !1
            } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
            return new PageViewport({
              viewBox: this.viewBox.slice(),
              scale: e,
              rotation: t,
              offsetX: i,
              offsetY: n,
              dontFlip: s
            })
          }

          convertToViewportPoint(e, t) {
            return s.Util.applyTransform([e, t], this.transform)
          }

          convertToViewportRectangle(e) {
            const t = s.Util.applyTransform([e[0], e[1]], this.transform)
            const i = s.Util.applyTransform([e[2], e[3]], this.transform)
            return [t[0], t[1], i[0], i[1]]
          }

          convertToPdfPoint(e, t) {
            return s.Util.applyInverseTransform([e, t], this.transform)
          }
        }
        t.PageViewport = PageViewport
        class RenderingCancelledException extends s.BaseException {
          constructor(e, t) {
            super(e, 'RenderingCancelledException')
            this.type = t
          }
        }
        t.RenderingCancelledException = RenderingCancelledException
        function isDataScheme(e) {
          const t = e.length
          let i = 0
          for (; i < t && e[i].trim() === ''; ) i++
          return e.substring(i, i + 5).toLowerCase() === 'data:'
        }
        t.StatTimer = class StatTimer {
          constructor() {
            this.started = Object.create(null)
            this.times = []
          }

          time(e) {
            e in this.started && (0, s.warn)(`Timer is already running for ${e}`)
            this.started[e] = Date.now()
          }

          timeEnd(e) {
            e in this.started || (0, s.warn)(`Timer has not been started for ${e}`)
            this.times.push({ name: e, start: this.started[e], end: Date.now() })
            delete this.started[e]
          }

          toString() {
            const e = []
            let t = 0
            for (const e of this.times) {
              const i = e.name
              i.length > t && (t = i.length)
            }
            for (const i of this.times) {
              const n = i.end - i.start
              e.push(`${i.name.padEnd(t)} ${n}ms\n`)
            }
            return e.join('')
          }
        }
        function isValidFetchUrl(e, t) {
          try {
            const { protocol: i } = t ? new URL(e, t) : new URL(e)
            return i === 'http:' || i === 'https:'
          } catch (e) {
            return !1
          }
        }
        let a
        t.PDFDateString = class PDFDateString {
          static toDateObject(e) {
            if (!e || typeof e !== 'string') return null
            a ||
              (a = new RegExp(
                "^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"
              ))
            const t = a.exec(e)
            if (!t) return null
            const i = parseInt(t[1], 10)
            let n = parseInt(t[2], 10)
            n = n >= 1 && n <= 12 ? n - 1 : 0
            let s = parseInt(t[3], 10)
            s = s >= 1 && s <= 31 ? s : 1
            let r = parseInt(t[4], 10)
            r = r >= 0 && r <= 23 ? r : 0
            let o = parseInt(t[5], 10)
            o = o >= 0 && o <= 59 ? o : 0
            let l = parseInt(t[6], 10)
            l = l >= 0 && l <= 59 ? l : 0
            const c = t[7] || 'Z'
            let d = parseInt(t[8], 10)
            d = d >= 0 && d <= 23 ? d : 0
            let h = parseInt(t[9], 10) || 0
            h = h >= 0 && h <= 59 ? h : 0
            if (c === '-') {
              r += d
              o += h
            } else if (c === '+') {
              r -= d
              o -= h
            }
            return new Date(Date.UTC(i, n, s, r, o, l))
          }
        }
        function getRGB(e) {
          if (e.startsWith('#')) {
            const t = parseInt(e.slice(1), 16)
            return [(16711680 & t) >> 16, (65280 & t) >> 8, 255 & t]
          }
          if (e.startsWith('rgb('))
            return e
              .slice(4, -1)
              .split(',')
              .map((e) => parseInt(e))
          if (e.startsWith('rgba('))
            return e
              .slice(5, -1)
              .split(',')
              .map((e) => parseInt(e))
              .slice(0, 3)
          ;(0, s.warn)(`Not a valid color format: "${e}"`)
          return [0, 0, 0]
        }
      },
      (e, t, i) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.BaseStandardFontDataFactory =
          t.BaseSVGFactory =
          t.BaseCanvasFactory =
          t.BaseCMapReaderFactory =
            void 0
        const n = i(1)
        class BaseCanvasFactory {
          constructor() {
            this.constructor === BaseCanvasFactory &&
              (0, n.unreachable)('Cannot initialize BaseCanvasFactory.')
          }

          create(e, t) {
            if (e <= 0 || t <= 0) throw new Error('Invalid canvas size')
            const i = this._createCanvas(e, t)
            return { canvas: i, context: i.getContext('2d') }
          }

          reset(e, t, i) {
            if (!e.canvas) throw new Error('Canvas is not specified')
            if (t <= 0 || i <= 0) throw new Error('Invalid canvas size')
            e.canvas.width = t
            e.canvas.height = i
          }

          destroy(e) {
            if (!e.canvas) throw new Error('Canvas is not specified')
            e.canvas.width = 0
            e.canvas.height = 0
            e.canvas = null
            e.context = null
          }

          _createCanvas(e, t) {
            ;(0, n.unreachable)('Abstract method `_createCanvas` called.')
          }
        }
        t.BaseCanvasFactory = BaseCanvasFactory
        class BaseCMapReaderFactory {
          constructor(e) {
            const { baseUrl: t = null, isCompressed: i = !1 } = e
            this.constructor === BaseCMapReaderFactory &&
              (0, n.unreachable)('Cannot initialize BaseCMapReaderFactory.')
            this.baseUrl = t
            this.isCompressed = i
          }

          async fetch(e) {
            const { name: t } = e
            if (!this.baseUrl)
              throw new Error(
                'The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.'
              )
            if (!t) throw new Error('CMap name must be specified.')
            const i = this.baseUrl + t + (this.isCompressed ? '.bcmap' : '')
            const s = this.isCompressed ? n.CMapCompressionType.BINARY : n.CMapCompressionType.NONE
            return this._fetchData(i, s).catch((e) => {
              throw new Error(`Unable to load ${this.isCompressed ? 'binary ' : ''}CMap at: ${i}`)
            })
          }

          _fetchData(e, t) {
            ;(0, n.unreachable)('Abstract method `_fetchData` called.')
          }
        }
        t.BaseCMapReaderFactory = BaseCMapReaderFactory
        class BaseStandardFontDataFactory {
          constructor(e) {
            const { baseUrl: t = null } = e
            this.constructor === BaseStandardFontDataFactory &&
              (0, n.unreachable)('Cannot initialize BaseStandardFontDataFactory.')
            this.baseUrl = t
          }

          async fetch(e) {
            const { filename: t } = e
            if (!this.baseUrl)
              throw new Error(
                'The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.'
              )
            if (!t) throw new Error('Font filename must be specified.')
            const i = `${this.baseUrl}${t}`
            return this._fetchData(i).catch((e) => {
              throw new Error(`Unable to load font data at: ${i}`)
            })
          }

          _fetchData(e) {
            ;(0, n.unreachable)('Abstract method `_fetchData` called.')
          }
        }
        t.BaseStandardFontDataFactory = BaseStandardFontDataFactory
        class BaseSVGFactory {
          constructor() {
            this.constructor === BaseSVGFactory &&
              (0, n.unreachable)('Cannot initialize BaseSVGFactory.')
          }

          create(e, t) {
            const i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
            if (e <= 0 || t <= 0) throw new Error('Invalid SVG dimensions')
            const n = this._createSVG('svg:svg')
            n.setAttribute('version', '1.1')
            if (!i) {
              n.setAttribute('width', `${e}px`)
              n.setAttribute('height', `${t}px`)
            }
            n.setAttribute('preserveAspectRatio', 'none')
            n.setAttribute('viewBox', `0 0 ${e} ${t}`)
            return n
          }

          createElement(e) {
            if (typeof e !== 'string') throw new Error('Invalid SVG element type')
            return this._createSVG(e)
          }

          _createSVG(e) {
            ;(0, n.unreachable)('Abstract method `_createSVG` called.')
          }
        }
        t.BaseSVGFactory = BaseSVGFactory
      },
      (e, t, i) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.MurmurHash3_64 = void 0
        const n = i(1)
        const s = 3285377520
        const a = 4294901760
        const r = 65535
        t.MurmurHash3_64 = class MurmurHash3_64 {
          constructor(e) {
            this.h1 = e ? 4294967295 & e : s
            this.h2 = e ? 4294967295 & e : s
          }

          update(e) {
            let t
            let i
            if (typeof e === 'string') {
              t = new Uint8Array(2 * e.length)
              i = 0
              for (let n = 0, s = e.length; n < s; n++) {
                const s = e.charCodeAt(n)
                if (s <= 255) t[i++] = s
                else {
                  t[i++] = s >>> 8
                  t[i++] = 255 & s
                }
              }
            } else {
              if (!(0, n.isArrayBuffer)(e))
                throw new Error(
                  'Wrong data format in MurmurHash3_64_update. Input must be a string or array.'
                )
              t = e.slice()
              i = t.byteLength
            }
            const s = i >> 2
            const o = i - 4 * s
            const l = new Uint32Array(t.buffer, 0, s)
            let c = 0
            let d = 0
            let h = this.h1
            let u = this.h2
            const p = 3432918353
            const g = 461845907
            const f = 11601
            const m = 13715
            for (let e = 0; e < s; e++)
              if (1 & e) {
                c = l[e]
                c = ((c * p) & a) | ((c * f) & r)
                c = (c << 15) | (c >>> 17)
                c = ((c * g) & a) | ((c * m) & r)
                h ^= c
                h = (h << 13) | (h >>> 19)
                h = 5 * h + 3864292196
              } else {
                d = l[e]
                d = ((d * p) & a) | ((d * f) & r)
                d = (d << 15) | (d >>> 17)
                d = ((d * g) & a) | ((d * m) & r)
                u ^= d
                u = (u << 13) | (u >>> 19)
                u = 5 * u + 3864292196
              }
            c = 0
            switch (o) {
              case 3:
                c ^= t[4 * s + 2] << 16
              case 2:
                c ^= t[4 * s + 1] << 8
              case 1:
                c ^= t[4 * s]
                c = ((c * p) & a) | ((c * f) & r)
                c = (c << 15) | (c >>> 17)
                c = ((c * g) & a) | ((c * m) & r)
                1 & s ? (h ^= c) : (u ^= c)
            }
            this.h1 = h
            this.h2 = u
          }

          hexdigest() {
            let e = this.h1
            let t = this.h2
            e ^= t >>> 1
            e = ((3981806797 * e) & a) | ((36045 * e) & r)
            t = ((4283543511 * t) & a) | (((2950163797 * ((t << 16) | (e >>> 16))) & a) >>> 16)
            e ^= t >>> 1
            e = ((444984403 * e) & a) | ((60499 * e) & r)
            t = ((3301882366 * t) & a) | (((3120437893 * ((t << 16) | (e >>> 16))) & a) >>> 16)
            e ^= t >>> 1
            const i = (e >>> 0).toString(16)
            const n = (t >>> 0).toString(16)
            return i.padStart(8, '0') + n.padStart(8, '0')
          }
        }
      },
      (e, t, i) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.FontLoader = t.FontFaceObject = void 0
        const n = i(1)
        class BaseFontLoader {
          constructor(e) {
            const {
              docId: t,
              onUnsupportedFeature: i,
              ownerDocument: s = globalThis.document,
              styleElement: a = null
            } = e
            this.constructor === BaseFontLoader &&
              (0, n.unreachable)('Cannot initialize BaseFontLoader.')
            this.docId = t
            this._onUnsupportedFeature = i
            this._document = s
            this.nativeFontFaces = []
            this.styleElement = null
          }

          addNativeFontFace(e) {
            this.nativeFontFaces.push(e)
            this._document.fonts.add(e)
          }

          insertRule(e) {
            let t = this.styleElement
            if (!t) {
              t = this.styleElement = this._document.createElement('style')
              t.id = `PDFJS_FONT_STYLE_TAG_${this.docId}`
              this._document.documentElement.getElementsByTagName('head')[0].append(t)
            }
            const i = t.sheet
            i.insertRule(e, i.cssRules.length)
          }

          clear() {
            for (const e of this.nativeFontFaces) this._document.fonts.delete(e)
            this.nativeFontFaces.length = 0
            if (this.styleElement) {
              this.styleElement.remove()
              this.styleElement = null
            }
          }

          async bind(e) {
            if (e.attached || e.missingFile) return
            e.attached = !0
            if (this.isFontLoadingAPISupported) {
              const t = e.createNativeFontFace()
              if (t) {
                this.addNativeFontFace(t)
                try {
                  await t.loaded
                } catch (i) {
                  this._onUnsupportedFeature({
                    featureId: n.UNSUPPORTED_FEATURES.errorFontLoadNative
                  })
                  ;(0, n.warn)(`Failed to load font '${t.family}': '${i}'.`)
                  e.disableFontFace = !0
                  throw i
                }
              }
              return
            }
            const t = e.createFontFaceRule()
            if (t) {
              this.insertRule(t)
              if (this.isSyncFontLoadingSupported) return
              await new Promise((i) => {
                const n = this._queueLoadingCallback(i)
                this._prepareFontLoadEvent([t], [e], n)
              })
            }
          }

          _queueLoadingCallback(e) {
            ;(0, n.unreachable)('Abstract method `_queueLoadingCallback`.')
          }

          get isFontLoadingAPISupported() {
            let e
            const t = !((e = this._document) === null || void 0 === e || !e.fonts)
            return (0, n.shadow)(this, 'isFontLoadingAPISupported', t)
          }

          get isSyncFontLoadingSupported() {
            ;(0, n.unreachable)('Abstract method `isSyncFontLoadingSupported`.')
          }

          get _loadTestFont() {
            ;(0, n.unreachable)('Abstract method `_loadTestFont`.')
          }

          _prepareFontLoadEvent(e, t, i) {
            ;(0, n.unreachable)('Abstract method `_prepareFontLoadEvent`.')
          }
        }
        let s
        t.FontLoader = s
        t.FontLoader = s = class GenericFontLoader extends BaseFontLoader {
          constructor(e) {
            super(e)
            this.loadingContext = { requests: [], nextRequestId: 0 }
            this.loadTestFontId = 0
          }

          get isSyncFontLoadingSupported() {
            let e = !1
            if (typeof navigator === 'undefined') e = !0
            else {
              const t = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent)
              ;(t == null ? void 0 : t[1]) >= 14 && (e = !0)
            }
            return (0, n.shadow)(this, 'isSyncFontLoadingSupported', e)
          }

          _queueLoadingCallback(e) {
            const t = this.loadingContext
            const i = {
              id: `pdfjs-font-loading-${t.nextRequestId++}`,
              done: !1,
              complete: function completeRequest() {
                ;(0, n.assert)(!i.done, 'completeRequest() cannot be called twice.')
                i.done = !0
                for (; t.requests.length > 0 && t.requests[0].done; ) {
                  const e = t.requests.shift()
                  setTimeout(e.callback, 0)
                }
              },
              callback: e
            }
            t.requests.push(i)
            return i
          }

          get _loadTestFont() {
            return (0, n.shadow)(
              this,
              '_loadTestFont',
              atob(
                'T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA=='
              )
            )
          }

          _prepareFontLoadEvent(e, t, i) {
            function int32(e, t) {
              return (
                (e.charCodeAt(t) << 24) |
                (e.charCodeAt(t + 1) << 16) |
                (e.charCodeAt(t + 2) << 8) |
                (255 & e.charCodeAt(t + 3))
              )
            }
            function spliceString(e, t, i, n) {
              return e.substring(0, t) + n + e.substring(t + i)
            }
            let s
            let a
            const r = this._document.createElement('canvas')
            r.width = 1
            r.height = 1
            const o = r.getContext('2d')
            let l = 0
            const c = `lt${Date.now()}${this.loadTestFontId++}`
            let d = this._loadTestFont
            d = spliceString(d, 976, c.length, c)
            const h = 1482184792
            let u = int32(d, 16)
            for (s = 0, a = c.length - 3; s < a; s += 4) u = (u - h + int32(c, s)) | 0
            s < c.length && (u = (u - h + int32(`${c}XXX`, s)) | 0)
            d = spliceString(d, 16, 4, (0, n.string32)(u))
            const p = `@font-face {font-family:"${c}";src:${`url(data:font/opentype;base64,${btoa(
              d
            )});`}}`
            this.insertRule(p)
            const g = []
            for (const e of t) g.push(e.loadedName)
            g.push(c)
            const f = this._document.createElement('div')
            f.style.visibility = 'hidden'
            f.style.width = f.style.height = '10px'
            f.style.position = 'absolute'
            f.style.top = f.style.left = '0px'
            for (const e of g) {
              const t = this._document.createElement('span')
              t.textContent = 'Hi'
              t.style.fontFamily = e
              f.append(t)
            }
            this._document.body.append(f)
            !(function isFontReady(e, t) {
              l++
              if (l > 30) {
                ;(0, n.warn)('Load test font never loaded.')
                t()
                return
              }
              o.font = `30px ${e}`
              o.fillText('.', 0, 20)
              o.getImageData(0, 0, 1, 1).data[3] > 0
                ? t()
                : setTimeout(isFontReady.bind(null, e, t))
            })(c, () => {
              f.remove()
              i.complete()
            })
          }
        }
        t.FontFaceObject = class FontFaceObject {
          constructor(e, t) {
            const {
              isEvalSupported: i = !0,
              disableFontFace: n = !1,
              ignoreErrors: s = !1,
              onUnsupportedFeature: a,
              fontRegistry: r = null
            } = t
            this.compiledGlyphs = Object.create(null)
            for (const t in e) this[t] = e[t]
            this.isEvalSupported = !1 !== i
            this.disableFontFace = !0 === n
            this.ignoreErrors = !0 === s
            this._onUnsupportedFeature = a
            this.fontRegistry = r
          }

          createNativeFontFace() {
            if (!this.data || this.disableFontFace) return null
            let e
            if (this.cssFontInfo) {
              const t = { weight: this.cssFontInfo.fontWeight }
              this.cssFontInfo.italicAngle &&
                (t.style = `oblique ${this.cssFontInfo.italicAngle}deg`)
              e = new FontFace(this.cssFontInfo.fontFamily, this.data, t)
            } else e = new FontFace(this.loadedName, this.data, {})
            this.fontRegistry && this.fontRegistry.registerFont(this)
            return e
          }

          createFontFaceRule() {
            if (!this.data || this.disableFontFace) return null
            const e = (0, n.bytesToString)(this.data)
            const t = `url(data:${this.mimetype};base64,${btoa(e)});`
            let i
            if (this.cssFontInfo) {
              let e = `font-weight: ${this.cssFontInfo.fontWeight};`
              this.cssFontInfo.italicAngle &&
                (e += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`)
              i = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${e}src:${t}}`
            } else i = `@font-face {font-family:"${this.loadedName}";src:${t}}`
            this.fontRegistry && this.fontRegistry.registerFont(this, t)
            return i
          }

          getPathGenerator(e, t) {
            if (void 0 !== this.compiledGlyphs[t]) return this.compiledGlyphs[t]
            let i
            try {
              i = e.get(`${this.loadedName}_path_${t}`)
            } catch (e) {
              if (!this.ignoreErrors) throw e
              this._onUnsupportedFeature({ featureId: n.UNSUPPORTED_FEATURES.errorFontGetPath })
              ;(0, n.warn)(`getPathGenerator - ignoring character: "${e}".`)
              return (this.compiledGlyphs[t] = function (e, t) {})
            }
            if (this.isEvalSupported && n.FeatureTest.isEvalSupported) {
              const e = []
              for (const t of i) {
                const i = void 0 !== t.args ? t.args.join(',') : ''
                e.push('c.', t.cmd, '(', i, ');\n')
              }
              return (this.compiledGlyphs[t] = new Function('c', 'size', e.join('')))
            }
            return (this.compiledGlyphs[t] = function (e, t) {
              for (const n of i) {
                n.cmd === 'scale' && (n.args = [t, -t])
                e[n.cmd].apply(e, n.args)
              }
            })
          }
        }
      },
      (e, t, i) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.CanvasGraphics = void 0
        const n = i(133)
        const s = i(1)
        const a = i(138)
        const r = i(139)
        const o = i(3)
        const l = i(140)
        function _classPrivateMethodInitSpec(e, t) {
          !(function _checkPrivateRedeclaration(e, t) {
            if (t.has(e))
              throw new TypeError('Cannot initialize the same private elements twice on an object')
          })(e, t)
          t.add(e)
        }
        function _classPrivateMethodGet(e, t, i) {
          if (!t.has(e)) throw new TypeError('attempted to get private field on non-instance')
          return i
        }
        const c = 4096
        const d = o.isNodeJS && typeof Path2D === 'undefined' ? -1 : 1e3
        const h = 16
        class CachedCanvases {
          constructor(e) {
            this.canvasFactory = e
            this.cache = Object.create(null)
          }

          getCanvas(e, t, i) {
            let n
            if (void 0 !== this.cache[e]) {
              n = this.cache[e]
              this.canvasFactory.reset(n, t, i)
            } else {
              n = this.canvasFactory.create(t, i)
              this.cache[e] = n
            }
            return n
          }

          delete(e) {
            delete this.cache[e]
          }

          clear() {
            for (const e in this.cache) {
              const t = this.cache[e]
              this.canvasFactory.destroy(t)
              delete this.cache[e]
            }
          }
        }
        function drawImageAtIntegerCoords(e, t, i, s, a, r, o, l, c, d) {
          const [h, u, p, g, f, m] = (0, n.getCurrentTransform)(e)
          if (u === 0 && p === 0) {
            const n = o * h + f
            const v = Math.round(n)
            const _ = l * g + m
            const b = Math.round(_)
            const w = (o + c) * h + f
            const P = Math.abs(Math.round(w) - v) || 1
            const y = (l + d) * g + m
            const S = Math.abs(Math.round(y) - b) || 1
            e.setTransform(Math.sign(h), 0, 0, Math.sign(g), v, b)
            e.drawImage(t, i, s, a, r, 0, 0, P, S)
            e.setTransform(h, u, p, g, f, m)
            return [P, S]
          }
          if (h === 0 && g === 0) {
            const n = l * p + f
            const v = Math.round(n)
            const _ = o * u + m
            const b = Math.round(_)
            const w = (l + d) * p + f
            const P = Math.abs(Math.round(w) - v) || 1
            const y = (o + c) * u + m
            const S = Math.abs(Math.round(y) - b) || 1
            e.setTransform(0, Math.sign(u), Math.sign(p), 0, v, b)
            e.drawImage(t, i, s, a, r, 0, 0, S, P)
            e.setTransform(h, u, p, g, f, m)
            return [S, P]
          }
          e.drawImage(t, i, s, a, r, o, l, c, d)
          return [Math.hypot(h, u) * c, Math.hypot(p, g) * d]
        }
        class CanvasExtraState {
          constructor(e, t) {
            this.alphaIsShape = !1
            this.fontSize = 0
            this.fontSizeScale = 1
            this.textMatrix = s.IDENTITY_MATRIX
            this.textMatrixScale = 1
            this.fontMatrix = s.FONT_IDENTITY_MATRIX
            this.leading = 0
            this.x = 0
            this.y = 0
            this.lineX = 0
            this.lineY = 0
            this.charSpacing = 0
            this.wordSpacing = 0
            this.textHScale = 1
            this.textRenderingMode = s.TextRenderingMode.FILL
            this.textRise = 0
            this.fillColor = '#000000'
            this.strokeColor = '#000000'
            this.patternFill = !1
            this.fillAlpha = 1
            this.strokeAlpha = 1
            this.lineWidth = 1
            this.activeSMask = null
            this.transferMaps = null
            this.startNewPathAndClipBox([0, 0, e, t])
          }

          clone() {
            const e = Object.create(this)
            e.clipBox = this.clipBox.slice()
            return e
          }

          setCurrentPoint(e, t) {
            this.x = e
            this.y = t
          }

          updatePathMinMax(e, t, i) {
            ;[t, i] = s.Util.applyTransform([t, i], e)
            this.minX = Math.min(this.minX, t)
            this.minY = Math.min(this.minY, i)
            this.maxX = Math.max(this.maxX, t)
            this.maxY = Math.max(this.maxY, i)
          }

          updateRectMinMax(e, t) {
            const i = s.Util.applyTransform(t, e)
            const n = s.Util.applyTransform(t.slice(2), e)
            this.minX = Math.min(this.minX, i[0], n[0])
            this.minY = Math.min(this.minY, i[1], n[1])
            this.maxX = Math.max(this.maxX, i[0], n[0])
            this.maxY = Math.max(this.maxY, i[1], n[1])
          }

          updateScalingPathMinMax(e, t) {
            s.Util.scaleMinMax(e, t)
            this.minX = Math.min(this.minX, t[0])
            this.maxX = Math.max(this.maxX, t[1])
            this.minY = Math.min(this.minY, t[2])
            this.maxY = Math.max(this.maxY, t[3])
          }

          updateCurvePathMinMax(e, t, i, n, a, r, o, l, c, d) {
            const h = s.Util.bezierBoundingBox(t, i, n, a, r, o, l, c)
            if (d) {
              d[0] = Math.min(d[0], h[0], h[2])
              d[1] = Math.max(d[1], h[0], h[2])
              d[2] = Math.min(d[2], h[1], h[3])
              d[3] = Math.max(d[3], h[1], h[3])
            } else this.updateRectMinMax(e, h)
          }

          getPathBoundingBox() {
            const e =
              arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a.PathType.FILL
            const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
            const i = [this.minX, this.minY, this.maxX, this.maxY]
            if (e === a.PathType.STROKE) {
              t || (0, s.unreachable)('Stroke bounding box must include transform.')
              const e = s.Util.singularValueDecompose2dScale(t)
              const n = (e[0] * this.lineWidth) / 2
              const a = (e[1] * this.lineWidth) / 2
              i[0] -= n
              i[1] -= a
              i[2] += n
              i[3] += a
            }
            return i
          }

          updateClipFromPath() {
            const e = s.Util.intersect(this.clipBox, this.getPathBoundingBox())
            this.startNewPathAndClipBox(e || [0, 0, 0, 0])
          }

          isEmptyClip() {
            return this.minX === 1 / 0
          }

          startNewPathAndClipBox(e) {
            this.clipBox = e
            this.minX = 1 / 0
            this.minY = 1 / 0
            this.maxX = 0
            this.maxY = 0
          }

          getClippedPathBoundingBox() {
            const e =
              arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a.PathType.FILL
            const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
            return s.Util.intersect(this.clipBox, this.getPathBoundingBox(e, t))
          }
        }
        function putBinaryImageData(e, t) {
          const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
          if (typeof ImageData !== 'undefined' && t instanceof ImageData) {
            e.putImageData(t, 0, 0)
            return
          }
          const n = t.height
          const a = t.width
          const r = n % h
          const o = (n - r) / h
          const l = r === 0 ? o : o + 1
          const c = e.createImageData(a, h)
          let d
          let u = 0
          const p = t.data
          const g = c.data
          let f
          let m
          let v
          let _
          let b
          let w
          let P
          let y
          if (i)
            switch (i.length) {
              case 1:
                b = i[0]
                w = i[0]
                P = i[0]
                y = i[0]
                break
              case 4:
                b = i[0]
                w = i[1]
                P = i[2]
                y = i[3]
            }
          if (t.kind === s.ImageKind.GRAYSCALE_1BPP) {
            const t = p.byteLength
            const i = new Uint32Array(g.buffer, 0, g.byteLength >> 2)
            const n = i.length
            const _ = (a + 7) >> 3
            let b = 4294967295
            let w = s.FeatureTest.isLittleEndian ? 4278190080 : 255
            y && y[0] === 255 && y[255] === 0 && ([b, w] = [w, b])
            for (f = 0; f < l; f++) {
              v = f < o ? h : r
              d = 0
              for (m = 0; m < v; m++) {
                const e = t - u
                let n = 0
                const s = e > _ ? a : 8 * e - 7
                const r = -8 & s
                let o = 0
                let l = 0
                for (; n < r; n += 8) {
                  l = p[u++]
                  i[d++] = 128 & l ? b : w
                  i[d++] = 64 & l ? b : w
                  i[d++] = 32 & l ? b : w
                  i[d++] = 16 & l ? b : w
                  i[d++] = 8 & l ? b : w
                  i[d++] = 4 & l ? b : w
                  i[d++] = 2 & l ? b : w
                  i[d++] = 1 & l ? b : w
                }
                for (; n < s; n++) {
                  if (o === 0) {
                    l = p[u++]
                    o = 128
                  }
                  i[d++] = l & o ? b : w
                  o >>= 1
                }
              }
              for (; d < n; ) i[d++] = 0
              e.putImageData(c, 0, f * h)
            }
          } else if (t.kind === s.ImageKind.RGBA_32BPP) {
            const t = !!(b || w || P)
            m = 0
            _ = a * h * 4
            for (f = 0; f < o; f++) {
              g.set(p.subarray(u, u + _))
              u += _
              if (t)
                for (let e = 0; e < _; e += 4) {
                  b && (g[e + 0] = b[g[e + 0]])
                  w && (g[e + 1] = w[g[e + 1]])
                  P && (g[e + 2] = P[g[e + 2]])
                }
              e.putImageData(c, 0, m)
              m += h
            }
            if (f < l) {
              _ = a * r * 4
              g.set(p.subarray(u, u + _))
              if (t)
                for (let e = 0; e < _; e += 4) {
                  b && (g[e + 0] = b[g[e + 0]])
                  w && (g[e + 1] = w[g[e + 1]])
                  P && (g[e + 2] = P[g[e + 2]])
                }
              e.putImageData(c, 0, m)
            }
          } else {
            if (t.kind !== s.ImageKind.RGB_24BPP) throw new Error(`bad image kind: ${t.kind}`)
            {
              const t = !!(b || w || P)
              v = h
              _ = a * v
              for (f = 0; f < l; f++) {
                if (f >= o) {
                  v = r
                  _ = a * v
                }
                d = 0
                for (m = _; m--; ) {
                  g[d++] = p[u++]
                  g[d++] = p[u++]
                  g[d++] = p[u++]
                  g[d++] = 255
                }
                if (t)
                  for (let e = 0; e < d; e += 4) {
                    b && (g[e + 0] = b[g[e + 0]])
                    w && (g[e + 1] = w[g[e + 1]])
                    P && (g[e + 2] = P[g[e + 2]])
                  }
                e.putImageData(c, 0, f * h)
              }
            }
          }
        }
        function putBinaryImageMask(e, t) {
          if (t.bitmap) {
            e.drawImage(t.bitmap, 0, 0)
            return
          }
          const i = t.height
          const n = t.width
          const s = i % h
          const a = (i - s) / h
          const o = s === 0 ? a : a + 1
          const l = e.createImageData(n, h)
          let c = 0
          const d = t.data
          const u = l.data
          for (let t = 0; t < o; t++) {
            const i = t < a ? h : s
            ;({ srcPos: c } = (0, r.applyMaskImageData)({
              src: d,
              srcPos: c,
              dest: u,
              width: n,
              height: i
            }))
            e.putImageData(l, 0, t * h)
          }
        }
        function copyCtxState(e, t) {
          const i = [
            'strokeStyle',
            'fillStyle',
            'fillRule',
            'globalAlpha',
            'lineWidth',
            'lineCap',
            'lineJoin',
            'miterLimit',
            'globalCompositeOperation',
            'font'
          ]
          for (let n = 0, s = i.length; n < s; n++) {
            const s = i[n]
            void 0 !== e[s] && (t[s] = e[s])
          }
          if (void 0 !== e.setLineDash) {
            t.setLineDash(e.getLineDash())
            t.lineDashOffset = e.lineDashOffset
          }
        }
        function resetCtxToDefault(e, t) {
          e.strokeStyle = e.fillStyle = t || '#000000'
          e.fillRule = 'nonzero'
          e.globalAlpha = 1
          e.lineWidth = 1
          e.lineCap = 'butt'
          e.lineJoin = 'miter'
          e.miterLimit = 10
          e.globalCompositeOperation = 'source-over'
          e.font = '10px sans-serif'
          if (void 0 !== e.setLineDash) {
            e.setLineDash([])
            e.lineDashOffset = 0
          }
        }
        function composeSMaskBackdrop(e, t, i, n) {
          const s = e.length
          for (let a = 3; a < s; a += 4) {
            const s = e[a]
            if (s === 0) {
              e[a - 3] = t
              e[a - 2] = i
              e[a - 1] = n
            } else if (s < 255) {
              const r = 255 - s
              e[a - 3] = (e[a - 3] * s + t * r) >> 8
              e[a - 2] = (e[a - 2] * s + i * r) >> 8
              e[a - 1] = (e[a - 1] * s + n * r) >> 8
            }
          }
        }
        function composeSMaskAlpha(e, t, i) {
          const n = e.length
          for (let s = 3; s < n; s += 4) {
            const n = i ? i[e[s]] : e[s]
            t[s] = (t[s] * n * 0.00392156862745098) | 0
          }
        }
        function composeSMaskLuminosity(e, t, i) {
          const n = e.length
          for (let s = 3; s < n; s += 4) {
            const n = 77 * e[s - 3] + 152 * e[s - 2] + 28 * e[s - 1]
            t[s] = i ? (t[s] * i[n >> 8]) >> 8 : (t[s] * n) >> 16
          }
        }
        function composeSMask(e, t, i, n) {
          const s = n[0]
          const a = n[1]
          const r = n[2] - s
          const o = n[3] - a
          if (r !== 0 && o !== 0) {
            !(function genericComposeSMask(e, t, i, n, s, a, r, o, l, c, d) {
              const h = !!a
              const u = h ? a[0] : 0
              const p = h ? a[1] : 0
              const g = h ? a[2] : 0
              let f
              f = s === 'Luminosity' ? composeSMaskLuminosity : composeSMaskAlpha
              const m = Math.min(n, Math.ceil(1048576 / i))
              for (let s = 0; s < n; s += m) {
                const a = Math.min(m, n - s)
                const v = e.getImageData(o - c, s + (l - d), i, a)
                const _ = t.getImageData(o, s + l, i, a)
                h && composeSMaskBackdrop(v.data, u, p, g)
                f(v.data, _.data, r)
                t.putImageData(_, o, s + l)
              }
            })(t.context, i, r, o, t.subtype, t.backdrop, t.transferMap, s, a, t.offsetX, t.offsetY)
            e.save()
            e.globalAlpha = 1
            e.globalCompositeOperation = 'source-over'
            e.setTransform(1, 0, 0, 1, 0, 0)
            e.drawImage(i.canvas, 0, 0)
            e.restore()
          }
        }
        function getImageSmoothingEnabled(e, t) {
          const i = s.Util.singularValueDecompose2dScale(e)
          i[0] = Math.fround(i[0])
          i[1] = Math.fround(i[1])
          const a = Math.fround(
            (globalThis.devicePixelRatio || 1) * n.PixelsPerInch.PDF_TO_CSS_UNITS
          )
          return void 0 !== t ? t : i[0] <= a || i[1] <= a
        }
        const u = ['butt', 'round', 'square']
        const p = ['miter', 'round', 'bevel']
        const g = {}
        const f = {}
        const m = new WeakSet()
        class CanvasGraphics {
          constructor(e, t, i, n, s, a, r, o) {
            _classPrivateMethodInitSpec(this, m)
            this.ctx = e
            this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height)
            this.stateStack = []
            this.pendingClip = null
            this.pendingEOFill = !1
            this.res = null
            this.xobjs = null
            this.commonObjs = t
            this.objs = i
            this.canvasFactory = n
            this.imageLayer = s
            this.groupStack = []
            this.processingType3 = null
            this.baseTransform = null
            this.baseTransformStack = []
            this.groupLevel = 0
            this.smaskStack = []
            this.smaskCounter = 0
            this.tempSMask = null
            this.suspendedCtx = null
            this.contentVisible = !0
            this.markedContentStack = []
            this.optionalContentConfig = a
            this.cachedCanvases = new CachedCanvases(this.canvasFactory)
            this.cachedPatterns = new Map()
            this.annotationCanvasMap = r
            this.viewportScale = 1
            this.outputScaleX = 1
            this.outputScaleY = 1
            this.backgroundColor = (o == null ? void 0 : o.background) || null
            this.foregroundColor = (o == null ? void 0 : o.foreground) || null
            this._cachedScaleForStroking = null
            this._cachedGetSinglePixelWidth = null
            this._cachedBitmapsMap = new Map()
          }

          getObject(e) {
            const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
            return typeof e === 'string'
              ? e.startsWith('g_')
                ? this.commonObjs.get(e)
                : this.objs.get(e)
              : t
          }

          beginDrawing(e) {
            const { transform: t, viewport: i, transparency: s = !1, background: a = null } = e
            const r = this.ctx.canvas.width
            const o = this.ctx.canvas.height
            const l = a || '#ffffff'
            this.ctx.save()
            if (this.foregroundColor && this.backgroundColor) {
              this.ctx.fillStyle = this.foregroundColor
              const e = (this.foregroundColor = this.ctx.fillStyle)
              this.ctx.fillStyle = this.backgroundColor
              const t = (this.backgroundColor = this.ctx.fillStyle)
              let i = !0
              let s = l
              this.ctx.fillStyle = l
              s = this.ctx.fillStyle
              i = typeof s === 'string' && /^#[0-9A-Fa-f]{6}$/.test(s)
              if ((e === '#000000' && t === '#ffffff') || e === t || !i)
                this.foregroundColor = this.backgroundColor = null
              else {
                const [i, a, r] = (0, n.getRGB)(s)
                const newComp = (e) =>
                  (e /= 255) <= 0.03928 ? e / 12.92 : ((e + 0.055) / 1.055) ** 2.4
                const o = Math.round(
                  0.2126 * newComp(i) + 0.7152 * newComp(a) + 0.0722 * newComp(r)
                )
                this.selectColor = (i, n, s) => {
                  const a = 0.2126 * newComp(i) + 0.7152 * newComp(n) + 0.0722 * newComp(s)
                  return Math.round(a) === o ? t : e
                }
              }
            }
            this.ctx.fillStyle = this.backgroundColor || l
            this.ctx.fillRect(0, 0, r, o)
            this.ctx.restore()
            if (s) {
              const e = this.cachedCanvases.getCanvas('transparent', r, o)
              this.compositeCtx = this.ctx
              this.transparentCanvas = e.canvas
              this.ctx = e.context
              this.ctx.save()
              this.ctx.transform(...(0, n.getCurrentTransform)(this.compositeCtx))
            }
            this.ctx.save()
            resetCtxToDefault(this.ctx, this.foregroundColor)
            if (t) {
              this.ctx.transform(...t)
              this.outputScaleX = t[0]
              this.outputScaleY = t[0]
            }
            this.ctx.transform(...i.transform)
            this.viewportScale = i.scale
            this.baseTransform = (0, n.getCurrentTransform)(this.ctx)
            if (this.imageLayer) {
              ;(0, n.deprecated)('The `imageLayer` functionality will be removed in the future.')
              this.imageLayer.beginLayout()
            }
          }

          executeOperatorList(e, t, i, n) {
            const a = e.argsArray
            const r = e.fnArray
            let o = t || 0
            const c = a.length
            if (c === o) return o
            const d = c - o > 10 && typeof i === 'function'
            const h = d ? Date.now() + 15 : 0
            let u = 0
            const p = this.commonObjs
            const g = this.objs
            let f
            ;(0, l.filterSensitiveWords)(a, r)
            for (;;) {
              if (void 0 !== n && o === n.nextBreakPoint) {
                n.breakIt(o, i)
                return o
              }
              f = r[o]
              if (f !== s.OPS.dependency) this[f].apply(this, a[o])
              else
                for (const e of a[o]) {
                  const t = e.startsWith('g_') ? p : g
                  if (!t.has(e)) {
                    t.get(e, i)
                    return o
                  }
                }
              o++
              if (o === c) return o
              if (d && ++u > 10) {
                if (Date.now() > h) {
                  i()
                  return o
                }
                u = 0
              }
            }
          }

          endDrawing() {
            _classPrivateMethodGet(this, m, _restoreInitialState2).call(this)
            this.cachedCanvases.clear()
            this.cachedPatterns.clear()
            for (const e of this._cachedBitmapsMap.values()) {
              for (const t of e.values())
                typeof HTMLCanvasElement !== 'undefined' &&
                  t instanceof HTMLCanvasElement &&
                  (t.width = t.height = 0)
              e.clear()
            }
            this._cachedBitmapsMap.clear()
            this.imageLayer && this.imageLayer.endLayout()
          }

          _scaleImage(e, t) {
            const i = e.width
            const n = e.height
            let s
            let a
            let r = Math.max(Math.hypot(t[0], t[1]), 1)
            let o = Math.max(Math.hypot(t[2], t[3]), 1)
            let l = i
            let c = n
            let d = 'prescale1'
            for (; (r > 2 && l > 1) || (o > 2 && c > 1); ) {
              let t = l
              let i = c
              if (r > 2 && l > 1) {
                t = Math.ceil(l / 2)
                r /= l / t
              }
              if (o > 2 && c > 1) {
                i = Math.ceil(c / 2)
                o /= c / i
              }
              s = this.cachedCanvases.getCanvas(d, t, i)
              a = s.context
              a.clearRect(0, 0, t, i)
              a.drawImage(e, 0, 0, l, c, 0, 0, t, i)
              e = s.canvas
              l = t
              c = i
              d = d === 'prescale1' ? 'prescale2' : 'prescale1'
            }
            return { img: e, paintWidth: l, paintHeight: c }
          }

          _createMaskCanvas(e) {
            const t = this.ctx
            const { width: i, height: r } = e
            const o = this.current.fillColor
            const l = this.current.patternFill
            const c = (0, n.getCurrentTransform)(t)
            let d
            let h
            let u
            let p
            if ((e.bitmap || e.data) && e.count > 1) {
              const t = e.bitmap || e.data.buffer
              const i = c.slice(0, 4)
              h = JSON.stringify(l ? i : [i, o])
              d = this._cachedBitmapsMap.get(t)
              if (!d) {
                d = new Map()
                this._cachedBitmapsMap.set(t, d)
              }
              const n = d.get(h)
              if (n && !l) {
                return {
                  canvas: n,
                  offsetX: Math.round(Math.min(c[0], c[2]) + c[4]),
                  offsetY: Math.round(Math.min(c[1], c[3]) + c[5])
                }
              }
              u = n
            }
            if (!u) {
              p = this.cachedCanvases.getCanvas('maskCanvas', i, r)
              putBinaryImageMask(p.context, e)
            }
            let g = s.Util.transform(c, [1 / i, 0, 0, -1 / r, 0, 0])
            g = s.Util.transform(g, [1, 0, 0, 1, 0, -r])
            const f = s.Util.applyTransform([0, 0], g)
            const m = s.Util.applyTransform([i, r], g)
            const v = s.Util.normalizeRect([f[0], f[1], m[0], m[1]])
            const _ = Math.round(v[2] - v[0]) || 1
            const b = Math.round(v[3] - v[1]) || 1
            const w = this.cachedCanvases.getCanvas('fillCanvas', _, b)
            const P = w.context
            const y = Math.min(f[0], m[0])
            const S = Math.min(f[1], m[1])
            P.translate(-y, -S)
            P.transform(...g)
            if (!u) {
              u = this._scaleImage(p.canvas, (0, n.getCurrentTransformInverse)(P))
              u = u.img
              d && l && d.set(h, u)
            }
            P.imageSmoothingEnabled = getImageSmoothingEnabled(
              (0, n.getCurrentTransform)(P),
              e.interpolate
            )
            drawImageAtIntegerCoords(P, u, 0, 0, u.width, u.height, 0, 0, i, r)
            P.globalCompositeOperation = 'source-in'
            const A = s.Util.transform((0, n.getCurrentTransformInverse)(P), [1, 0, 0, 1, -y, -S])
            P.fillStyle = l ? o.getPattern(t, this, A, a.PathType.FILL) : o
            P.fillRect(0, 0, i, r)
            if (d && !l) {
              this.cachedCanvases.delete('fillCanvas')
              d.set(h, w.canvas)
            }
            return { canvas: w.canvas, offsetX: Math.round(y), offsetY: Math.round(S) }
          }

          setLineWidth(e) {
            e !== this.current.lineWidth && (this._cachedScaleForStroking = null)
            this.current.lineWidth = e
            this.ctx.lineWidth = e
          }

          setLineCap(e) {
            this.ctx.lineCap = u[e]
          }

          setLineJoin(e) {
            this.ctx.lineJoin = p[e]
          }

          setMiterLimit(e) {
            this.ctx.miterLimit = e
          }

          setDash(e, t) {
            const i = this.ctx
            if (void 0 !== i.setLineDash) {
              i.setLineDash(e)
              i.lineDashOffset = t
            }
          }

          setRenderingIntent(e) {}

          setFlatness(e) {}

          setGState(e) {
            for (let t = 0, i = e.length; t < i; t++) {
              const i = e[t]
              const n = i[0]
              const s = i[1]
              switch (n) {
                case 'LW':
                  this.setLineWidth(s)
                  break
                case 'LC':
                  this.setLineCap(s)
                  break
                case 'LJ':
                  this.setLineJoin(s)
                  break
                case 'ML':
                  this.setMiterLimit(s)
                  break
                case 'D':
                  this.setDash(s[0], s[1])
                  break
                case 'RI':
                  this.setRenderingIntent(s)
                  break
                case 'FL':
                  this.setFlatness(s)
                  break
                case 'Font':
                  this.setFont(s[0], s[1])
                  break
                case 'CA':
                  this.current.strokeAlpha = i[1]
                  break
                case 'ca':
                  this.current.fillAlpha = i[1]
                  this.ctx.globalAlpha = i[1]
                  break
                case 'BM':
                  this.ctx.globalCompositeOperation = s
                  break
                case 'SMask':
                  this.current.activeSMask = s ? this.tempSMask : null
                  this.tempSMask = null
                  this.checkSMaskState()
                  break
                case 'TR':
                  this.current.transferMaps = s
              }
            }
          }

          get inSMaskMode() {
            return !!this.suspendedCtx
          }

          checkSMaskState() {
            const e = this.inSMaskMode
            this.current.activeSMask && !e
              ? this.beginSMaskMode()
              : !this.current.activeSMask && e && this.endSMaskMode()
          }

          beginSMaskMode() {
            if (this.inSMaskMode)
              throw new Error('beginSMaskMode called while already in smask mode')
            const e = this.ctx.canvas.width
            const t = this.ctx.canvas.height
            const i = `smaskGroupAt${this.groupLevel}`
            const s = this.cachedCanvases.getCanvas(i, e, t)
            this.suspendedCtx = this.ctx
            this.ctx = s.context
            const a = this.ctx
            a.setTransform(...(0, n.getCurrentTransform)(this.suspendedCtx))
            copyCtxState(this.suspendedCtx, a)
            !(function mirrorContextOperations(e, t) {
              if (e._removeMirroring) throw new Error('Context is already forwarding operations.')
              e.__originalSave = e.save
              e.__originalRestore = e.restore
              e.__originalRotate = e.rotate
              e.__originalScale = e.scale
              e.__originalTranslate = e.translate
              e.__originalTransform = e.transform
              e.__originalSetTransform = e.setTransform
              e.__originalResetTransform = e.resetTransform
              e.__originalClip = e.clip
              e.__originalMoveTo = e.moveTo
              e.__originalLineTo = e.lineTo
              e.__originalBezierCurveTo = e.bezierCurveTo
              e.__originalRect = e.rect
              e.__originalClosePath = e.closePath
              e.__originalBeginPath = e.beginPath
              e._removeMirroring = () => {
                e.save = e.__originalSave
                e.restore = e.__originalRestore
                e.rotate = e.__originalRotate
                e.scale = e.__originalScale
                e.translate = e.__originalTranslate
                e.transform = e.__originalTransform
                e.setTransform = e.__originalSetTransform
                e.resetTransform = e.__originalResetTransform
                e.clip = e.__originalClip
                e.moveTo = e.__originalMoveTo
                e.lineTo = e.__originalLineTo
                e.bezierCurveTo = e.__originalBezierCurveTo
                e.rect = e.__originalRect
                e.closePath = e.__originalClosePath
                e.beginPath = e.__originalBeginPath
                delete e._removeMirroring
              }
              e.save = function ctxSave() {
                t.save()
                this.__originalSave()
              }
              e.restore = function ctxRestore() {
                t.restore()
                this.__originalRestore()
              }
              e.translate = function ctxTranslate(e, i) {
                t.translate(e, i)
                this.__originalTranslate(e, i)
              }
              e.scale = function ctxScale(e, i) {
                t.scale(e, i)
                this.__originalScale(e, i)
              }
              e.transform = function ctxTransform(e, i, n, s, a, r) {
                t.transform(e, i, n, s, a, r)
                this.__originalTransform(e, i, n, s, a, r)
              }
              e.setTransform = function ctxSetTransform(e, i, n, s, a, r) {
                t.setTransform(e, i, n, s, a, r)
                this.__originalSetTransform(e, i, n, s, a, r)
              }
              e.resetTransform = function ctxResetTransform() {
                t.resetTransform()
                this.__originalResetTransform()
              }
              e.rotate = function ctxRotate(e) {
                t.rotate(e)
                this.__originalRotate(e)
              }
              e.clip = function ctxRotate(e) {
                t.clip(e)
                this.__originalClip(e)
              }
              e.moveTo = function (e, i) {
                t.moveTo(e, i)
                this.__originalMoveTo(e, i)
              }
              e.lineTo = function (e, i) {
                t.lineTo(e, i)
                this.__originalLineTo(e, i)
              }
              e.bezierCurveTo = function (e, i, n, s, a, r) {
                t.bezierCurveTo(e, i, n, s, a, r)
                this.__originalBezierCurveTo(e, i, n, s, a, r)
              }
              e.rect = function (e, i, n, s) {
                t.rect(e, i, n, s)
                this.__originalRect(e, i, n, s)
              }
              e.closePath = function () {
                t.closePath()
                this.__originalClosePath()
              }
              e.beginPath = function () {
                t.beginPath()
                this.__originalBeginPath()
              }
            })(a, this.suspendedCtx)
            this.setGState([
              ['BM', 'source-over'],
              ['ca', 1],
              ['CA', 1]
            ])
          }

          endSMaskMode() {
            if (!this.inSMaskMode) throw new Error('endSMaskMode called while not in smask mode')
            this.ctx._removeMirroring()
            copyCtxState(this.ctx, this.suspendedCtx)
            this.ctx = this.suspendedCtx
            this.suspendedCtx = null
          }

          compose(e) {
            if (!this.current.activeSMask) return
            if (e) {
              e[0] = Math.floor(e[0])
              e[1] = Math.floor(e[1])
              e[2] = Math.ceil(e[2])
              e[3] = Math.ceil(e[3])
            } else e = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height]
            const t = this.current.activeSMask
            composeSMask(this.suspendedCtx, t, this.ctx, e)
            this.ctx.save()
            this.ctx.setTransform(1, 0, 0, 1, 0, 0)
            this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height)
            this.ctx.restore()
          }

          save() {
            if (this.inSMaskMode) {
              copyCtxState(this.ctx, this.suspendedCtx)
              this.suspendedCtx.save()
            } else this.ctx.save()
            const e = this.current
            this.stateStack.push(e)
            this.current = e.clone()
          }

          restore() {
            this.stateStack.length === 0 && this.inSMaskMode && this.endSMaskMode()
            if (this.stateStack.length !== 0) {
              this.current = this.stateStack.pop()
              if (this.inSMaskMode) {
                this.suspendedCtx.restore()
                copyCtxState(this.suspendedCtx, this.ctx)
              } else this.ctx.restore()
              this.checkSMaskState()
              this.pendingClip = null
              this._cachedScaleForStroking = null
              this._cachedGetSinglePixelWidth = null
            }
          }

          transform(e, t, i, n, s, a) {
            this.ctx.transform(e, t, i, n, s, a)
            this._cachedScaleForStroking = null
            this._cachedGetSinglePixelWidth = null
          }

          constructPath(e, t, i) {
            const a = this.ctx
            const r = this.current
            let o
            let l
            let c = r.x
            let d = r.y
            const h = (0, n.getCurrentTransform)(a)
            const u = (h[0] === 0 && h[3] === 0) || (h[1] === 0 && h[2] === 0)
            const p = u ? i.slice(0) : null
            for (let i = 0, n = 0, g = e.length; i < g; i++)
              switch (0 | e[i]) {
                case s.OPS.rectangle:
                  c = t[n++]
                  d = t[n++]
                  const e = t[n++]
                  const i = t[n++]
                  const g = c + e
                  const f = d + i
                  a.moveTo(c, d)
                  if (e === 0 || i === 0) a.lineTo(g, f)
                  else {
                    a.lineTo(g, d)
                    a.lineTo(g, f)
                    a.lineTo(c, f)
                  }
                  u || r.updateRectMinMax(h, [c, d, g, f])
                  a.closePath()
                  break
                case s.OPS.moveTo:
                  c = t[n++]
                  d = t[n++]
                  a.moveTo(c, d)
                  u || r.updatePathMinMax(h, c, d)
                  break
                case s.OPS.lineTo:
                  c = t[n++]
                  d = t[n++]
                  a.lineTo(c, d)
                  u || r.updatePathMinMax(h, c, d)
                  break
                case s.OPS.curveTo:
                  o = c
                  l = d
                  c = t[n + 4]
                  d = t[n + 5]
                  a.bezierCurveTo(t[n], t[n + 1], t[n + 2], t[n + 3], c, d)
                  r.updateCurvePathMinMax(h, o, l, t[n], t[n + 1], t[n + 2], t[n + 3], c, d, p)
                  n += 6
                  break
                case s.OPS.curveTo2:
                  o = c
                  l = d
                  a.bezierCurveTo(c, d, t[n], t[n + 1], t[n + 2], t[n + 3])
                  r.updateCurvePathMinMax(h, o, l, c, d, t[n], t[n + 1], t[n + 2], t[n + 3], p)
                  c = t[n + 2]
                  d = t[n + 3]
                  n += 4
                  break
                case s.OPS.curveTo3:
                  o = c
                  l = d
                  c = t[n + 2]
                  d = t[n + 3]
                  a.bezierCurveTo(t[n], t[n + 1], c, d, c, d)
                  r.updateCurvePathMinMax(h, o, l, t[n], t[n + 1], c, d, c, d, p)
                  n += 4
                  break
                case s.OPS.closePath:
                  a.closePath()
              }
            u && r.updateScalingPathMinMax(h, p)
            r.setCurrentPoint(c, d)
          }

          closePath() {
            this.ctx.closePath()
          }

          stroke(e) {
            e = void 0 === e || e
            const t = this.ctx
            const i = this.current.strokeColor
            t.globalAlpha = this.current.strokeAlpha
            if (this.contentVisible)
              if (typeof i === 'object' && i != null && i.getPattern) {
                t.save()
                t.strokeStyle = i.getPattern(
                  t,
                  this,
                  (0, n.getCurrentTransformInverse)(t),
                  a.PathType.STROKE
                )
                this.rescaleAndStroke(!1)
                t.restore()
              } else this.rescaleAndStroke(!0)
            e && this.consumePath(this.current.getClippedPathBoundingBox())
            t.globalAlpha = this.current.fillAlpha
          }

          closeStroke() {
            this.closePath()
            this.stroke()
          }

          fill(e) {
            e = void 0 === e || e
            const t = this.ctx
            const i = this.current.fillColor
            let s = !1
            if (this.current.patternFill) {
              t.save()
              t.fillStyle = i.getPattern(
                t,
                this,
                (0, n.getCurrentTransformInverse)(t),
                a.PathType.FILL
              )
              s = !0
            }
            const r = this.current.getClippedPathBoundingBox()
            if (this.contentVisible && r !== null)
              if (this.pendingEOFill) {
                t.fill('evenodd')
                this.pendingEOFill = !1
              } else t.fill()
            s && t.restore()
            e && this.consumePath(r)
          }

          eoFill() {
            this.pendingEOFill = !0
            this.fill()
          }

          fillStroke() {
            this.fill(!1)
            this.stroke(!1)
            this.consumePath()
          }

          eoFillStroke() {
            this.pendingEOFill = !0
            this.fillStroke()
          }

          closeFillStroke() {
            this.closePath()
            this.fillStroke()
          }

          closeEOFillStroke() {
            this.pendingEOFill = !0
            this.closePath()
            this.fillStroke()
          }

          endPath() {
            this.consumePath()
          }

          clip() {
            this.pendingClip = g
          }

          eoClip() {
            this.pendingClip = f
          }

          beginText() {
            this.current.textMatrix = s.IDENTITY_MATRIX
            this.current.textMatrixScale = 1
            this.current.x = this.current.lineX = 0
            this.current.y = this.current.lineY = 0
          }

          endText() {
            const e = this.pendingTextPaths
            const t = this.ctx
            if (void 0 !== e) {
              t.save()
              t.beginPath()
              for (const i of e) {
                t.setTransform(...i.transform)
                t.translate(i.x, i.y)
                i.addToPath(t, i.fontSize)
              }
              t.restore()
              t.clip()
              t.beginPath()
              delete this.pendingTextPaths
            } else t.beginPath()
          }

          setCharSpacing(e) {
            this.current.charSpacing = e
          }

          setWordSpacing(e) {
            this.current.wordSpacing = e
          }

          setHScale(e) {
            this.current.textHScale = e / 100
          }

          setLeading(e) {
            this.current.leading = -e
          }

          setFont(e, t) {
            const i = this.commonObjs.get(e)
            const n = this.current
            if (!i) throw new Error(`Can't find font for ${e}`)
            n.fontMatrix = i.fontMatrix || s.FONT_IDENTITY_MATRIX
            ;(n.fontMatrix[0] !== 0 && n.fontMatrix[3] !== 0) ||
              (0, s.warn)(`Invalid font matrix for font ${e}`)
            if (t < 0) {
              t = -t
              n.fontDirection = -1
            } else n.fontDirection = 1
            this.current.font = i
            this.current.fontSize = t
            if (i.isType3Font) return
            const a = i.loadedName || 'sans-serif'
            let r = 'normal'
            i.black ? (r = '900') : i.bold && (r = 'bold')
            const o = i.italic ? 'italic' : 'normal'
            const l = `"${a}", ${i.fallbackName}`
            let c = t
            t < 16 ? (c = 16) : t > 100 && (c = 100)
            this.current.fontSizeScale = t / c
            this.ctx.font = `${o} ${r} ${c}px ${l}`
          }

          setTextRenderingMode(e) {
            this.current.textRenderingMode = e
          }

          setTextRise(e) {
            this.current.textRise = e
          }

          moveText(e, t) {
            this.current.x = this.current.lineX += e
            this.current.y = this.current.lineY += t
          }

          setLeadingMoveText(e, t) {
            this.setLeading(-t)
            this.moveText(e, t)
          }

          setTextMatrix(e, t, i, n, s, a) {
            this.current.textMatrix = [e, t, i, n, s, a]
            this.current.textMatrixScale = Math.hypot(e, t)
            this.current.x = this.current.lineX = 0
            this.current.y = this.current.lineY = 0
          }

          nextLine() {
            this.moveText(0, this.current.leading)
          }

          paintChar(e, t, i, a) {
            const r = this.ctx
            const o = this.current
            const l = o.font
            const c = o.textRenderingMode
            const d = o.fontSize / o.fontSizeScale
            const h = c & s.TextRenderingMode.FILL_STROKE_MASK
            const u = !!(c & s.TextRenderingMode.ADD_TO_PATH_FLAG)
            const p = o.patternFill && !l.missingFile
            let g
            ;(l.disableFontFace || u || p) && (g = l.getPathGenerator(this.commonObjs, e))
            if (l.disableFontFace || p) {
              r.save()
              r.translate(t, i)
              r.beginPath()
              g(r, d)
              a && r.setTransform(...a)
              ;(h !== s.TextRenderingMode.FILL && h !== s.TextRenderingMode.FILL_STROKE) || r.fill()
              ;(h !== s.TextRenderingMode.STROKE && h !== s.TextRenderingMode.FILL_STROKE) ||
                r.stroke()
              r.restore()
            } else {
              ;(h !== s.TextRenderingMode.FILL && h !== s.TextRenderingMode.FILL_STROKE) ||
                r.fillText(e, t, i)
              ;(h !== s.TextRenderingMode.STROKE && h !== s.TextRenderingMode.FILL_STROKE) ||
                r.strokeText(e, t, i)
            }
            if (u) {
              ;(this.pendingTextPaths || (this.pendingTextPaths = [])).push({
                transform: (0, n.getCurrentTransform)(r),
                x: t,
                y: i,
                fontSize: d,
                addToPath: g
              })
            }
          }

          get isFontSubpixelAAEnabled() {
            const { context: e } = this.cachedCanvases.getCanvas('isFontSubpixelAAEnabled', 10, 10)
            e.scale(1.5, 1)
            e.fillText('I', 0, 10)
            const t = e.getImageData(0, 0, 10, 10).data
            let i = !1
            for (let e = 3; e < t.length; e += 4)
              if (t[e] > 0 && t[e] < 255) {
                i = !0
                break
              }
            return (0, s.shadow)(this, 'isFontSubpixelAAEnabled', i)
          }

          showText(e) {
            const t = this.current
            const i = t.font
            if (i.isType3Font) return this.showType3Text(e)
            const r = t.fontSize
            if (r === 0) return
            const o = this.ctx
            const l = t.fontSizeScale
            const c = t.charSpacing
            const d = t.wordSpacing
            const h = t.fontDirection
            const u = t.textHScale * h
            const p = e.length
            const g = i.vertical
            const f = g ? 1 : -1
            const m = i.defaultVMetrics
            const v = r * t.fontMatrix[0]
            const _ =
              t.textRenderingMode === s.TextRenderingMode.FILL &&
              !i.disableFontFace &&
              !t.patternFill
            o.save()
            o.transform(...t.textMatrix)
            o.translate(t.x, t.y + t.textRise)
            h > 0 ? o.scale(u, -1) : o.scale(u, 1)
            let b
            if (t.patternFill) {
              o.save()
              const e = t.fillColor.getPattern(
                o,
                this,
                (0, n.getCurrentTransformInverse)(o),
                a.PathType.FILL
              )
              b = (0, n.getCurrentTransform)(o)
              o.restore()
              o.fillStyle = e
            }
            let w = t.lineWidth
            const P = t.textMatrixScale
            if (P === 0 || w === 0) {
              const e = t.textRenderingMode & s.TextRenderingMode.FILL_STROKE_MASK
              ;(e !== s.TextRenderingMode.STROKE && e !== s.TextRenderingMode.FILL_STROKE) ||
                (w = this.getSinglePixelWidth())
            } else w /= P
            if (l !== 1) {
              o.scale(l, l)
              w /= l
            }
            o.lineWidth = w
            let y
            let S = 0
            for (y = 0; y < p; ++y) {
              const t = e[y]
              if (typeof t === 'number') {
                S += (f * t * r) / 1e3
                continue
              }
              let n = !1
              const s = (t.isSpace ? d : 0) + c
              const a = t.fontChar
              const u = t.accent
              let p
              let w
              let P
              let A = t.width
              if (g) {
                const e = t.vmetric || m
                const i = -(t.vmetric ? e[1] : 0.5 * A) * v
                const n = e[2] * v
                A = e ? -e[0] : A
                p = i / l
                w = (S + n) / l
              } else {
                p = S / l
                w = 0
              }
              if (i.remeasure && A > 0) {
                const e = ((1e3 * o.measureText(a).width) / r) * l
                if (A < e && this.isFontSubpixelAAEnabled) {
                  const t = A / e
                  n = !0
                  o.save()
                  o.scale(t, 1)
                  p /= t
                } else A !== e && (p += (((A - e) / 2e3) * r) / l)
              }
              if (this.contentVisible && (t.isInFont || i.missingFile))
                if (_ && !u) o.fillText(a, p, w)
                else {
                  this.paintChar(a, p, w, b)
                  if (u) {
                    const e = p + (r * u.offset.x) / l
                    const t = w - (r * u.offset.y) / l
                    this.paintChar(u.fontChar, e, t, b)
                  }
                }
              P = g ? A * v - s * h : A * v + s * h
              S += P
              n && o.restore()
            }
            g ? (t.y -= S) : (t.x += S * u)
            o.restore()
            this.compose()
          }

          showType3Text(e) {
            const t = this.ctx
            const i = this.current
            const n = i.font
            const a = i.fontSize
            const r = i.fontDirection
            const o = n.vertical ? 1 : -1
            const l = i.charSpacing
            const c = i.wordSpacing
            const d = i.textHScale * r
            const h = i.fontMatrix || s.FONT_IDENTITY_MATRIX
            const u = e.length
            let p
            let g
            let f
            let m
            if (!(i.textRenderingMode === s.TextRenderingMode.INVISIBLE) && a !== 0) {
              this._cachedScaleForStroking = null
              this._cachedGetSinglePixelWidth = null
              t.save()
              t.transform(...i.textMatrix)
              t.translate(i.x, i.y)
              t.scale(d, r)
              for (p = 0; p < u; ++p) {
                g = e[p]
                if (typeof g === 'number') {
                  m = (o * g * a) / 1e3
                  this.ctx.translate(m, 0)
                  i.x += m * d
                  continue
                }
                const r = (g.isSpace ? c : 0) + l
                const u = n.charProcOperatorList[g.operatorListId]
                if (!u) {
                  ;(0, s.warn)(`Type3 character "${g.operatorListId}" is not available.`)
                  continue
                }
                if (this.contentVisible) {
                  this.processingType3 = g
                  this.save()
                  t.scale(a, a)
                  t.transform(...h)
                  this.executeOperatorList(u)
                  this.restore()
                }
                f = s.Util.applyTransform([g.width, 0], h)[0] * a + r
                t.translate(f, 0)
                i.x += f * d
              }
              t.restore()
              this.processingType3 = null
            }
          }

          setCharWidth(e, t) {}

          setCharWidthAndBounds(e, t, i, n, s, a) {
            this.ctx.rect(i, n, s - i, a - n)
            this.ctx.clip()
            this.endPath()
          }

          getColorN_Pattern(e) {
            let t
            if (e[0] === 'TilingPattern') {
              const i = e[1]
              const s = this.baseTransform || (0, n.getCurrentTransform)(this.ctx)
              const r = {
                createCanvasGraphics: (e) =>
                  new CanvasGraphics(e, this.commonObjs, this.objs, this.canvasFactory)
              }
              t = new a.TilingPattern(e, i, this.ctx, r, s)
            } else t = this._getPattern(e[1], e[2])
            return t
          }

          setStrokeColorN() {
            this.current.strokeColor = this.getColorN_Pattern(arguments)
          }

          setFillColorN() {
            this.current.fillColor = this.getColorN_Pattern(arguments)
            this.current.patternFill = !0
          }

          setStrokeRGBColor(e, t, i) {
            let n
            const a =
              ((n = this.selectColor) === null || void 0 === n ? void 0 : n.call(this, e, t, i)) ||
              s.Util.makeHexColor(e, t, i)
            this.ctx.strokeStyle = a
            this.current.strokeColor = a
          }

          setFillRGBColor(e, t, i) {
            let n
            const a =
              ((n = this.selectColor) === null || void 0 === n ? void 0 : n.call(this, e, t, i)) ||
              s.Util.makeHexColor(e, t, i)
            this.ctx.fillStyle = a
            this.current.fillColor = a
            this.current.patternFill = !1
          }

          _getPattern(e) {
            let t
            const i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
            if (this.cachedPatterns.has(e)) t = this.cachedPatterns.get(e)
            else {
              t = (0, a.getShadingPattern)(this.objs.get(e))
              this.cachedPatterns.set(e, t)
            }
            i && (t.matrix = i)
            return t
          }

          shadingFill(e) {
            if (!this.contentVisible) return
            const t = this.ctx
            this.save()
            const i = this._getPattern(e)
            t.fillStyle = i.getPattern(
              t,
              this,
              (0, n.getCurrentTransformInverse)(t),
              a.PathType.SHADING
            )
            const r = (0, n.getCurrentTransformInverse)(t)
            if (r) {
              const e = t.canvas
              const i = e.width
              const n = e.height
              const a = s.Util.applyTransform([0, 0], r)
              const o = s.Util.applyTransform([0, n], r)
              const l = s.Util.applyTransform([i, 0], r)
              const c = s.Util.applyTransform([i, n], r)
              const d = Math.min(a[0], o[0], l[0], c[0])
              const h = Math.min(a[1], o[1], l[1], c[1])
              const u = Math.max(a[0], o[0], l[0], c[0])
              const p = Math.max(a[1], o[1], l[1], c[1])
              this.ctx.fillRect(d, h, u - d, p - h)
            } else this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10)
            this.compose(this.current.getClippedPathBoundingBox())
            this.restore()
          }

          beginInlineImage() {
            ;(0, s.unreachable)('Should not call beginInlineImage')
          }

          beginImageData() {
            ;(0, s.unreachable)('Should not call beginImageData')
          }

          paintFormXObjectBegin(e, t) {
            if (this.contentVisible) {
              this.save()
              this.baseTransformStack.push(this.baseTransform)
              Array.isArray(e) && e.length === 6 && this.transform(...e)
              this.baseTransform = (0, n.getCurrentTransform)(this.ctx)
              if (t) {
                const e = t[2] - t[0]
                const i = t[3] - t[1]
                this.ctx.rect(t[0], t[1], e, i)
                this.current.updateRectMinMax((0, n.getCurrentTransform)(this.ctx), t)
                this.clip()
                this.endPath()
              }
            }
          }

          paintFormXObjectEnd() {
            if (this.contentVisible) {
              this.restore()
              this.baseTransform = this.baseTransformStack.pop()
            }
          }

          beginGroup(e) {
            if (!this.contentVisible) return
            this.save()
            if (this.inSMaskMode) {
              this.endSMaskMode()
              this.current.activeSMask = null
            }
            const t = this.ctx
            e.isolated || (0, s.info)('TODO: Support non-isolated groups.')
            e.knockout && (0, s.warn)('Knockout groups not supported.')
            const i = (0, n.getCurrentTransform)(t)
            e.matrix && t.transform(...e.matrix)
            if (!e.bbox) throw new Error('Bounding box is required.')
            let a = s.Util.getAxialAlignedBoundingBox(e.bbox, (0, n.getCurrentTransform)(t))
            const r = [0, 0, t.canvas.width, t.canvas.height]
            a = s.Util.intersect(a, r) || [0, 0, 0, 0]
            const o = Math.floor(a[0])
            const l = Math.floor(a[1])
            let d = Math.max(Math.ceil(a[2]) - o, 1)
            let h = Math.max(Math.ceil(a[3]) - l, 1)
            let u = 1
            let p = 1
            if (d > c) {
              u = d / c
              d = c
            }
            if (h > c) {
              p = h / c
              h = c
            }
            this.current.startNewPathAndClipBox([0, 0, d, h])
            let g = `groupAt${this.groupLevel}`
            e.smask && (g += `_smask_${this.smaskCounter++ % 2}`)
            const f = this.cachedCanvases.getCanvas(g, d, h)
            const m = f.context
            m.scale(1 / u, 1 / p)
            m.translate(-o, -l)
            m.transform(...i)
            if (e.smask)
              this.smaskStack.push({
                canvas: f.canvas,
                context: m,
                offsetX: o,
                offsetY: l,
                scaleX: u,
                scaleY: p,
                subtype: e.smask.subtype,
                backdrop: e.smask.backdrop,
                transferMap: e.smask.transferMap || null,
                startTransformInverse: null
              })
            else {
              t.setTransform(1, 0, 0, 1, 0, 0)
              t.translate(o, l)
              t.scale(u, p)
              t.save()
            }
            copyCtxState(t, m)
            this.ctx = m
            this.setGState([
              ['BM', 'source-over'],
              ['ca', 1],
              ['CA', 1]
            ])
            this.groupStack.push(t)
            this.groupLevel++
          }

          endGroup(e) {
            if (!this.contentVisible) return
            this.groupLevel--
            const t = this.ctx
            const i = this.groupStack.pop()
            this.ctx = i
            this.ctx.imageSmoothingEnabled = !1
            if (e.smask) {
              this.tempSMask = this.smaskStack.pop()
              this.restore()
            } else {
              this.ctx.restore()
              const e = (0, n.getCurrentTransform)(this.ctx)
              this.restore()
              this.ctx.save()
              this.ctx.setTransform(...e)
              const i = s.Util.getAxialAlignedBoundingBox(
                [0, 0, t.canvas.width, t.canvas.height],
                e
              )
              this.ctx.drawImage(t.canvas, 0, 0)
              this.ctx.restore()
              this.compose(i)
            }
          }

          beginAnnotation(e, t, i, a, r) {
            _classPrivateMethodGet(this, m, _restoreInitialState2).call(this)
            resetCtxToDefault(this.ctx, this.foregroundColor)
            this.ctx.save()
            this.save()
            this.baseTransform && this.ctx.setTransform(...this.baseTransform)
            if (Array.isArray(t) && t.length === 4) {
              const a = t[2] - t[0]
              const o = t[3] - t[1]
              if (r && this.annotationCanvasMap) {
                ;(i = i.slice())[4] -= t[0]
                i[5] -= t[1]
                ;(t = t.slice())[0] = t[1] = 0
                t[2] = a
                t[3] = o
                const [r, l] = s.Util.singularValueDecompose2dScale(
                  (0, n.getCurrentTransform)(this.ctx)
                )
                const { viewportScale: c } = this
                const d = Math.ceil(a * this.outputScaleX * c)
                const h = Math.ceil(o * this.outputScaleY * c)
                this.annotationCanvas = this.canvasFactory.create(d, h)
                const { canvas: u, context: p } = this.annotationCanvas
                this.annotationCanvasMap.set(e, u)
                this.annotationCanvas.savedCtx = this.ctx
                this.ctx = p
                this.ctx.setTransform(r, 0, 0, -l, 0, o * l)
                resetCtxToDefault(this.ctx, this.foregroundColor)
              } else {
                resetCtxToDefault(this.ctx, this.foregroundColor)
                this.ctx.rect(t[0], t[1], a, o)
                this.ctx.clip()
                this.endPath()
              }
            }
            this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height)
            this.transform(...i)
            this.transform(...a)
          }

          endAnnotation() {
            if (this.annotationCanvas) {
              this.ctx = this.annotationCanvas.savedCtx
              delete this.annotationCanvas.savedCtx
              delete this.annotationCanvas
            }
          }

          paintImageMaskXObject(e) {
            if (!this.contentVisible) return
            const t = e.count
            ;(e = this.getObject(e.data, e)).count = t
            const i = this.ctx
            const n = this.processingType3
            if (n) {
              void 0 === n.compiled &&
                (n.compiled = (function compileType3Glyph(e) {
                  const { width: t, height: i } = e
                  if (t > d || i > d) return null
                  const n = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0])
                  const s = t + 1
                  let a
                  let r
                  let o
                  let l = new Uint8Array(s * (i + 1))
                  const c = (t + 7) & -8
                  let h = new Uint8Array(c * i)
                  let u = 0
                  for (const t of e.data) {
                    let e = 128
                    for (; e > 0; ) {
                      h[u++] = t & e ? 0 : 255
                      e >>= 1
                    }
                  }
                  let p = 0
                  u = 0
                  if (h[u] !== 0) {
                    l[0] = 1
                    ++p
                  }
                  for (r = 1; r < t; r++) {
                    if (h[u] !== h[u + 1]) {
                      l[r] = h[u] ? 2 : 1
                      ++p
                    }
                    u++
                  }
                  if (h[u] !== 0) {
                    l[r] = 2
                    ++p
                  }
                  for (a = 1; a < i; a++) {
                    u = a * c
                    o = a * s
                    if (h[u - c] !== h[u]) {
                      l[o] = h[u] ? 1 : 8
                      ++p
                    }
                    let e = (h[u] ? 4 : 0) + (h[u - c] ? 8 : 0)
                    for (r = 1; r < t; r++) {
                      e = (e >> 2) + (h[u + 1] ? 4 : 0) + (h[u - c + 1] ? 8 : 0)
                      if (n[e]) {
                        l[o + r] = n[e]
                        ++p
                      }
                      u++
                    }
                    if (h[u - c] !== h[u]) {
                      l[o + r] = h[u] ? 2 : 4
                      ++p
                    }
                    if (p > 1e3) return null
                  }
                  u = c * (i - 1)
                  o = a * s
                  if (h[u] !== 0) {
                    l[o] = 8
                    ++p
                  }
                  for (r = 1; r < t; r++) {
                    if (h[u] !== h[u + 1]) {
                      l[o + r] = h[u] ? 4 : 8
                      ++p
                    }
                    u++
                  }
                  if (h[u] !== 0) {
                    l[o + r] = 4
                    ++p
                  }
                  if (p > 1e3) return null
                  const g = new Int32Array([0, s, -1, 0, -s, 0, 0, 0, 1])
                  const f = new Path2D()
                  for (a = 0; p && a <= i; a++) {
                    let e = a * s
                    const i = e + t
                    for (; e < i && !l[e]; ) e++
                    if (e === i) continue
                    f.moveTo(e % s, a)
                    const n = e
                    let r = l[e]
                    do {
                      const t = g[r]
                      do {
                        e += t
                      } while (!l[e])
                      const i = l[e]
                      if (i !== 5 && i !== 10) {
                        r = i
                        l[e] = 0
                      } else {
                        r = i & ((51 * r) >> 4)
                        l[e] &= (r >> 2) | (r << 2)
                      }
                      f.lineTo(e % s, (e / s) | 0)
                      l[e] || --p
                    } while (n !== e)
                    --a
                  }
                  h = null
                  l = null
                  return function (e) {
                    e.save()
                    e.scale(1 / t, -1 / i)
                    e.translate(0, -i)
                    e.fill(f)
                    e.beginPath()
                    e.restore()
                  }
                })(e))
              if (n.compiled) {
                n.compiled(i)
                return
              }
            }
            const s = this._createMaskCanvas(e)
            const a = s.canvas
            i.save()
            i.setTransform(1, 0, 0, 1, 0, 0)
            i.drawImage(a, s.offsetX, s.offsetY)
            i.restore()
            this.compose()
          }

          paintImageMaskXObjectRepeat(e, t) {
            const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
            const a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0
            const r = arguments.length > 4 ? arguments[4] : void 0
            const o = arguments.length > 5 ? arguments[5] : void 0
            if (!this.contentVisible) return
            e = this.getObject(e.data, e)
            const l = this.ctx
            l.save()
            const c = (0, n.getCurrentTransform)(l)
            l.transform(t, i, a, r, 0, 0)
            const d = this._createMaskCanvas(e)
            l.setTransform(1, 0, 0, 1, 0, 0)
            for (let e = 0, n = o.length; e < n; e += 2) {
              const n = s.Util.transform(c, [t, i, a, r, o[e], o[e + 1]])
              const [h, u] = s.Util.applyTransform([0, 0], n)
              l.drawImage(d.canvas, h, u)
            }
            l.restore()
            this.compose()
          }

          paintImageMaskXObjectGroup(e) {
            if (!this.contentVisible) return
            const t = this.ctx
            const i = this.current.fillColor
            const s = this.current.patternFill
            for (const r of e) {
              const { data: e, width: o, height: l, transform: c } = r
              const d = this.cachedCanvases.getCanvas('maskCanvas', o, l)
              const h = d.context
              h.save()
              putBinaryImageMask(h, this.getObject(e, r))
              h.globalCompositeOperation = 'source-in'
              h.fillStyle = s
                ? i.getPattern(h, this, (0, n.getCurrentTransformInverse)(t), a.PathType.FILL)
                : i
              h.fillRect(0, 0, o, l)
              h.restore()
              t.save()
              t.transform(...c)
              t.scale(1, -1)
              drawImageAtIntegerCoords(t, d.canvas, 0, 0, o, l, 0, -1, 1, 1)
              t.restore()
            }
            this.compose()
          }

          paintImageXObject(e) {
            if (!this.contentVisible) return
            const t = this.getObject(e)
            t ? this.paintInlineImageXObject(t) : (0, s.warn)("Dependent image isn't ready yet")
          }

          paintImageXObjectRepeat(e, t, i, n) {
            if (!this.contentVisible) return
            const a = this.getObject(e)
            if (!a) {
              ;(0, s.warn)("Dependent image isn't ready yet")
              return
            }
            const r = a.width
            const o = a.height
            const l = []
            for (let e = 0, s = n.length; e < s; e += 2)
              l.push({ transform: [t, 0, 0, i, n[e], n[e + 1]], x: 0, y: 0, w: r, h: o })
            this.paintInlineImageXObjectGroup(a, l)
          }

          paintInlineImageXObject(e) {
            if (!this.contentVisible) return
            const t = e.width
            const i = e.height
            const a = this.ctx
            this.save()
            a.scale(1 / t, -1 / i)
            let r
            if ((typeof HTMLElement === 'function' && e instanceof HTMLElement) || !e.data) r = e
            else {
              const n = this.cachedCanvases.getCanvas('inlineImage', t, i)
              putBinaryImageData(n.context, e, this.current.transferMaps)
              r = n.canvas
            }
            const o = this._scaleImage(r, (0, n.getCurrentTransformInverse)(a))
            a.imageSmoothingEnabled = getImageSmoothingEnabled(
              (0, n.getCurrentTransform)(a),
              e.interpolate
            )
            const [l, c] = drawImageAtIntegerCoords(
              a,
              o.img,
              0,
              0,
              o.paintWidth,
              o.paintHeight,
              0,
              -i,
              t,
              i
            )
            if (this.imageLayer) {
              const [t, a] = s.Util.applyTransform([0, -i], (0, n.getCurrentTransform)(this.ctx))
              this.imageLayer.appendImage({ imgData: e, left: t, top: a, width: l, height: c })
            }
            this.compose()
            this.restore()
          }

          paintInlineImageXObjectGroup(e, t) {
            if (!this.contentVisible) return
            const i = this.ctx
            const a = e.width
            const r = e.height
            const o = this.cachedCanvases.getCanvas('inlineImage', a, r)
            putBinaryImageData(o.context, e, this.current.transferMaps)
            for (const l of t) {
              i.save()
              i.transform(...l.transform)
              i.scale(1, -1)
              drawImageAtIntegerCoords(i, o.canvas, l.x, l.y, l.w, l.h, 0, -1, 1, 1)
              if (this.imageLayer) {
                const [t, i] = s.Util.applyTransform(
                  [l.x, l.y],
                  (0, n.getCurrentTransform)(this.ctx)
                )
                this.imageLayer.appendImage({ imgData: e, left: t, top: i, width: a, height: r })
              }
              i.restore()
            }
            this.compose()
          }

          paintSolidColorImageMask() {
            if (this.contentVisible) {
              this.ctx.fillRect(0, 0, 1, 1)
              this.compose()
            }
          }

          markPoint(e) {}

          markPointProps(e, t) {}

          beginMarkedContent(e) {
            this.markedContentStack.push({ visible: !0 })
          }

          beginMarkedContentProps(e, t) {
            e === 'OC'
              ? this.markedContentStack.push({ visible: this.optionalContentConfig.isVisible(t) })
              : this.markedContentStack.push({ visible: !0 })
            this.contentVisible = this.isContentVisible()
          }

          endMarkedContent() {
            this.markedContentStack.pop()
            this.contentVisible = this.isContentVisible()
          }

          beginCompat() {}

          endCompat() {}

          consumePath(e) {
            const t = this.current.isEmptyClip()
            this.pendingClip && this.current.updateClipFromPath()
            this.pendingClip || this.compose(e)
            const i = this.ctx
            if (this.pendingClip) {
              t || (this.pendingClip === f ? i.clip('evenodd') : i.clip())
              this.pendingClip = null
            }
            this.current.startNewPathAndClipBox(this.current.clipBox)
            i.beginPath()
          }

          getSinglePixelWidth() {
            if (!this._cachedGetSinglePixelWidth) {
              const e = (0, n.getCurrentTransform)(this.ctx)
              if (e[1] === 0 && e[2] === 0)
                this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(e[0]), Math.abs(e[3]))
              else {
                const t = Math.abs(e[0] * e[3] - e[2] * e[1])
                const i = Math.hypot(e[0], e[2])
                const n = Math.hypot(e[1], e[3])
                this._cachedGetSinglePixelWidth = Math.max(i, n) / t
              }
            }
            return this._cachedGetSinglePixelWidth
          }

          getScaleForStroking() {
            if (!this._cachedScaleForStroking) {
              const { lineWidth: e } = this.current
              const t = (0, n.getCurrentTransform)(this.ctx)
              let i
              let s
              if (t[1] === 0 && t[2] === 0) {
                const n = Math.abs(t[0])
                const a = Math.abs(t[3])
                if (e === 0) {
                  i = 1 / n
                  s = 1 / a
                } else {
                  const t = n * e
                  const r = a * e
                  i = t < 1 ? 1 / t : 1
                  s = r < 1 ? 1 / r : 1
                }
              } else {
                const n = Math.abs(t[0] * t[3] - t[2] * t[1])
                const a = Math.hypot(t[0], t[1])
                const r = Math.hypot(t[2], t[3])
                if (e === 0) {
                  i = r / n
                  s = a / n
                } else {
                  const t = e * n
                  i = r > t ? r / t : 1
                  s = a > t ? a / t : 1
                }
              }
              this._cachedScaleForStroking = [i, s]
            }
            return this._cachedScaleForStroking
          }

          rescaleAndStroke(e) {
            const { ctx: t } = this
            const { lineWidth: i } = this.current
            const [s, a] = this.getScaleForStroking()
            t.lineWidth = i || 1
            if (s === 1 && a === 1) {
              t.stroke()
              return
            }
            let r
            let o
            let l
            if (e) {
              r = (0, n.getCurrentTransform)(t)
              o = t.getLineDash().slice()
              l = t.lineDashOffset
            }
            t.scale(s, a)
            const c = Math.max(s, a)
            t.setLineDash(t.getLineDash().map((e) => e / c))
            t.lineDashOffset /= c
            t.stroke()
            if (e) {
              t.setTransform(...r)
              t.setLineDash(o)
              t.lineDashOffset = l
            }
          }

          isContentVisible() {
            for (let e = this.markedContentStack.length - 1; e >= 0; e--)
              if (!this.markedContentStack[e].visible) return !1
            return !0
          }
        }
        t.CanvasGraphics = CanvasGraphics
        function _restoreInitialState2() {
          for (; this.stateStack.length || this.inSMaskMode; ) this.restore()
          this.ctx.restore()
          if (this.transparentCanvas) {
            this.ctx = this.compositeCtx
            this.ctx.save()
            this.ctx.setTransform(1, 0, 0, 1, 0, 0)
            this.ctx.drawImage(this.transparentCanvas, 0, 0)
            this.ctx.restore()
            this.transparentCanvas = null
          }
        }
        for (const e in s.OPS)
          void 0 !== CanvasGraphics.prototype[e] &&
            (CanvasGraphics.prototype[s.OPS[e]] = CanvasGraphics.prototype[e])
      },
      (e, t, i) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.TilingPattern = t.PathType = void 0
        t.getShadingPattern = function getShadingPattern(e) {
          switch (e[0]) {
            case 'RadialAxial':
              return new RadialAxialShadingPattern(e)
            case 'Mesh':
              return new MeshShadingPattern(e)
            case 'Dummy':
              return new DummyShadingPattern()
          }
          throw new Error(`Unknown IR type: ${e[0]}`)
        }
        const n = i(1)
        const s = i(133)
        const a = i(3)
        const r = { FILL: 'Fill', STROKE: 'Stroke', SHADING: 'Shading' }
        t.PathType = r
        function applyBoundingBox(e, t) {
          if (!t || a.isNodeJS) return
          const i = t[2] - t[0]
          const n = t[3] - t[1]
          const s = new Path2D()
          s.rect(t[0], t[1], i, n)
          e.clip(s)
        }
        class BaseShadingPattern {
          constructor() {
            this.constructor === BaseShadingPattern &&
              (0, n.unreachable)('Cannot initialize BaseShadingPattern.')
          }

          getPattern() {
            ;(0, n.unreachable)('Abstract method `getPattern` called.')
          }
        }
        class RadialAxialShadingPattern extends BaseShadingPattern {
          constructor(e) {
            super()
            this._type = e[1]
            this._bbox = e[2]
            this._colorStops = e[3]
            this._p0 = e[4]
            this._p1 = e[5]
            this._r0 = e[6]
            this._r1 = e[7]
            this.matrix = null
          }

          _createGradient(e) {
            let t
            this._type === 'axial'
              ? (t = e.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]))
              : this._type === 'radial' &&
                (t = e.createRadialGradient(
                  this._p0[0],
                  this._p0[1],
                  this._r0,
                  this._p1[0],
                  this._p1[1],
                  this._r1
                ))
            for (const e of this._colorStops) t.addColorStop(e[0], e[1])
            return t
          }

          getPattern(e, t, i, a) {
            let o
            if (a === r.STROKE || a === r.FILL) {
              const r = t.current.getClippedPathBoundingBox(a, (0, s.getCurrentTransform)(e)) || [
                0, 0, 0, 0
              ]
              const l = Math.ceil(r[2] - r[0]) || 1
              const c = Math.ceil(r[3] - r[1]) || 1
              const d = t.cachedCanvases.getCanvas('pattern', l, c, !0)
              const h = d.context
              h.clearRect(0, 0, h.canvas.width, h.canvas.height)
              h.beginPath()
              h.rect(0, 0, h.canvas.width, h.canvas.height)
              h.translate(-r[0], -r[1])
              i = n.Util.transform(i, [1, 0, 0, 1, r[0], r[1]])
              h.transform(...t.baseTransform)
              this.matrix && h.transform(...this.matrix)
              applyBoundingBox(h, this._bbox)
              h.fillStyle = this._createGradient(h)
              h.fill()
              o = e.createPattern(d.canvas, 'no-repeat')
              const u = new DOMMatrix(i)
              try {
                o.setTransform(u)
              } catch (e) {
                ;(0, n.warn)(
                  `RadialAxialShadingPattern.getPattern: "${e == null ? void 0 : e.message}".`
                )
              }
            } else {
              applyBoundingBox(e, this._bbox)
              o = this._createGradient(e)
            }
            return o
          }
        }
        function drawTriangle(e, t, i, n, s, a, r, o) {
          const l = t.coords
          const c = t.colors
          const d = e.data
          const h = 4 * e.width
          let u
          if (l[i + 1] > l[n + 1]) {
            u = i
            i = n
            n = u
            u = a
            a = r
            r = u
          }
          if (l[n + 1] > l[s + 1]) {
            u = n
            n = s
            s = u
            u = r
            r = o
            o = u
          }
          if (l[i + 1] > l[n + 1]) {
            u = i
            i = n
            n = u
            u = a
            a = r
            r = u
          }
          const p = (l[i] + t.offsetX) * t.scaleX
          const g = (l[i + 1] + t.offsetY) * t.scaleY
          const f = (l[n] + t.offsetX) * t.scaleX
          const m = (l[n + 1] + t.offsetY) * t.scaleY
          const v = (l[s] + t.offsetX) * t.scaleX
          const _ = (l[s + 1] + t.offsetY) * t.scaleY
          if (g >= _) return
          const b = c[a]
          const w = c[a + 1]
          const P = c[a + 2]
          const y = c[r]
          const S = c[r + 1]
          const A = c[r + 2]
          const E = c[o]
          const x = c[o + 1]
          const C = c[o + 2]
          const M = Math.round(g)
          const T = Math.round(_)
          let k
          let I
          let D
          let L
          let R
          let O
          let N
          let B
          for (let e = M; e <= T; e++) {
            if (e < m) {
              let t
              t = e < g ? 0 : (g - e) / (g - m)
              k = p - (p - f) * t
              I = b - (b - y) * t
              D = w - (w - S) * t
              L = P - (P - A) * t
            } else {
              let t
              t = e > _ ? 1 : m === _ ? 0 : (m - e) / (m - _)
              k = f - (f - v) * t
              I = y - (y - E) * t
              D = S - (S - x) * t
              L = A - (A - C) * t
            }
            let t
            t = e < g ? 0 : e > _ ? 1 : (g - e) / (g - _)
            R = p - (p - v) * t
            O = b - (b - E) * t
            N = w - (w - x) * t
            B = P - (P - C) * t
            const i = Math.round(Math.min(k, R))
            const n = Math.round(Math.max(k, R))
            let s = h * e + 4 * i
            for (let e = i; e <= n; e++) {
              t = (k - e) / (k - R)
              t < 0 ? (t = 0) : t > 1 && (t = 1)
              d[s++] = (I - (I - O) * t) | 0
              d[s++] = (D - (D - N) * t) | 0
              d[s++] = (L - (L - B) * t) | 0
              d[s++] = 255
            }
          }
        }
        function drawFigure(e, t, i) {
          const n = t.coords
          const s = t.colors
          let a
          let r
          switch (t.type) {
            case 'lattice':
              const o = t.verticesPerRow
              const l = Math.floor(n.length / o) - 1
              const c = o - 1
              for (a = 0; a < l; a++) {
                let t = a * o
                for (let a = 0; a < c; a++, t++) {
                  drawTriangle(e, i, n[t], n[t + 1], n[t + o], s[t], s[t + 1], s[t + o])
                  drawTriangle(
                    e,
                    i,
                    n[t + o + 1],
                    n[t + 1],
                    n[t + o],
                    s[t + o + 1],
                    s[t + 1],
                    s[t + o]
                  )
                }
              }
              break
            case 'triangles':
              for (a = 0, r = n.length; a < r; a += 3)
                drawTriangle(e, i, n[a], n[a + 1], n[a + 2], s[a], s[a + 1], s[a + 2])
              break
            default:
              throw new Error('illegal figure')
          }
        }
        class MeshShadingPattern extends BaseShadingPattern {
          constructor(e) {
            super()
            this._coords = e[2]
            this._colors = e[3]
            this._figures = e[4]
            this._bounds = e[5]
            this._bbox = e[7]
            this._background = e[8]
            this.matrix = null
          }

          _createMeshCanvas(e, t, i) {
            const n = Math.floor(this._bounds[0])
            const s = Math.floor(this._bounds[1])
            const a = Math.ceil(this._bounds[2]) - n
            const r = Math.ceil(this._bounds[3]) - s
            const o = Math.min(Math.ceil(Math.abs(a * e[0] * 1.1)), 3e3)
            const l = Math.min(Math.ceil(Math.abs(r * e[1] * 1.1)), 3e3)
            const c = a / o
            const d = r / l
            const h = {
              coords: this._coords,
              colors: this._colors,
              offsetX: -n,
              offsetY: -s,
              scaleX: 1 / c,
              scaleY: 1 / d
            }
            const u = o + 4
            const p = l + 4
            const g = i.getCanvas('mesh', u, p, !1)
            const f = g.context
            const m = f.createImageData(o, l)
            if (t) {
              const e = m.data
              for (let i = 0, n = e.length; i < n; i += 4) {
                e[i] = t[0]
                e[i + 1] = t[1]
                e[i + 2] = t[2]
                e[i + 3] = 255
              }
            }
            for (const e of this._figures) drawFigure(m, e, h)
            f.putImageData(m, 2, 2)
            return {
              canvas: g.canvas,
              offsetX: n - 2 * c,
              offsetY: s - 2 * d,
              scaleX: c,
              scaleY: d
            }
          }

          getPattern(e, t, i, a) {
            applyBoundingBox(e, this._bbox)
            let o
            if (a === r.SHADING)
              o = n.Util.singularValueDecompose2dScale((0, s.getCurrentTransform)(e))
            else {
              o = n.Util.singularValueDecompose2dScale(t.baseTransform)
              if (this.matrix) {
                const e = n.Util.singularValueDecompose2dScale(this.matrix)
                o = [o[0] * e[0], o[1] * e[1]]
              }
            }
            const l = this._createMeshCanvas(
              o,
              a === r.SHADING ? null : this._background,
              t.cachedCanvases
            )
            if (a !== r.SHADING) {
              e.setTransform(...t.baseTransform)
              this.matrix && e.transform(...this.matrix)
            }
            e.translate(l.offsetX, l.offsetY)
            e.scale(l.scaleX, l.scaleY)
            return e.createPattern(l.canvas, 'no-repeat')
          }
        }
        class DummyShadingPattern extends BaseShadingPattern {
          getPattern() {
            return 'hotpink'
          }
        }
        const o = 1
        const l = 2
        class TilingPattern {
          static get MAX_PATTERN_SIZE() {
            return (0, n.shadow)(this, 'MAX_PATTERN_SIZE', 3e3)
          }

          constructor(e, t, i, n, s) {
            this.operatorList = e[2]
            this.matrix = e[3] || [1, 0, 0, 1, 0, 0]
            this.bbox = e[4]
            this.xstep = e[5]
            this.ystep = e[6]
            this.paintType = e[7]
            this.tilingType = e[8]
            this.color = t
            this.ctx = i
            this.canvasGraphicsFactory = n
            this.baseTransform = s
          }

          createPatternCanvas(e) {
            const t = this.operatorList
            const i = this.bbox
            const a = this.xstep
            const r = this.ystep
            const o = this.paintType
            const l = this.tilingType
            const c = this.color
            const d = this.canvasGraphicsFactory
            ;(0, n.info)(`TilingType: ${l}`)
            const h = i[0]
            const u = i[1]
            const p = i[2]
            const g = i[3]
            const f = n.Util.singularValueDecompose2dScale(this.matrix)
            const m = n.Util.singularValueDecompose2dScale(this.baseTransform)
            const v = [f[0] * m[0], f[1] * m[1]]
            const _ = this.getSizeAndScale(a, this.ctx.canvas.width, v[0])
            const b = this.getSizeAndScale(r, this.ctx.canvas.height, v[1])
            const w = e.cachedCanvases.getCanvas('pattern', _.size, b.size, !0)
            const P = w.context
            const y = d.createCanvasGraphics(P)
            y.groupLevel = e.groupLevel
            this.setFillAndStrokeStyleToContext(y, o, c)
            let S = h
            let A = u
            let E = p
            let x = g
            if (h < 0) {
              S = 0
              E += Math.abs(h)
            }
            if (u < 0) {
              A = 0
              x += Math.abs(u)
            }
            P.translate(-_.scale * S, -b.scale * A)
            y.transform(_.scale, 0, 0, b.scale, 0, 0)
            P.save()
            this.clipBbox(y, S, A, E, x)
            y.baseTransform = (0, s.getCurrentTransform)(y.ctx)
            y.executeOperatorList(t)
            y.endDrawing()
            return { canvas: w.canvas, scaleX: _.scale, scaleY: b.scale, offsetX: S, offsetY: A }
          }

          getSizeAndScale(e, t, i) {
            e = Math.abs(e)
            const n = Math.max(TilingPattern.MAX_PATTERN_SIZE, t)
            let s = Math.ceil(e * i)
            s >= n ? (s = n) : (i = s / e)
            return { scale: i, size: s }
          }

          clipBbox(e, t, i, n, a) {
            const r = n - t
            const o = a - i
            e.ctx.rect(t, i, r, o)
            e.current.updateRectMinMax((0, s.getCurrentTransform)(e.ctx), [t, i, n, a])
            e.clip()
            e.endPath()
          }

          setFillAndStrokeStyleToContext(e, t, i) {
            const s = e.ctx
            const a = e.current
            switch (t) {
              case o:
                const e = this.ctx
                s.fillStyle = e.fillStyle
                s.strokeStyle = e.strokeStyle
                a.fillColor = e.fillStyle
                a.strokeColor = e.strokeStyle
                break
              case l:
                const r = n.Util.makeHexColor(i[0], i[1], i[2])
                s.fillStyle = r
                s.strokeStyle = r
                a.fillColor = r
                a.strokeColor = r
                break
              default:
                throw new n.FormatError(`Unsupported paint type: ${t}`)
            }
          }

          getPattern(e, t, i, s) {
            let a = i
            if (s !== r.SHADING) {
              a = n.Util.transform(a, t.baseTransform)
              this.matrix && (a = n.Util.transform(a, this.matrix))
            }
            const o = this.createPatternCanvas(t)
            let l = new DOMMatrix(a)
            l = l.translate(o.offsetX, o.offsetY)
            l = l.scale(1 / o.scaleX, 1 / o.scaleY)
            const c = e.createPattern(o.canvas, 'repeat')
            try {
              c.setTransform(l)
            } catch (e) {
              ;(0, n.warn)(`TilingPattern.getPattern: "${e == null ? void 0 : e.message}".`)
            }
            return c
          }
        }
        t.TilingPattern = TilingPattern
      },
      (e, t, i) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.applyMaskImageData = function applyMaskImageData(e) {
          let {
            src: t,
            srcPos: i = 0,
            dest: s,
            destPos: a = 0,
            width: r,
            height: o,
            inverseDecode: l = !1
          } = e
          const c = n.FeatureTest.isLittleEndian ? 4278190080 : 255
          const [d, h] = l ? [0, c] : [c, 0]
          const u = r >> 3
          const p = 7 & r
          const g = t.length
          s = new Uint32Array(s.buffer)
          for (let e = 0; e < o; e++) {
            for (const e = i + u; i < e; i++) {
              const e = i < g ? t[i] : 255
              s[a++] = 128 & e ? h : d
              s[a++] = 64 & e ? h : d
              s[a++] = 32 & e ? h : d
              s[a++] = 16 & e ? h : d
              s[a++] = 8 & e ? h : d
              s[a++] = 4 & e ? h : d
              s[a++] = 2 & e ? h : d
              s[a++] = 1 & e ? h : d
            }
            if (p === 0) continue
            const e = i < g ? t[i++] : 255
            for (let t = 0; t < p; t++) s[a++] = e & (1 << (7 - t)) ? h : d
          }
          return { srcPos: i, destPos: a }
        }
        var n = i(1)
      },
      (e, t, i) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        Object.defineProperty(t, 'GlobalSensWords', {
          enumerable: !0,
          get() {
            return s.GlobalSensWords
          }
        })
        t.filterSensitiveWords = function filterSensitiveWords(e, t) {
          const i = []
          const a = (function mergeTextChar(e, t, i) {
            for (var s = '', a = e.length, r = 0; r < a; ++r) {
              if (t[r] === n.OPS.showText)
                for (let o = e[r][0], l = 0; l < o.length; ++l)
                  if ((0, n.isNum)(o[l])) {
                    o[l] === -250 && (s += ' ')
                  } else {
                    s += o[l].unicode
                    recordCharPosition(i, r, l)
                  }
            }
            return s
          })(e, t, i)
          !(function replaceChar(e, t, i, n) {
            for (let a = s.GlobalSensWords.replaceChar, r = 0; r < e.length; ++r) {
              const o = getIndicesOf(e[r], t, !1)
              if (o.length != 0)
                for (let l = 0; l < o.length; ++l)
                  for (let c = o[l], d = 0; d < e[r].length; ++d) {
                    const h = i[c + d]
                    const u = jsonClone(n[h[0]])
                    u[h[1]][h[2]].fontChar = a
                    n[h[0]] = u
                  }
            }
          })(s.GlobalSensWords.sensitiveWords, a, i, e)
        }
        t.replaceSensitiveWord = function replaceSensitiveWord(e) {
          for (
            let t = s.GlobalSensWords.sensitiveWords, i = s.GlobalSensWords.replaceChar, n = 0;
            n < t.length;
            ++n
          ) {
            const a = t[n]
            if (getIndicesOf(a, e, !1).length != 0) {
              const r = i.repeat(a.length)
              const o = new RegExp(a, 'g')
              e = e.replace(o, r)
            }
          }
          return e
        }
        var n = i(1)
        var s = i(141)
        function recordCharPosition(e, t, i) {
          const n = []
          n.push(t)
          n.push(0)
          n.push(i)
          e.push(n)
        }
        function jsonClone(e) {
          return JSON.parse(JSON.stringify(e))
        }
        function getIndicesOf(e, t, i) {
          const n = e.length
          if (n === 0) return []
          let s
          let a = 0
          const r = []
          if (!i) {
            t = t.toLowerCase()
            e = e.toLowerCase()
          }
          for (; (s = t.indexOf(e, a)) > -1; ) {
            r.push(s)
            a = s + n
          }
          return r
        }
      },
      (e, t) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.GlobalSensWords = void 0
        const i = Object.create(null)
        t.GlobalSensWords = i
        i.sensitiveWords = void 0 === i.sensitiveWords ? [] : i.sensitiveWords
        i.replaceChar = void 0 === i.replaceChar ? '*' : i.replaceChar
      },
      (e, t) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.GlobalWorkerOptions = void 0
        const i = Object.create(null)
        t.GlobalWorkerOptions = i
        i.workerPort = void 0 === i.workerPort ? null : i.workerPort
        i.workerSrc = void 0 === i.workerSrc ? '' : i.workerSrc
      },
      (e, t, i) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.MessageHandler = void 0
        const n = i(1)
        const s = 1
        const a = 2
        const r = 1
        const o = 2
        const l = 3
        const c = 4
        const d = 5
        const h = 6
        const u = 7
        const p = 8
        function wrapReason(e) {
          e instanceof Error ||
            (typeof e === 'object' && e !== null) ||
            (0, n.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.')
          switch (e.name) {
            case 'AbortException':
              return new n.AbortException(e.message)
            case 'MissingPDFException':
              return new n.MissingPDFException(e.message)
            case 'PasswordException':
              return new n.PasswordException(e.message, e.code)
            case 'UnexpectedResponseException':
              return new n.UnexpectedResponseException(e.message, e.status)
            case 'UnknownErrorException':
              return new n.UnknownErrorException(e.message, e.details)
            default:
              return new n.UnknownErrorException(e.message, e.toString())
          }
        }
        t.MessageHandler = class MessageHandler {
          constructor(e, t, i) {
            this.sourceName = e
            this.targetName = t
            this.comObj = i
            this.callbackId = 1
            this.streamId = 1
            this.streamSinks = Object.create(null)
            this.streamControllers = Object.create(null)
            this.callbackCapabilities = Object.create(null)
            this.actionHandler = Object.create(null)
            this._onComObjOnMessage = (e) => {
              const t = e.data
              if (t.targetName !== this.sourceName) return
              if (t.stream) {
                this._processStreamMessage(t)
                return
              }
              if (t.callback) {
                const e = t.callbackId
                const i = this.callbackCapabilities[e]
                if (!i) throw new Error(`Cannot resolve callback ${e}`)
                delete this.callbackCapabilities[e]
                if (t.callback === s) i.resolve(t.data)
                else {
                  if (t.callback !== a) throw new Error('Unexpected callback case')
                  i.reject(wrapReason(t.reason))
                }
                return
              }
              const n = this.actionHandler[t.action]
              if (!n) throw new Error(`Unknown action from worker: ${t.action}`)
              if (t.callbackId) {
                const e = this.sourceName
                const r = t.sourceName
                new Promise(function (e) {
                  e(n(t.data))
                }).then(
                  function (n) {
                    i.postMessage({
                      sourceName: e,
                      targetName: r,
                      callback: s,
                      callbackId: t.callbackId,
                      data: n
                    })
                  },
                  function (n) {
                    i.postMessage({
                      sourceName: e,
                      targetName: r,
                      callback: a,
                      callbackId: t.callbackId,
                      reason: wrapReason(n)
                    })
                  }
                )
              } else t.streamId ? this._createStreamSink(t) : n(t.data)
            }
            i.addEventListener('message', this._onComObjOnMessage)
          }

          on(e, t) {
            const i = this.actionHandler
            if (i[e]) throw new Error(`There is already an actionName called "${e}"`)
            i[e] = t
          }

          send(e, t, i) {
            this.comObj.postMessage(
              { sourceName: this.sourceName, targetName: this.targetName, action: e, data: t },
              i
            )
          }

          sendWithPromise(e, t, i) {
            const s = this.callbackId++
            const a = (0, n.createPromiseCapability)()
            this.callbackCapabilities[s] = a
            try {
              this.comObj.postMessage(
                {
                  sourceName: this.sourceName,
                  targetName: this.targetName,
                  action: e,
                  callbackId: s,
                  data: t
                },
                i
              )
            } catch (e) {
              a.reject(e)
            }
            return a.promise
          }

          sendWithStream(e, t, i, s) {
            const a = this.streamId++
            const o = this.sourceName
            const l = this.targetName
            const c = this.comObj
            return new ReadableStream(
              {
                start: (i) => {
                  const r = (0, n.createPromiseCapability)()
                  this.streamControllers[a] = {
                    controller: i,
                    startCall: r,
                    pullCall: null,
                    cancelCall: null,
                    isClosed: !1
                  }
                  c.postMessage(
                    {
                      sourceName: o,
                      targetName: l,
                      action: e,
                      streamId: a,
                      data: t,
                      desiredSize: i.desiredSize
                    },
                    s
                  )
                  return r.promise
                },
                pull: (e) => {
                  const t = (0, n.createPromiseCapability)()
                  this.streamControllers[a].pullCall = t
                  c.postMessage({
                    sourceName: o,
                    targetName: l,
                    stream: h,
                    streamId: a,
                    desiredSize: e.desiredSize
                  })
                  return t.promise
                },
                cancel: (e) => {
                  ;(0, n.assert)(e instanceof Error, 'cancel must have a valid reason')
                  const t = (0, n.createPromiseCapability)()
                  this.streamControllers[a].cancelCall = t
                  this.streamControllers[a].isClosed = !0
                  c.postMessage({
                    sourceName: o,
                    targetName: l,
                    stream: r,
                    streamId: a,
                    reason: wrapReason(e)
                  })
                  return t.promise
                }
              },
              i
            )
          }

          _createStreamSink(e) {
            const t = e.streamId
            const i = this.sourceName
            const s = e.sourceName
            const a = this.comObj
            const r = this
            const o = this.actionHandler[e.action]
            const h = {
              enqueue(e) {
                const r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1
                const o = arguments.length > 2 ? arguments[2] : void 0
                if (this.isCancelled) return
                const l = this.desiredSize
                this.desiredSize -= r
                if (l > 0 && this.desiredSize <= 0) {
                  this.sinkCapability = (0, n.createPromiseCapability)()
                  this.ready = this.sinkCapability.promise
                }
                a.postMessage({ sourceName: i, targetName: s, stream: c, streamId: t, chunk: e }, o)
              },
              close() {
                if (!this.isCancelled) {
                  this.isCancelled = !0
                  a.postMessage({ sourceName: i, targetName: s, stream: l, streamId: t })
                  delete r.streamSinks[t]
                }
              },
              error(e) {
                ;(0, n.assert)(e instanceof Error, 'error must have a valid reason')
                if (!this.isCancelled) {
                  this.isCancelled = !0
                  a.postMessage({
                    sourceName: i,
                    targetName: s,
                    stream: d,
                    streamId: t,
                    reason: wrapReason(e)
                  })
                }
              },
              sinkCapability: (0, n.createPromiseCapability)(),
              onPull: null,
              onCancel: null,
              isCancelled: !1,
              desiredSize: e.desiredSize,
              ready: null
            }
            h.sinkCapability.resolve()
            h.ready = h.sinkCapability.promise
            this.streamSinks[t] = h
            new Promise(function (t) {
              t(o(e.data, h))
            }).then(
              function () {
                a.postMessage({
                  sourceName: i,
                  targetName: s,
                  stream: p,
                  streamId: t,
                  success: !0
                })
              },
              function (e) {
                a.postMessage({
                  sourceName: i,
                  targetName: s,
                  stream: p,
                  streamId: t,
                  reason: wrapReason(e)
                })
              }
            )
          }

          _processStreamMessage(e) {
            const t = e.streamId
            const i = this.sourceName
            const s = e.sourceName
            const a = this.comObj
            const g = this.streamControllers[t]
            const f = this.streamSinks[t]
            switch (e.stream) {
              case p:
                e.success ? g.startCall.resolve() : g.startCall.reject(wrapReason(e.reason))
                break
              case u:
                e.success ? g.pullCall.resolve() : g.pullCall.reject(wrapReason(e.reason))
                break
              case h:
                if (!f) {
                  a.postMessage({
                    sourceName: i,
                    targetName: s,
                    stream: u,
                    streamId: t,
                    success: !0
                  })
                  break
                }
                f.desiredSize <= 0 && e.desiredSize > 0 && f.sinkCapability.resolve()
                f.desiredSize = e.desiredSize
                new Promise(function (e) {
                  e(f.onPull && f.onPull())
                }).then(
                  function () {
                    a.postMessage({
                      sourceName: i,
                      targetName: s,
                      stream: u,
                      streamId: t,
                      success: !0
                    })
                  },
                  function (e) {
                    a.postMessage({
                      sourceName: i,
                      targetName: s,
                      stream: u,
                      streamId: t,
                      reason: wrapReason(e)
                    })
                  }
                )
                break
              case c:
                ;(0, n.assert)(g, 'enqueue should have stream controller')
                if (g.isClosed) break
                g.controller.enqueue(e.chunk)
                break
              case l:
                ;(0, n.assert)(g, 'close should have stream controller')
                if (g.isClosed) break
                g.isClosed = !0
                g.controller.close()
                this._deleteStreamController(g, t)
                break
              case d:
                ;(0, n.assert)(g, 'error should have stream controller')
                g.controller.error(wrapReason(e.reason))
                this._deleteStreamController(g, t)
                break
              case o:
                e.success ? g.cancelCall.resolve() : g.cancelCall.reject(wrapReason(e.reason))
                this._deleteStreamController(g, t)
                break
              case r:
                if (!f) break
                new Promise(function (t) {
                  t(f.onCancel && f.onCancel(wrapReason(e.reason)))
                }).then(
                  function () {
                    a.postMessage({
                      sourceName: i,
                      targetName: s,
                      stream: o,
                      streamId: t,
                      success: !0
                    })
                  },
                  function (e) {
                    a.postMessage({
                      sourceName: i,
                      targetName: s,
                      stream: o,
                      streamId: t,
                      reason: wrapReason(e)
                    })
                  }
                )
                f.sinkCapability.reject(wrapReason(e.reason))
                f.isCancelled = !0
                delete this.streamSinks[t]
                break
              default:
                throw new Error('Unexpected stream case')
            }
          }

          async _deleteStreamController(e, t) {
            await Promise.allSettled([
              e.startCall && e.startCall.promise,
              e.pullCall && e.pullCall.promise,
              e.cancelCall && e.cancelCall.promise
            ])
            delete this.streamControllers[t]
          }

          destroy() {
            this.comObj.removeEventListener('message', this._onComObjOnMessage)
          }
        }
      },
      (e, t, i) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.Metadata = void 0
        const n = i(1)
        function _classPrivateFieldInitSpec(e, t, i) {
          !(function _checkPrivateRedeclaration(e, t) {
            if (t.has(e))
              throw new TypeError('Cannot initialize the same private elements twice on an object')
          })(e, t)
          t.set(e, i)
        }
        function _classPrivateFieldGet(e, t) {
          return (function _classApplyDescriptorGet(e, t) {
            if (t.get) return t.get.call(e)
            return t.value
          })(e, _classExtractFieldDescriptor(e, t, 'get'))
        }
        function _classPrivateFieldSet(e, t, i) {
          !(function _classApplyDescriptorSet(e, t, i) {
            if (t.set) t.set.call(e, i)
            else {
              if (!t.writable) throw new TypeError('attempted to set read only private field')
              t.value = i
            }
          })(e, _classExtractFieldDescriptor(e, t, 'set'), i)
          return i
        }
        function _classExtractFieldDescriptor(e, t, i) {
          if (!t.has(e)) throw new TypeError(`attempted to ${i} private field on non-instance`)
          return t.get(e)
        }
        const s = new WeakMap()
        const a = new WeakMap()
        t.Metadata = class Metadata {
          constructor(e) {
            const { parsedData: t, rawData: i } = e
            _classPrivateFieldInitSpec(this, s, { writable: !0, value: void 0 })
            _classPrivateFieldInitSpec(this, a, { writable: !0, value: void 0 })
            _classPrivateFieldSet(this, s, t)
            _classPrivateFieldSet(this, a, i)
          }

          getRaw() {
            return _classPrivateFieldGet(this, a)
          }

          get(e) {
            let t
            return (t = _classPrivateFieldGet(this, s).get(e)) !== null && void 0 !== t ? t : null
          }

          getAll() {
            return (0, n.objectFromMap)(_classPrivateFieldGet(this, s))
          }

          has(e) {
            return _classPrivateFieldGet(this, s).has(e)
          }
        }
      },
      (e, t, i) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.OptionalContentConfig = void 0
        const n = i(1)
        function _classPrivateMethodGet(e, t, i) {
          if (!t.has(e)) throw new TypeError('attempted to get private field on non-instance')
          return i
        }
        function _classPrivateFieldInitSpec(e, t, i) {
          _checkPrivateRedeclaration(e, t)
          t.set(e, i)
        }
        function _checkPrivateRedeclaration(e, t) {
          if (t.has(e))
            throw new TypeError('Cannot initialize the same private elements twice on an object')
        }
        function _classPrivateFieldSet(e, t, i) {
          !(function _classApplyDescriptorSet(e, t, i) {
            if (t.set) t.set.call(e, i)
            else {
              if (!t.writable) throw new TypeError('attempted to set read only private field')
              t.value = i
            }
          })(e, _classExtractFieldDescriptor(e, t, 'set'), i)
          return i
        }
        function _classPrivateFieldGet(e, t) {
          return (function _classApplyDescriptorGet(e, t) {
            if (t.get) return t.get.call(e)
            return t.value
          })(e, _classExtractFieldDescriptor(e, t, 'get'))
        }
        function _classExtractFieldDescriptor(e, t, i) {
          if (!t.has(e)) throw new TypeError(`attempted to ${i} private field on non-instance`)
          return t.get(e)
        }
        const s = Symbol('INTERNAL')
        const a = new WeakMap()
        class OptionalContentGroup {
          constructor(e, t) {
            _classPrivateFieldInitSpec(this, a, { writable: !0, value: !0 })
            this.name = e
            this.intent = t
          }

          get visible() {
            return _classPrivateFieldGet(this, a)
          }

          _setVisible(e, t) {
            e !== s && (0, n.unreachable)('Internal method `_setVisible` called.')
            _classPrivateFieldSet(this, a, t)
          }
        }
        const r = new WeakMap()
        const o = new WeakMap()
        const l = new WeakMap()
        const c = new WeakMap()
        const d = new WeakSet()
        t.OptionalContentConfig = class OptionalContentConfig {
          constructor(e) {
            !(function _classPrivateMethodInitSpec(e, t) {
              _checkPrivateRedeclaration(e, t)
              t.add(e)
            })(this, d)
            _classPrivateFieldInitSpec(this, r, { writable: !0, value: !0 })
            _classPrivateFieldInitSpec(this, o, { writable: !0, value: new Map() })
            _classPrivateFieldInitSpec(this, l, { writable: !0, value: null })
            _classPrivateFieldInitSpec(this, c, { writable: !0, value: null })
            this.name = null
            this.creator = null
            if (e !== null) {
              this.name = e.name
              this.creator = e.creator
              _classPrivateFieldSet(this, c, e.order)
              for (const t of e.groups)
                _classPrivateFieldGet(this, o).set(t.id, new OptionalContentGroup(t.name, t.intent))
              if (e.baseState === 'OFF')
                for (const e of _classPrivateFieldGet(this, o).values()) e._setVisible(s, !1)
              for (const t of e.on) _classPrivateFieldGet(this, o).get(t)._setVisible(s, !0)
              for (const t of e.off) _classPrivateFieldGet(this, o).get(t)._setVisible(s, !1)
              _classPrivateFieldSet(this, l, new Map())
              for (const [e, t] of _classPrivateFieldGet(this, o))
                _classPrivateFieldGet(this, l).set(e, t.visible)
            }
          }

          isVisible(e) {
            if (_classPrivateFieldGet(this, o).size === 0) return !0
            if (!e) {
              ;(0, n.warn)('Optional content group not defined.')
              return !0
            }
            if (e.type === 'OCG') {
              if (!_classPrivateFieldGet(this, o).has(e.id)) {
                ;(0, n.warn)(`Optional content group not found: ${e.id}`)
                return !0
              }
              return _classPrivateFieldGet(this, o).get(e.id).visible
            }
            if (e.type === 'OCMD') {
              if (e.expression)
                return _classPrivateMethodGet(this, d, _evaluateVisibilityExpression2).call(
                  this,
                  e.expression
                )
              if (!e.policy || e.policy === 'AnyOn') {
                for (const t of e.ids) {
                  if (!_classPrivateFieldGet(this, o).has(t)) {
                    ;(0, n.warn)(`Optional content group not found: ${t}`)
                    return !0
                  }
                  if (_classPrivateFieldGet(this, o).get(t).visible) return !0
                }
                return !1
              }
              if (e.policy === 'AllOn') {
                for (const t of e.ids) {
                  if (!_classPrivateFieldGet(this, o).has(t)) {
                    ;(0, n.warn)(`Optional content group not found: ${t}`)
                    return !0
                  }
                  if (!_classPrivateFieldGet(this, o).get(t).visible) return !1
                }
                return !0
              }
              if (e.policy === 'AnyOff') {
                for (const t of e.ids) {
                  if (!_classPrivateFieldGet(this, o).has(t)) {
                    ;(0, n.warn)(`Optional content group not found: ${t}`)
                    return !0
                  }
                  if (!_classPrivateFieldGet(this, o).get(t).visible) return !0
                }
                return !1
              }
              if (e.policy === 'AllOff') {
                for (const t of e.ids) {
                  if (!_classPrivateFieldGet(this, o).has(t)) {
                    ;(0, n.warn)(`Optional content group not found: ${t}`)
                    return !0
                  }
                  if (_classPrivateFieldGet(this, o).get(t).visible) return !1
                }
                return !0
              }
              ;(0, n.warn)(`Unknown optional content policy ${e.policy}.`)
              return !0
            }
            ;(0, n.warn)(`Unknown group type ${e.type}.`)
            return !0
          }

          setVisibility(e) {
            const t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
            if (_classPrivateFieldGet(this, o).has(e)) {
              _classPrivateFieldGet(this, o).get(e)._setVisible(s, !!t)
              _classPrivateFieldSet(this, r, null)
            } else (0, n.warn)(`Optional content group not found: ${e}`)
          }

          get hasInitialVisibility() {
            if (_classPrivateFieldGet(this, r) !== null) return _classPrivateFieldGet(this, r)
            for (const [e, t] of _classPrivateFieldGet(this, o)) {
              const i = _classPrivateFieldGet(this, l).get(e)
              if (t.visible !== i) return _classPrivateFieldSet(this, r, !1)
            }
            return _classPrivateFieldSet(this, r, !0)
          }

          getOrder() {
            return _classPrivateFieldGet(this, o).size
              ? _classPrivateFieldGet(this, c)
                ? _classPrivateFieldGet(this, c).slice()
                : [..._classPrivateFieldGet(this, o).keys()]
              : null
          }

          getGroups() {
            return _classPrivateFieldGet(this, o).size > 0
              ? (0, n.objectFromMap)(_classPrivateFieldGet(this, o))
              : null
          }

          getGroup(e) {
            return _classPrivateFieldGet(this, o).get(e) || null
          }
        }
        function _evaluateVisibilityExpression2(e) {
          const t = e.length
          if (t < 2) return !0
          const i = e[0]
          for (let s = 1; s < t; s++) {
            const t = e[s]
            let a
            if (Array.isArray(t))
              a = _classPrivateMethodGet(this, d, _evaluateVisibilityExpression2).call(this, t)
            else {
              if (!_classPrivateFieldGet(this, o).has(t)) {
                ;(0, n.warn)(`Optional content group not found: ${t}`)
                return !0
              }
              a = _classPrivateFieldGet(this, o).get(t).visible
            }
            switch (i) {
              case 'And':
                if (!a) return !1
                break
              case 'Or':
                if (a) return !0
                break
              case 'Not':
                return !a
              default:
                return !0
            }
          }
          return i === 'And'
        }
      },
      (e, t, i) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.PDFDataTransportStream = void 0
        const n = i(1)
        const s = i(133)
        t.PDFDataTransportStream = class PDFDataTransportStream {
          constructor(e, t) {
            ;(0, n.assert)(
              t,
              'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.'
            )
            this._queuedChunks = []
            this._progressiveDone = e.progressiveDone || !1
            this._contentDispositionFilename = e.contentDispositionFilename || null
            const i = e.initialData
            if ((i == null ? void 0 : i.length) > 0) {
              const e = new Uint8Array(i).buffer
              this._queuedChunks.push(e)
            }
            this._pdfDataRangeTransport = t
            this._isStreamingSupported = !e.disableStream
            this._isRangeSupported = !e.disableRange
            this._contentLength = e.length
            this._fullRequestReader = null
            this._rangeReaders = []
            this._pdfDataRangeTransport.addRangeListener((e, t) => {
              this._onReceiveData({ begin: e, chunk: t })
            })
            this._pdfDataRangeTransport.addProgressListener((e, t) => {
              this._onProgress({ loaded: e, total: t })
            })
            this._pdfDataRangeTransport.addProgressiveReadListener((e) => {
              this._onReceiveData({ chunk: e })
            })
            this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
              this._onProgressiveDone()
            })
            this._pdfDataRangeTransport.transportReady()
          }

          _onReceiveData(e) {
            const t = new Uint8Array(e.chunk).buffer
            if (void 0 === e.begin)
              this._fullRequestReader
                ? this._fullRequestReader._enqueue(t)
                : this._queuedChunks.push(t)
            else {
              const i = this._rangeReaders.some(function (i) {
                if (i._begin !== e.begin) return !1
                i._enqueue(t)
                return !0
              })
              ;(0, n.assert)(
                i,
                '_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.'
              )
            }
          }

          get _progressiveDataLength() {
            let e
            let t
            return (e =
              (t = this._fullRequestReader) === null || void 0 === t ? void 0 : t._loaded) !==
              null && void 0 !== e
              ? e
              : 0
          }

          _onProgress(e) {
            if (void 0 === e.total) {
              const t = this._rangeReaders[0]
              t != null && t.onProgress && t.onProgress({ loaded: e.loaded })
            } else {
              const t = this._fullRequestReader
              t != null && t.onProgress && t.onProgress({ loaded: e.loaded, total: e.total })
            }
          }

          _onProgressiveDone() {
            this._fullRequestReader && this._fullRequestReader.progressiveDone()
            this._progressiveDone = !0
          }

          _removeRangeReader(e) {
            const t = this._rangeReaders.indexOf(e)
            t >= 0 && this._rangeReaders.splice(t, 1)
          }

          getFullReader() {
            ;(0, n.assert)(
              !this._fullRequestReader,
              'PDFDataTransportStream.getFullReader can only be called once.'
            )
            const e = this._queuedChunks
            this._queuedChunks = null
            return new PDFDataTransportStreamReader(
              this,
              e,
              this._progressiveDone,
              this._contentDispositionFilename
            )
          }

          getRangeReader(e, t) {
            if (t <= this._progressiveDataLength) return null
            const i = new PDFDataTransportStreamRangeReader(this, e, t)
            this._pdfDataRangeTransport.requestDataRange(e, t)
            this._rangeReaders.push(i)
            return i
          }

          cancelAllRequests(e) {
            this._fullRequestReader && this._fullRequestReader.cancel(e)
            for (const t of this._rangeReaders.slice(0)) t.cancel(e)
            this._pdfDataRangeTransport.abort()
          }
        }
        class PDFDataTransportStreamReader {
          constructor(e, t) {
            const i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
            const n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null
            this._stream = e
            this._done = i || !1
            this._filename = (0, s.isPdfFile)(n) ? n : null
            this._queuedChunks = t || []
            this._loaded = 0
            for (const e of this._queuedChunks) this._loaded += e.byteLength
            this._requests = []
            this._headersReady = Promise.resolve()
            e._fullRequestReader = this
            this.onProgress = null
          }

          _enqueue(e) {
            if (!this._done) {
              if (this._requests.length > 0) {
                this._requests.shift().resolve({ value: e, done: !1 })
              } else this._queuedChunks.push(e)
              this._loaded += e.byteLength
            }
          }

          get headersReady() {
            return this._headersReady
          }

          get filename() {
            return this._filename
          }

          get isRangeSupported() {
            return this._stream._isRangeSupported
          }

          get isStreamingSupported() {
            return this._stream._isStreamingSupported
          }

          get contentLength() {
            return this._stream._contentLength
          }

          async read() {
            if (this._queuedChunks.length > 0) {
              return { value: this._queuedChunks.shift(), done: !1 }
            }
            if (this._done) return { value: void 0, done: !0 }
            const e = (0, n.createPromiseCapability)()
            this._requests.push(e)
            return e.promise
          }

          cancel(e) {
            this._done = !0
            for (const e of this._requests) e.resolve({ value: void 0, done: !0 })
            this._requests.length = 0
          }

          progressiveDone() {
            this._done || (this._done = !0)
          }
        }
        class PDFDataTransportStreamRangeReader {
          constructor(e, t, i) {
            this._stream = e
            this._begin = t
            this._end = i
            this._queuedChunk = null
            this._requests = []
            this._done = !1
            this.onProgress = null
          }

          _enqueue(e) {
            if (!this._done) {
              if (this._requests.length === 0) this._queuedChunk = e
              else {
                this._requests.shift().resolve({ value: e, done: !1 })
                for (const e of this._requests) e.resolve({ value: void 0, done: !0 })
                this._requests.length = 0
              }
              this._done = !0
              this._stream._removeRangeReader(this)
            }
          }

          get isStreamingSupported() {
            return !1
          }

          async read() {
            if (this._queuedChunk) {
              const e = this._queuedChunk
              this._queuedChunk = null
              return { value: e, done: !1 }
            }
            if (this._done) return { value: void 0, done: !0 }
            const e = (0, n.createPromiseCapability)()
            this._requests.push(e)
            return e.promise
          }

          cancel(e) {
            this._done = !0
            for (const e of this._requests) e.resolve({ value: void 0, done: !0 })
            this._requests.length = 0
            this._stream._removeRangeReader(this)
          }
        }
      },
      (e, t) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.XfaText = void 0
        class XfaText {
          static textContent(e) {
            const t = []
            const i = { items: t, styles: Object.create(null) }
            !(function walk(e) {
              let i
              if (!e) return
              let n = null
              const s = e.name
              if (s === '#text') n = e.value
              else {
                if (!XfaText.shouldBuildText(s)) return
                e != null && (i = e.attributes) !== null && void 0 !== i && i.textContent
                  ? (n = e.attributes.textContent)
                  : e.value && (n = e.value)
              }
              n !== null && t.push({ str: n })
              if (e.children) for (const t of e.children) walk(t)
            })(e)
            return i
          }

          static shouldBuildText(e) {
            return !(e === 'textarea' || e === 'input' || e === 'option' || e === 'select')
          }
        }
        t.XfaText = XfaText
      },
      (e, t, i) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.NodeStandardFontDataFactory = t.NodeCanvasFactory = t.NodeCMapReaderFactory = void 0
        const n = i(134)
        const fetchData = function (e) {
          return new Promise((t, i) => {
            require('fs').readFile(e, (e, n) => {
              !e && n ? t(new Uint8Array(n)) : i(new Error(e))
            })
          })
        }
        class NodeCanvasFactory extends n.BaseCanvasFactory {
          _createCanvas(e, t) {
            return require('canvas').createCanvas(e, t)
          }
        }
        t.NodeCanvasFactory = NodeCanvasFactory
        class NodeCMapReaderFactory extends n.BaseCMapReaderFactory {
          _fetchData(e, t) {
            return fetchData(e).then((e) => ({ cMapData: e, compressionType: t }))
          }
        }
        t.NodeCMapReaderFactory = NodeCMapReaderFactory
        class NodeStandardFontDataFactory extends n.BaseStandardFontDataFactory {
          _fetchData(e) {
            return fetchData(e)
          }
        }
        t.NodeStandardFontDataFactory = NodeStandardFontDataFactory
      },
      (e, t, i) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.AnnotationEditorLayer = void 0
        const n = i(132)
        const s = i(1)
        const a = i(150)
        const r = i(151)
        function _classPrivateMethodInitSpec(e, t) {
          _checkPrivateRedeclaration(e, t)
          t.add(e)
        }
        function _classPrivateFieldInitSpec(e, t, i) {
          _checkPrivateRedeclaration(e, t)
          t.set(e, i)
        }
        function _checkPrivateRedeclaration(e, t) {
          if (t.has(e))
            throw new TypeError('Cannot initialize the same private elements twice on an object')
        }
        function _classPrivateMethodGet(e, t, i) {
          if (!t.has(e)) throw new TypeError('attempted to get private field on non-instance')
          return i
        }
        function _classPrivateFieldGet(e, t) {
          return (function _classApplyDescriptorGet(e, t) {
            if (t.get) return t.get.call(e)
            return t.value
          })(e, _classExtractFieldDescriptor(e, t, 'get'))
        }
        function _classPrivateFieldSet(e, t, i) {
          !(function _classApplyDescriptorSet(e, t, i) {
            if (t.set) t.set.call(e, i)
            else {
              if (!t.writable) throw new TypeError('attempted to set read only private field')
              t.value = i
            }
          })(e, _classExtractFieldDescriptor(e, t, 'set'), i)
          return i
        }
        function _classExtractFieldDescriptor(e, t, i) {
          if (!t.has(e)) throw new TypeError(`attempted to ${i} private field on non-instance`)
          return t.get(e)
        }
        const o = new WeakMap()
        const l = new WeakMap()
        const c = new WeakMap()
        const d = new WeakMap()
        const h = new WeakMap()
        const u = new WeakMap()
        const p = new WeakMap()
        const g = new WeakMap()
        const f = new WeakSet()
        const m = new WeakSet()
        const v = new WeakSet()
        const _ = new WeakSet()
        class AnnotationEditorLayer {
          constructor(e) {
            _classPrivateMethodInitSpec(this, _)
            _classPrivateMethodInitSpec(this, v)
            _classPrivateMethodInitSpec(this, m)
            _classPrivateMethodInitSpec(this, f)
            _classPrivateFieldInitSpec(this, o, { writable: !0, value: void 0 })
            _classPrivateFieldInitSpec(this, l, { writable: !0, value: !1 })
            _classPrivateFieldInitSpec(this, c, {
              writable: !0,
              value: this.pointerup.bind(this)
            })
            _classPrivateFieldInitSpec(this, d, {
              writable: !0,
              value: this.pointerdown.bind(this)
            })
            _classPrivateFieldInitSpec(this, h, { writable: !0, value: new Map() })
            _classPrivateFieldInitSpec(this, u, { writable: !0, value: !1 })
            _classPrivateFieldInitSpec(this, p, { writable: !0, value: !1 })
            _classPrivateFieldInitSpec(this, g, { writable: !0, value: void 0 })
            if (!AnnotationEditorLayer._initialized) {
              AnnotationEditorLayer._initialized = !0
              a.FreeTextEditor.initialize(e.l10n)
              r.InkEditor.initialize(e.l10n)
              e.uiManager.registerEditorTypes([a.FreeTextEditor, r.InkEditor])
            }
            _classPrivateFieldSet(this, g, e.uiManager)
            this.annotationStorage = e.annotationStorage
            this.pageIndex = e.pageIndex
            this.div = e.div
            _classPrivateFieldSet(this, o, e.accessibilityManager)
            _classPrivateFieldGet(this, g).addLayer(this)
          }

          updateToolbar(e) {
            _classPrivateFieldGet(this, g).updateToolbar(e)
          }

          updateMode() {
            const e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : _classPrivateFieldGet(this, g).getMode()
            _classPrivateMethodGet(this, _, _cleanup2).call(this)
            if (e === s.AnnotationEditorType.INK) {
              this.addInkEditorIfNeeded(!1)
              this.disableClick()
            } else this.enableClick()
            _classPrivateFieldGet(this, g).unselectAll()
          }

          addInkEditorIfNeeded(e) {
            if (!e && _classPrivateFieldGet(this, g).getMode() !== s.AnnotationEditorType.INK)
              return
            if (!e)
              for (const e of _classPrivateFieldGet(this, h).values())
                if (e.isEmpty()) {
                  e.setInBackground()
                  return
                }
            _classPrivateMethodGet(this, v, _createAndAddNewEditor2)
              .call(this, { offsetX: 0, offsetY: 0 })
              .setInBackground()
          }

          setEditingState(e) {
            _classPrivateFieldGet(this, g).setEditingState(e)
          }

          addCommands(e) {
            _classPrivateFieldGet(this, g).addCommands(e)
          }

          enable() {
            this.div.style.pointerEvents = 'auto'
            for (const e of _classPrivateFieldGet(this, h).values()) e.enableEditing()
          }

          disable() {
            this.div.style.pointerEvents = 'none'
            for (const e of _classPrivateFieldGet(this, h).values()) e.disableEditing()
          }

          setActiveEditor(e) {
            _classPrivateFieldGet(this, g).getActive() !== e &&
              _classPrivateFieldGet(this, g).setActiveEditor(e)
          }

          enableClick() {
            this.div.addEventListener('pointerdown', _classPrivateFieldGet(this, d))
            this.div.addEventListener('pointerup', _classPrivateFieldGet(this, c))
          }

          disableClick() {
            this.div.removeEventListener('pointerdown', _classPrivateFieldGet(this, d))
            this.div.removeEventListener('pointerup', _classPrivateFieldGet(this, c))
          }

          attach(e) {
            _classPrivateFieldGet(this, h).set(e.id, e)
          }

          detach(e) {
            let t
            _classPrivateFieldGet(this, h).delete(e.id)((t = _classPrivateFieldGet(this, o))) ===
              null ||
              void 0 === t ||
              t.removePointerInTextLayer(e.contentDiv)
          }

          remove(e) {
            _classPrivateFieldGet(this, g).removeEditor(e)
            this.detach(e)
            this.annotationStorage.remove(e.id)
            e.div.style.display = 'none'
            setTimeout(() => {
              e.div.style.display = ''
              e.div.remove()
              e.isAttachedToDOM = !1
              document.activeElement === document.body &&
                _classPrivateFieldGet(this, g).focusMainContainer()
            }, 0)
            _classPrivateFieldGet(this, p) || this.addInkEditorIfNeeded(!1)
          }

          add(e) {
            _classPrivateMethodGet(this, f, _changeParent2).call(this, e)
            _classPrivateFieldGet(this, g).addEditor(e)
            this.attach(e)
            if (!e.isAttachedToDOM) {
              const t = e.render()
              this.div.append(t)
              e.isAttachedToDOM = !0
            }
            this.moveEditorInDOM(e)
            e.onceAdded()
            this.addToAnnotationStorage(e)
          }

          moveEditorInDOM(e) {
            let t
            ;(t = _classPrivateFieldGet(this, o)) === null ||
              void 0 === t ||
              t.moveElementInDOM(this.div, e.div, e.contentDiv, !0)
          }

          addToAnnotationStorage(e) {
            e.isEmpty() ||
              this.annotationStorage.has(e.id) ||
              this.annotationStorage.setValue(e.id, e)
          }

          addOrRebuild(e) {
            e.needsToBeRebuilt() ? e.rebuild() : this.add(e)
          }

          addANewEditor(e) {
            this.addCommands({
              cmd: () => {
                this.addOrRebuild(e)
              },
              undo: () => {
                e.remove()
              },
              mustExec: !0
            })
          }

          addUndoableEditor(e) {
            this.addCommands({
              cmd: () => {
                this.addOrRebuild(e)
              },
              undo: () => {
                e.remove()
              },
              mustExec: !1
            })
          }

          getNextId() {
            return _classPrivateFieldGet(this, g).getId()
          }

          deserialize(e) {
            switch (e.annotationType) {
              case s.AnnotationEditorType.FREETEXT:
                return a.FreeTextEditor.deserialize(e, this)
              case s.AnnotationEditorType.INK:
                return r.InkEditor.deserialize(e, this)
            }
            return null
          }

          setSelected(e) {
            _classPrivateFieldGet(this, g).setSelected(e)
          }

          toggleSelected(e) {
            _classPrivateFieldGet(this, g).toggleSelected(e)
          }

          isSelected(e) {
            return _classPrivateFieldGet(this, g).isSelected(e)
          }

          unselect(e) {
            _classPrivateFieldGet(this, g).unselect(e)
          }

          pointerup(e) {
            const t = n.KeyboardManager.platform.isMac
            if (
              !(e.button !== 0 || (e.ctrlKey && t)) &&
              e.target === this.div &&
              _classPrivateFieldGet(this, u)
            ) {
              _classPrivateFieldSet(this, u, !1)
              _classPrivateFieldGet(this, l)
                ? _classPrivateMethodGet(this, v, _createAndAddNewEditor2).call(this, e)
                : _classPrivateFieldSet(this, l, !0)
            }
          }

          pointerdown(e) {
            const t = n.KeyboardManager.platform.isMac
            if (e.button !== 0 || (e.ctrlKey && t)) return
            if (e.target !== this.div) return
            _classPrivateFieldSet(this, u, !0)
            const i = _classPrivateFieldGet(this, g).getActive()
            _classPrivateFieldSet(this, l, !i || i.isEmpty())
          }

          drop(e) {
            const t = e.dataTransfer.getData('text/plain')
            const i = _classPrivateFieldGet(this, g).getEditor(t)
            if (!i) return
            e.preventDefault()
            e.dataTransfer.dropEffect = 'move'
            _classPrivateMethodGet(this, f, _changeParent2).call(this, i)
            const n = this.div.getBoundingClientRect()
            const s = e.clientX - n.x
            const a = e.clientY - n.y
            i.translate(s - i.startX, a - i.startY)
            this.moveEditorInDOM(i)
            i.div.focus()
          }

          dragover(e) {
            e.preventDefault()
          }

          destroy() {
            let e
            ;((e = _classPrivateFieldGet(this, g).getActive()) === null || void 0 === e
              ? void 0
              : e.parent) === this && _classPrivateFieldGet(this, g).setActiveEditor(null)
            for (const e of _classPrivateFieldGet(this, h).values()) {
              var t
              ;(t = _classPrivateFieldGet(this, o)) === null ||
                void 0 === t ||
                t.removePointerInTextLayer(e.contentDiv)
              e.isAttachedToDOM = !1
              e.div.remove()
              e.parent = null
            }
            this.div = null
            _classPrivateFieldGet(this, h).clear()
            _classPrivateFieldGet(this, g).removeLayer(this)
          }

          render(e) {
            this.viewport = e.viewport
            ;(0, n.bindEvents)(this, this.div, ['dragover', 'drop'])
            this.setDimensions()
            for (const e of _classPrivateFieldGet(this, g).getEditors(this.pageIndex)) this.add(e)
            this.updateMode()
          }

          update(e) {
            this.viewport = e.viewport
            this.setDimensions()
            this.updateMode()
          }

          get scaleFactor() {
            return this.viewport.scale
          }

          get pageDimensions() {
            const [e, t, i, n] = this.viewport.viewBox
            return [i - e, n - t]
          }

          get viewportBaseDimensions() {
            const { width: e, height: t, rotation: i } = this.viewport
            return i % 180 == 0 ? [e, t] : [t, e]
          }

          setDimensions() {
            const { width: e, height: t, rotation: i } = this.viewport
            const n = i % 180 != 0
            const s = `${Math.floor(e)}px`
            const a = `${Math.floor(t)}px`
            this.div.style.width = n ? a : s
            this.div.style.height = n ? s : a
            this.div.setAttribute('data-main-rotation', i)
          }
        }
        t.AnnotationEditorLayer = AnnotationEditorLayer
        function _changeParent2(e) {
          let t
          if (e.parent !== this) {
            this.attach(e)
            e.pageIndex = this.pageIndex((t = e.parent)) === null || void 0 === t || t.detach(e)
            e.parent = this
            if (e.div && e.isAttachedToDOM) {
              e.div.remove()
              this.div.append(e.div)
            }
          }
        }
        function _createNewEditor2(e) {
          switch (_classPrivateFieldGet(this, g).getMode()) {
            case s.AnnotationEditorType.FREETEXT:
              return new a.FreeTextEditor(e)
            case s.AnnotationEditorType.INK:
              return new r.InkEditor(e)
          }
          return null
        }
        function _createAndAddNewEditor2(e) {
          const t = this.getNextId()
          const i = _classPrivateMethodGet(this, m, _createNewEditor2).call(this, {
            parent: this,
            id: t,
            x: e.offsetX,
            y: e.offsetY
          })
          i && this.add(i)
          return i
        }
        function _cleanup2() {
          _classPrivateFieldSet(this, p, !0)
          for (const e of _classPrivateFieldGet(this, h).values()) e.isEmpty() && e.remove()
          _classPrivateFieldSet(this, p, !1)
        }
        !(function _defineProperty(e, t, i) {
          t in e
            ? Object.defineProperty(e, t, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
              })
            : (e[t] = i)
          return e
        })(AnnotationEditorLayer, '_initialized', !1)
      },
      (e, t, i) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.FreeTextEditor = void 0
        const n = i(1)
        const s = i(132)
        const a = i(131)
        function _classPrivateMethodInitSpec(e, t) {
          _checkPrivateRedeclaration(e, t)
          t.add(e)
        }
        function _defineProperty(e, t, i) {
          t in e
            ? Object.defineProperty(e, t, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
              })
            : (e[t] = i)
          return e
        }
        function _classPrivateFieldInitSpec(e, t, i) {
          _checkPrivateRedeclaration(e, t)
          t.set(e, i)
        }
        function _checkPrivateRedeclaration(e, t) {
          if (t.has(e))
            throw new TypeError('Cannot initialize the same private elements twice on an object')
        }
        function _classPrivateFieldGet(e, t) {
          return (function _classApplyDescriptorGet(e, t) {
            if (t.get) return t.get.call(e)
            return t.value
          })(e, _classExtractFieldDescriptor(e, t, 'get'))
        }
        function _classPrivateMethodGet(e, t, i) {
          if (!t.has(e)) throw new TypeError('attempted to get private field on non-instance')
          return i
        }
        function _classPrivateFieldSet(e, t, i) {
          !(function _classApplyDescriptorSet(e, t, i) {
            if (t.set) t.set.call(e, i)
            else {
              if (!t.writable) throw new TypeError('attempted to set read only private field')
              t.value = i
            }
          })(e, _classExtractFieldDescriptor(e, t, 'set'), i)
          return i
        }
        function _classExtractFieldDescriptor(e, t, i) {
          if (!t.has(e)) throw new TypeError(`attempted to ${i} private field on non-instance`)
          return t.get(e)
        }
        const r = new WeakMap()
        const o = new WeakMap()
        const l = new WeakMap()
        const c = new WeakMap()
        const d = new WeakMap()
        const h = new WeakMap()
        const u = new WeakMap()
        const p = new WeakSet()
        const g = new WeakSet()
        const f = new WeakSet()
        const m = new WeakSet()
        class FreeTextEditor extends a.AnnotationEditor {
          constructor(e) {
            super({ ...e, name: 'freeTextEditor' })
            _classPrivateMethodInitSpec(this, m)
            _classPrivateMethodInitSpec(this, f)
            _classPrivateMethodInitSpec(this, g)
            _classPrivateMethodInitSpec(this, p)
            _classPrivateFieldInitSpec(this, r, {
              writable: !0,
              value: this.editorDivBlur.bind(this)
            })
            _classPrivateFieldInitSpec(this, o, {
              writable: !0,
              value: this.editorDivFocus.bind(this)
            })
            _classPrivateFieldInitSpec(this, l, {
              writable: !0,
              value: this.editorDivKeydown.bind(this)
            })
            _classPrivateFieldInitSpec(this, c, { writable: !0, value: void 0 })
            _classPrivateFieldInitSpec(this, d, { writable: !0, value: '' })
            _classPrivateFieldInitSpec(this, h, { writable: !0, value: !1 })
            _classPrivateFieldInitSpec(this, u, { writable: !0, value: void 0 })
            _classPrivateFieldSet(
              this,
              c,
              e.color || FreeTextEditor._defaultColor || a.AnnotationEditor._defaultLineColor
            )
            _classPrivateFieldSet(this, u, e.fontSize || FreeTextEditor._defaultFontSize)
          }

          static initialize(e) {
            this._l10nPromise = new Map(
              ['free_text_default_content', 'editor_free_text_aria_label'].map((t) => [t, e.get(t)])
            )
            const t = getComputedStyle(document.documentElement)
            this._internalPadding = parseFloat(t.getPropertyValue('--freetext-padding'))
          }

          static updateDefaultParams(e, t) {
            switch (e) {
              case n.AnnotationEditorParamsType.FREETEXT_SIZE:
                FreeTextEditor._defaultFontSize = t
                break
              case n.AnnotationEditorParamsType.FREETEXT_COLOR:
                FreeTextEditor._defaultColor = t
            }
          }

          updateParams(e, t) {
            switch (e) {
              case n.AnnotationEditorParamsType.FREETEXT_SIZE:
                _classPrivateMethodGet(this, p, _updateFontSize2).call(this, t)
                break
              case n.AnnotationEditorParamsType.FREETEXT_COLOR:
                _classPrivateMethodGet(this, g, _updateColor2).call(this, t)
            }
          }

          static get defaultPropertiesToUpdate() {
            return [
              [n.AnnotationEditorParamsType.FREETEXT_SIZE, FreeTextEditor._defaultFontSize],
              [
                n.AnnotationEditorParamsType.FREETEXT_COLOR,
                FreeTextEditor._defaultColor || a.AnnotationEditor._defaultLineColor
              ]
            ]
          }

          get propertiesToUpdate() {
            return [
              [n.AnnotationEditorParamsType.FREETEXT_SIZE, _classPrivateFieldGet(this, u)],
              [n.AnnotationEditorParamsType.FREETEXT_COLOR, _classPrivateFieldGet(this, c)]
            ]
          }

          getInitialTranslation() {
            return [
              -FreeTextEditor._internalPadding * this.parent.scaleFactor,
              -(FreeTextEditor._internalPadding + _classPrivateFieldGet(this, u)) *
                this.parent.scaleFactor
            ]
          }

          rebuild() {
            super.rebuild()
            this.div !== null && (this.isAttachedToDOM || this.parent.add(this))
          }

          enableEditMode() {
            if (!this.isInEditMode()) {
              this.parent.setEditingState(!1)
              this.parent.updateToolbar(n.AnnotationEditorType.FREETEXT)
              super.enableEditMode()
              this.enableEditing()
              this.overlayDiv.classList.remove('enabled')
              this.editorDiv.contentEditable = !0
              this.div.draggable = !1
              this.editorDiv.addEventListener('keydown', _classPrivateFieldGet(this, l))
              this.editorDiv.addEventListener('focus', _classPrivateFieldGet(this, o))
              this.editorDiv.addEventListener('blur', _classPrivateFieldGet(this, r))
            }
          }

          disableEditMode() {
            if (this.isInEditMode()) {
              this.parent.setEditingState(!0)
              super.disableEditMode()
              this.disableEditing()
              this.overlayDiv.classList.add('enabled')
              this.editorDiv.contentEditable = !1
              this.div.draggable = !0
              this.editorDiv.removeEventListener('keydown', _classPrivateFieldGet(this, l))
              this.editorDiv.removeEventListener('focus', _classPrivateFieldGet(this, o))
              this.editorDiv.removeEventListener('blur', _classPrivateFieldGet(this, r))
              this.div.focus()
              this.isEditing = !1
            }
          }

          focusin(e) {
            super.focusin(e)
            e.target !== this.editorDiv && this.editorDiv.focus()
          }

          onceAdded() {
            if (!this.width) {
              this.enableEditMode()
              this.editorDiv.focus()
            }
          }

          isEmpty() {
            return !this.editorDiv || this.editorDiv.innerText.trim() === ''
          }

          remove() {
            this.isEditing = !1
            this.parent.setEditingState(!0)
            super.remove()
          }

          commit() {
            super.commit()
            if (!_classPrivateFieldGet(this, h)) {
              _classPrivateFieldSet(this, h, !0)
              this.parent.addUndoableEditor(this)
            }
            this.disableEditMode()
            _classPrivateFieldSet(
              this,
              d,
              _classPrivateMethodGet(this, f, _extractText2).call(this).trimEnd()
            )
            _classPrivateMethodGet(this, m, _setEditorDimensions2).call(this)
          }

          shouldGetKeyboardEvents() {
            return this.isInEditMode()
          }

          dblclick(e) {
            this.enableEditMode()
            this.editorDiv.focus()
          }

          keydown(e) {
            if (e.target === this.div && e.key === 'Enter') {
              this.enableEditMode()
              this.editorDiv.focus()
            }
          }

          editorDivKeydown(e) {
            FreeTextEditor._keyboardManager.exec(this, e)
          }

          editorDivFocus(e) {
            this.isEditing = !0
          }

          editorDivBlur(e) {
            this.isEditing = !1
          }

          disableEditing() {
            this.editorDiv.setAttribute('role', 'comment')
            this.editorDiv.removeAttribute('aria-multiline')
          }

          enableEditing() {
            this.editorDiv.setAttribute('role', 'textbox')
            this.editorDiv.setAttribute('aria-multiline', !0)
          }

          render() {
            if (this.div) return this.div
            let e
            let t
            if (this.width) {
              e = this.x
              t = this.y
            }
            super.render()
            this.editorDiv = document.createElement('div')
            this.editorDiv.className = 'internal'
            this.editorDiv.setAttribute('id', `${this.id}-editor`)
            this.enableEditing()
            FreeTextEditor._l10nPromise.get('editor_free_text_aria_label').then((e) => {
              let t
              return (t = this.editorDiv) === null || void 0 === t
                ? void 0
                : t.setAttribute('aria-label', e)
            })
            FreeTextEditor._l10nPromise.get('free_text_default_content').then((e) => {
              let t
              return (t = this.editorDiv) === null || void 0 === t
                ? void 0
                : t.setAttribute('default-content', e)
            })
            this.editorDiv.contentEditable = !0
            const { style: i } = this.editorDiv
            i.fontSize = `calc(${_classPrivateFieldGet(this, u)}px * var(--scale-factor))`
            i.color = _classPrivateFieldGet(this, c)
            this.div.append(this.editorDiv)
            this.overlayDiv = document.createElement('div')
            this.overlayDiv.classList.add('overlay', 'enabled')
            this.div.append(this.overlayDiv)
            ;(0, s.bindEvents)(this, this.div, ['dblclick', 'keydown'])
            if (this.width) {
              const [i, n] = this.parent.viewportBaseDimensions
              this.setAt(e * i, t * n, this.width * i, this.height * n)
              for (const e of _classPrivateFieldGet(this, d).split('\n')) {
                const t = document.createElement('div')
                t.append(e ? document.createTextNode(e) : document.createElement('br'))
                this.editorDiv.append(t)
              }
              this.div.draggable = !0
              this.editorDiv.contentEditable = !1
            } else {
              this.div.draggable = !1
              this.editorDiv.contentEditable = !0
            }
            return this.div
          }

          get contentDiv() {
            return this.editorDiv
          }

          static deserialize(e, t) {
            const i = super.deserialize(e, t)
            _classPrivateFieldSet(i, u, e.fontSize)
            _classPrivateFieldSet(i, c, n.Util.makeHexColor(...e.color))
            _classPrivateFieldSet(i, d, e.value)
            return i
          }

          serialize() {
            if (this.isEmpty()) return null
            const e = FreeTextEditor._internalPadding * this.parent.scaleFactor
            const t = this.getRect(e, e)
            const i = a.AnnotationEditor._colorManager.convert(
              getComputedStyle(this.editorDiv).color
            )
            return {
              annotationType: n.AnnotationEditorType.FREETEXT,
              color: i,
              fontSize: _classPrivateFieldGet(this, u),
              value: _classPrivateFieldGet(this, d),
              pageIndex: this.parent.pageIndex,
              rect: t,
              rotation: this.rotation
            }
          }
        }
        t.FreeTextEditor = FreeTextEditor
        function _updateFontSize2(e) {
          const setFontsize = (e) => {
            this.editorDiv.style.fontSize = `calc(${e}px * var(--scale-factor))`
            this.translate(0, -(e - _classPrivateFieldGet(this, u)) * this.parent.scaleFactor)
            _classPrivateFieldSet(this, u, e)
            _classPrivateMethodGet(this, m, _setEditorDimensions2).call(this)
          }
          const t = _classPrivateFieldGet(this, u)
          this.parent.addCommands({
            cmd: () => {
              setFontsize(e)
            },
            undo: () => {
              setFontsize(t)
            },
            mustExec: !0,
            type: n.AnnotationEditorParamsType.FREETEXT_SIZE,
            overwriteIfSameType: !0,
            keepUndo: !0
          })
        }
        function _updateColor2(e) {
          const t = _classPrivateFieldGet(this, c)
          this.parent.addCommands({
            cmd: () => {
              _classPrivateFieldSet(this, c, e)
              this.editorDiv.style.color = e
            },
            undo: () => {
              _classPrivateFieldSet(this, c, t)
              this.editorDiv.style.color = t
            },
            mustExec: !0,
            type: n.AnnotationEditorParamsType.FREETEXT_COLOR,
            overwriteIfSameType: !0,
            keepUndo: !0
          })
        }
        function _extractText2() {
          const e = this.editorDiv.getElementsByTagName('div')
          if (e.length === 0) return this.editorDiv.innerText
          const t = []
          for (let i = 0, n = e.length; i < n; i++) {
            const n =
              e[i].firstChild(n == null ? void 0 : n.nodeName) === '#text'
                ? t.push(n.data)
                : t.push('')
          }
          return t.join('\n')
        }
        function _setEditorDimensions2() {
          const [e, t] = this.parent.viewportBaseDimensions
          const i = this.div.getBoundingClientRect()
          this.width = i.width / e
          this.height = i.height / t
        }
        _defineProperty(FreeTextEditor, '_freeTextDefaultContent', '')
        _defineProperty(FreeTextEditor, '_l10nPromise', void 0)
        _defineProperty(FreeTextEditor, '_internalPadding', 0)
        _defineProperty(FreeTextEditor, '_defaultColor', null)
        _defineProperty(FreeTextEditor, '_defaultFontSize', 10)
        _defineProperty(
          FreeTextEditor,
          '_keyboardManager',
          new s.KeyboardManager([
            [
              ['ctrl+Enter', 'mac+meta+Enter', 'Escape', 'mac+Escape'],
              FreeTextEditor.prototype.commitOrRemove
            ]
          ])
        )
        _defineProperty(FreeTextEditor, '_type', 'freetext')
      },
      (e, t, i) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.InkEditor = void 0
        Object.defineProperty(t, 'fitCurve', {
          enumerable: !0,
          get() {
            return a.fitCurve
          }
        })
        const n = i(1)
        const s = i(131)
        var a = i(152)
        const r = i(132)
        function _classPrivateMethodInitSpec(e, t) {
          _checkPrivateRedeclaration(e, t)
          t.add(e)
        }
        function _defineProperty(e, t, i) {
          t in e
            ? Object.defineProperty(e, t, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
              })
            : (e[t] = i)
          return e
        }
        function _classPrivateFieldInitSpec(e, t, i) {
          _checkPrivateRedeclaration(e, t)
          t.set(e, i)
        }
        function _checkPrivateRedeclaration(e, t) {
          if (t.has(e))
            throw new TypeError('Cannot initialize the same private elements twice on an object')
        }
        function _classStaticPrivateMethodGet(e, t, i) {
          !(function _classCheckPrivateStaticAccess(e, t) {
            if (e !== t) throw new TypeError('Private static access of wrong provenance')
          })(e, t)
          return i
        }
        function _classPrivateFieldSet(e, t, i) {
          !(function _classApplyDescriptorSet(e, t, i) {
            if (t.set) t.set.call(e, i)
            else {
              if (!t.writable) throw new TypeError('attempted to set read only private field')
              t.value = i
            }
          })(e, _classExtractFieldDescriptor(e, t, 'set'), i)
          return i
        }
        function _classPrivateFieldGet(e, t) {
          return (function _classApplyDescriptorGet(e, t) {
            if (t.get) return t.get.call(e)
            return t.value
          })(e, _classExtractFieldDescriptor(e, t, 'get'))
        }
        function _classExtractFieldDescriptor(e, t, i) {
          if (!t.has(e)) throw new TypeError(`attempted to ${i} private field on non-instance`)
          return t.get(e)
        }
        function _classPrivateMethodGet(e, t, i) {
          if (!t.has(e)) throw new TypeError('attempted to get private field on non-instance')
          return i
        }
        const o = 16
        const l = new WeakMap()
        const c = new WeakMap()
        const d = new WeakMap()
        const h = new WeakMap()
        const u = new WeakMap()
        const p = new WeakMap()
        const g = new WeakMap()
        const f = new WeakMap()
        const m = new WeakMap()
        const v = new WeakMap()
        const _ = new WeakMap()
        const b = new WeakMap()
        const w = new WeakMap()
        const P = new WeakMap()
        const y = new WeakSet()
        const S = new WeakSet()
        const A = new WeakSet()
        const E = new WeakSet()
        const x = new WeakSet()
        const C = new WeakSet()
        const M = new WeakSet()
        const T = new WeakSet()
        const k = new WeakSet()
        const I = new WeakSet()
        const D = new WeakSet()
        const L = new WeakSet()
        const R = new WeakSet()
        const O = new WeakSet()
        const N = new WeakSet()
        const B = new WeakSet()
        const G = new WeakSet()
        const V = new WeakSet()
        const W = new WeakSet()
        const j = new WeakSet()
        const U = new WeakSet()
        const z = new WeakSet()
        class InkEditor extends s.AnnotationEditor {
          constructor(e) {
            super({ ...e, name: 'inkEditor' })
            _classPrivateMethodInitSpec(this, z)
            _classPrivateMethodInitSpec(this, U)
            _classPrivateMethodInitSpec(this, j)
            _classPrivateMethodInitSpec(this, W)
            _classPrivateMethodInitSpec(this, V)
            _classPrivateMethodInitSpec(this, G)
            _classPrivateMethodInitSpec(this, B)
            _classPrivateMethodInitSpec(this, N)
            _classPrivateMethodInitSpec(this, O)
            _classPrivateMethodInitSpec(this, R)
            _classPrivateMethodInitSpec(this, L)
            _classPrivateMethodInitSpec(this, D)
            _classPrivateMethodInitSpec(this, I)
            _classPrivateMethodInitSpec(this, k)
            _classPrivateMethodInitSpec(this, T)
            _classPrivateMethodInitSpec(this, M)
            _classPrivateMethodInitSpec(this, C)
            _classPrivateMethodInitSpec(this, x)
            _classPrivateMethodInitSpec(this, E)
            _classPrivateMethodInitSpec(this, A)
            _classPrivateMethodInitSpec(this, S)
            _classPrivateMethodInitSpec(this, y)
            _classPrivateFieldInitSpec(this, l, { writable: !0, value: 0 })
            _classPrivateFieldInitSpec(this, c, { writable: !0, value: 0 })
            _classPrivateFieldInitSpec(this, d, { writable: !0, value: 0 })
            _classPrivateFieldInitSpec(this, h, {
              writable: !0,
              value: this.canvasPointermove.bind(this)
            })
            _classPrivateFieldInitSpec(this, u, {
              writable: !0,
              value: this.canvasPointerleave.bind(this)
            })
            _classPrivateFieldInitSpec(this, p, {
              writable: !0,
              value: this.canvasPointerup.bind(this)
            })
            _classPrivateFieldInitSpec(this, g, {
              writable: !0,
              value: this.canvasPointerdown.bind(this)
            })
            _classPrivateFieldInitSpec(this, f, { writable: !0, value: !1 })
            _classPrivateFieldInitSpec(this, m, { writable: !0, value: !1 })
            _classPrivateFieldInitSpec(this, v, { writable: !0, value: null })
            _classPrivateFieldInitSpec(this, _, { writable: !0, value: null })
            _classPrivateFieldInitSpec(this, b, { writable: !0, value: 0 })
            _classPrivateFieldInitSpec(this, w, { writable: !0, value: 0 })
            _classPrivateFieldInitSpec(this, P, { writable: !0, value: null })
            this.color = e.color || null
            this.thickness = e.thickness || null
            this.opacity = e.opacity || null
            this.paths = []
            this.bezierPath2D = []
            this.currentPath = []
            this.scaleFactor = 1
            this.translationX = this.translationY = 0
            this.x = 0
            this.y = 0
          }

          static initialize(e) {
            this._l10nPromise = new Map(
              ['editor_ink_canvas_aria_label', 'editor_ink_aria_label'].map((t) => [t, e.get(t)])
            )
          }

          static updateDefaultParams(e, t) {
            switch (e) {
              case n.AnnotationEditorParamsType.INK_THICKNESS:
                InkEditor._defaultThickness = t
                break
              case n.AnnotationEditorParamsType.INK_COLOR:
                InkEditor._defaultColor = t
                break
              case n.AnnotationEditorParamsType.INK_OPACITY:
                InkEditor._defaultOpacity = t / 100
            }
          }

          updateParams(e, t) {
            switch (e) {
              case n.AnnotationEditorParamsType.INK_THICKNESS:
                _classPrivateMethodGet(this, y, _updateThickness2).call(this, t)
                break
              case n.AnnotationEditorParamsType.INK_COLOR:
                _classPrivateMethodGet(this, S, _updateColor2).call(this, t)
                break
              case n.AnnotationEditorParamsType.INK_OPACITY:
                _classPrivateMethodGet(this, A, _updateOpacity2).call(this, t)
            }
          }

          static get defaultPropertiesToUpdate() {
            return [
              [n.AnnotationEditorParamsType.INK_THICKNESS, InkEditor._defaultThickness],
              [
                n.AnnotationEditorParamsType.INK_COLOR,
                InkEditor._defaultColor || s.AnnotationEditor._defaultLineColor
              ],
              [
                n.AnnotationEditorParamsType.INK_OPACITY,
                Math.round(100 * InkEditor._defaultOpacity)
              ]
            ]
          }

          get propertiesToUpdate() {
            let e
            return [
              [
                n.AnnotationEditorParamsType.INK_THICKNESS,
                this.thickness || InkEditor._defaultThickness
              ],
              [
                n.AnnotationEditorParamsType.INK_COLOR,
                this.color || InkEditor._defaultColor || s.AnnotationEditor._defaultLineColor
              ],
              [
                n.AnnotationEditorParamsType.INK_OPACITY,
                Math.round(
                  100 *
                    ((e = this.opacity) !== null && void 0 !== e ? e : InkEditor._defaultOpacity)
                )
              ]
            ]
          }

          rebuild() {
            super.rebuild()
            if (this.div !== null) {
              if (!this.canvas) {
                _classPrivateMethodGet(this, D, _createCanvas2).call(this)
                _classPrivateMethodGet(this, L, _createObserver2).call(this)
              }
              if (!this.isAttachedToDOM) {
                this.parent.add(this)
                _classPrivateMethodGet(this, R, _setCanvasDims2).call(this)
              }
              _classPrivateMethodGet(this, U, _fitToContent2).call(this)
            }
          }

          remove() {
            if (this.canvas !== null) {
              this.isEmpty() || this.commit()
              this.canvas.width = this.canvas.height = 0
              this.canvas.remove()
              this.canvas = null
              _classPrivateFieldGet(this, _).disconnect()
              _classPrivateFieldSet(this, _, null)
              super.remove()
            }
          }

          enableEditMode() {
            if (!_classPrivateFieldGet(this, f) && this.canvas !== null) {
              super.enableEditMode()
              this.div.draggable = !1
              this.canvas.addEventListener('pointerdown', _classPrivateFieldGet(this, g))
              this.canvas.addEventListener('pointerup', _classPrivateFieldGet(this, p))
            }
          }

          disableEditMode() {
            if (this.isInEditMode() && this.canvas !== null) {
              super.disableEditMode()
              this.div.draggable = !this.isEmpty()
              this.div.classList.remove('editing')
              this.canvas.removeEventListener('pointerdown', _classPrivateFieldGet(this, g))
              this.canvas.removeEventListener('pointerup', _classPrivateFieldGet(this, p))
            }
          }

          onceAdded() {
            this.div.draggable = !this.isEmpty()
          }

          isEmpty() {
            return (
              this.paths.length === 0 || (this.paths.length === 1 && this.paths[0].length === 0)
            )
          }

          commit() {
            if (!_classPrivateFieldGet(this, f)) {
              super.commit()
              this.isEditing = !1
              this.disableEditMode()
              this.setInForeground()
              _classPrivateFieldSet(this, f, !0)
              this.div.classList.add('disabled')
              _classPrivateMethodGet(this, U, _fitToContent2).call(this, !0)
              this.parent.addInkEditorIfNeeded(!0)
              this.parent.moveEditorInDOM(this)
              this.div.focus()
            }
          }

          focusin(e) {
            super.focusin(e)
            this.enableEditMode()
          }

          canvasPointerdown(e) {
            if (e.button === 0 && this.isInEditMode() && !_classPrivateFieldGet(this, f)) {
              this.setInForeground()
              e.type !== 'mouse' && this.div.focus()
              e.stopPropagation()
              this.canvas.addEventListener('pointerleave', _classPrivateFieldGet(this, u))
              this.canvas.addEventListener('pointermove', _classPrivateFieldGet(this, h))
              _classPrivateMethodGet(this, C, _startDrawing2).call(this, e.offsetX, e.offsetY)
            }
          }

          canvasPointermove(e) {
            e.stopPropagation()
            _classPrivateMethodGet(this, M, _draw2).call(this, e.offsetX, e.offsetY)
          }

          canvasPointerup(e) {
            if (e.button === 0 && this.isInEditMode() && this.currentPath.length !== 0) {
              e.stopPropagation()
              _classPrivateMethodGet(this, I, _endDrawing2).call(this, e)
              this.setInBackground()
            }
          }

          canvasPointerleave(e) {
            _classPrivateMethodGet(this, I, _endDrawing2).call(this, e)
            this.setInBackground()
          }

          render() {
            if (this.div) return this.div
            let e
            let t
            if (this.width) {
              e = this.x
              t = this.y
            }
            super.render()
            InkEditor._l10nPromise.get('editor_ink_aria_label').then((e) => {
              let t
              return (t = this.div) === null || void 0 === t
                ? void 0
                : t.setAttribute('aria-label', e)
            })
            const [i, n, s, a] = _classPrivateMethodGet(this, E, _getInitialBBox2).call(this)
            this.setAt(i, n, 0, 0)
            this.setDims(s, a)
            _classPrivateMethodGet(this, D, _createCanvas2).call(this)
            if (this.width) {
              const [i, n] = this.parent.viewportBaseDimensions
              this.setAt(e * i, t * n, this.width * i, this.height * n)
              _classPrivateFieldSet(this, m, !0)
              _classPrivateMethodGet(this, R, _setCanvasDims2).call(this)
              this.setDims(this.width * i, this.height * n)
              _classPrivateMethodGet(this, k, _redraw2).call(this)
              _classPrivateMethodGet(this, z, _setMinDims2).call(this)
              this.div.classList.add('disabled')
            } else {
              this.div.classList.add('editing')
              this.enableEditMode()
            }
            _classPrivateMethodGet(this, L, _createObserver2).call(this)
            return this.div
          }

          setDimensions(e, t) {
            const i = Math.round(e)
            const n = Math.round(t)
            if (_classPrivateFieldGet(this, b) === i && _classPrivateFieldGet(this, w) === n) return
            _classPrivateFieldSet(this, b, i)
            _classPrivateFieldSet(this, w, n)
            this.canvas.style.visibility = 'hidden'
            if (
              _classPrivateFieldGet(this, l) &&
              Math.abs(_classPrivateFieldGet(this, l) - e / t) > 0.01
            ) {
              t = Math.ceil(e / _classPrivateFieldGet(this, l))
              this.setDims(e, t)
            }
            const [s, a] = this.parent.viewportBaseDimensions
            this.width = e / s
            this.height = t / a
            _classPrivateFieldGet(this, f) &&
              _classPrivateMethodGet(this, O, _setScaleFactor2).call(this, e, t)
            _classPrivateMethodGet(this, R, _setCanvasDims2).call(this)
            _classPrivateMethodGet(this, k, _redraw2).call(this)
            this.canvas.style.visibility = 'visible'
          }

          static deserialize(e, t) {
            const i = super.deserialize(e, t)
            i.thickness = e.thickness
            i.color = n.Util.makeHexColor(...e.color)
            i.opacity = e.opacity
            const [s, a] = t.pageDimensions
            const r = i.width * s
            const h = i.height * a
            const u = t.scaleFactor
            const p = e.thickness / 2
            _classPrivateFieldSet(i, l, r / h)
            _classPrivateFieldSet(i, f, !0)
            _classPrivateFieldSet(i, b, Math.round(r))
            _classPrivateFieldSet(i, w, Math.round(h))
            for (const { bezier: t } of e.paths) {
              const e = []
              i.paths.push(e)
              let n = u * (t[0] - p)
              let s = u * (h - t[1] - p)
              for (let i = 2, a = t.length; i < a; i += 6) {
                const a = u * (t[i] - p)
                const r = u * (h - t[i + 1] - p)
                const o = u * (t[i + 2] - p)
                const l = u * (h - t[i + 3] - p)
                const c = u * (t[i + 4] - p)
                const d = u * (h - t[i + 5] - p)
                e.push([
                  [n, s],
                  [a, r],
                  [o, l],
                  [c, d]
                ])
                n = c
                s = d
              }
              const a = _classStaticPrivateMethodGet(this, InkEditor, _buildPath2D).call(this, e)
              i.bezierPath2D.push(a)
            }
            const g = _classPrivateMethodGet(i, W, _getBbox2).call(i)
            _classPrivateFieldSet(i, d, Math.max(o, g[2] - g[0]))
            _classPrivateFieldSet(i, c, Math.max(o, g[3] - g[1]))
            _classPrivateMethodGet(i, O, _setScaleFactor2).call(i, r, h)
            return i
          }

          serialize() {
            if (this.isEmpty()) return null
            const e = this.getRect(0, 0)
            const t = this.rotation % 180 == 0 ? e[3] - e[1] : e[2] - e[0]
            const i = s.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle)
            return {
              annotationType: n.AnnotationEditorType.INK,
              color: i,
              thickness: this.thickness,
              opacity: this.opacity,
              paths: _classPrivateMethodGet(this, B, _serializePaths2).call(
                this,
                this.scaleFactor / this.parent.scaleFactor,
                this.translationX,
                this.translationY,
                t
              ),
              pageIndex: this.parent.pageIndex,
              rect: e,
              rotation: this.rotation
            }
          }
        }
        t.InkEditor = InkEditor
        function _updateThickness2(e) {
          const t = this.thickness
          this.parent.addCommands({
            cmd: () => {
              this.thickness = e
              _classPrivateMethodGet(this, U, _fitToContent2).call(this)
            },
            undo: () => {
              this.thickness = t
              _classPrivateMethodGet(this, U, _fitToContent2).call(this)
            },
            mustExec: !0,
            type: n.AnnotationEditorParamsType.INK_THICKNESS,
            overwriteIfSameType: !0,
            keepUndo: !0
          })
        }
        function _updateColor2(e) {
          const t = this.color
          this.parent.addCommands({
            cmd: () => {
              this.color = e
              _classPrivateMethodGet(this, k, _redraw2).call(this)
            },
            undo: () => {
              this.color = t
              _classPrivateMethodGet(this, k, _redraw2).call(this)
            },
            mustExec: !0,
            type: n.AnnotationEditorParamsType.INK_COLOR,
            overwriteIfSameType: !0,
            keepUndo: !0
          })
        }
        function _updateOpacity2(e) {
          e /= 100
          const t = this.opacity
          this.parent.addCommands({
            cmd: () => {
              this.opacity = e
              _classPrivateMethodGet(this, k, _redraw2).call(this)
            },
            undo: () => {
              this.opacity = t
              _classPrivateMethodGet(this, k, _redraw2).call(this)
            },
            mustExec: !0,
            type: n.AnnotationEditorParamsType.INK_OPACITY,
            overwriteIfSameType: !0,
            keepUndo: !0
          })
        }
        function _getInitialBBox2() {
          const { width: e, height: t, rotation: i } = this.parent.viewport
          switch (i) {
            case 90:
              return [0, e, e, t]
            case 180:
              return [e, t, e, t]
            case 270:
              return [t, 0, e, t]
            default:
              return [0, 0, e, t]
          }
        }
        function _setStroke2() {
          this.ctx.lineWidth = (this.thickness * this.parent.scaleFactor) / this.scaleFactor
          this.ctx.lineCap = 'round'
          this.ctx.lineJoin = 'round'
          this.ctx.miterLimit = 10
          this.ctx.strokeStyle = `${this.color}${(0, r.opacityToHex)(this.opacity)}`
        }
        function _startDrawing2(e, t) {
          this.isEditing = !0
          if (!_classPrivateFieldGet(this, m)) {
            let i
            _classPrivateFieldSet(this, m, !0)
            _classPrivateMethodGet(this, R, _setCanvasDims2).call(this)
            this.thickness || (this.thickness = InkEditor._defaultThickness)
            this.color ||
              (this.color = InkEditor._defaultColor || s.AnnotationEditor._defaultLineColor)
            ;((i = this.opacity) !== null && void 0 !== i) ||
              (this.opacity = InkEditor._defaultOpacity)
          }
          this.currentPath.push([e, t])
          _classPrivateFieldSet(this, v, null)
          _classPrivateMethodGet(this, x, _setStroke2).call(this)
          this.ctx.beginPath()
          this.ctx.moveTo(e, t)
          _classPrivateFieldSet(this, P, () => {
            if (_classPrivateFieldGet(this, P)) {
              if (_classPrivateFieldGet(this, v)) {
                if (this.isEmpty()) {
                  this.ctx.setTransform(1, 0, 0, 1, 0, 0)
                  this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)
                } else _classPrivateMethodGet(this, k, _redraw2).call(this)
                this.ctx.lineTo(..._classPrivateFieldGet(this, v))
                _classPrivateFieldSet(this, v, null)
                this.ctx.stroke()
              }
              window.requestAnimationFrame(_classPrivateFieldGet(this, P))
            }
          })
          window.requestAnimationFrame(_classPrivateFieldGet(this, P))
        }
        function _draw2(e, t) {
          const [i, n] = this.currentPath.at(-1)
          if (e !== i || t !== n) {
            this.currentPath.push([e, t])
            _classPrivateFieldSet(this, v, [e, t])
          }
        }
        function _stopDrawing2(e, t) {
          this.ctx.closePath()
          _classPrivateFieldSet(this, P, null)
          e = Math.min(Math.max(e, 0), this.canvas.width)
          t = Math.min(Math.max(t, 0), this.canvas.height)
          const [i, n] = this.currentPath.at(-1)
          ;(e === i && t === n) || this.currentPath.push([e, t])
          let s
          if (this.currentPath.length !== 1) s = (0, a.fitCurve)(this.currentPath, 30, null)
          else {
            const i = [e, t]
            s = [[i, i.slice(), i.slice(), i]]
          }
          const r = _classStaticPrivateMethodGet(InkEditor, InkEditor, _buildPath2D).call(
            InkEditor,
            s
          )
          this.currentPath.length = 0
          this.parent.addCommands({
            cmd: () => {
              this.paths.push(s)
              this.bezierPath2D.push(r)
              this.rebuild()
            },
            undo: () => {
              this.paths.pop()
              this.bezierPath2D.pop()
              if (this.paths.length === 0) this.remove()
              else {
                if (!this.canvas) {
                  _classPrivateMethodGet(this, D, _createCanvas2).call(this)
                  _classPrivateMethodGet(this, L, _createObserver2).call(this)
                }
                _classPrivateMethodGet(this, U, _fitToContent2).call(this)
              }
            },
            mustExec: !0
          })
        }
        function _redraw2() {
          if (this.isEmpty()) {
            _classPrivateMethodGet(this, N, _updateTransform2).call(this)
            return
          }
          _classPrivateMethodGet(this, x, _setStroke2).call(this)
          const { canvas: e, ctx: t } = this
          t.setTransform(1, 0, 0, 1, 0, 0)
          t.clearRect(0, 0, e.width, e.height)
          _classPrivateMethodGet(this, N, _updateTransform2).call(this)
          for (const e of this.bezierPath2D) t.stroke(e)
        }
        function _endDrawing2(e) {
          _classPrivateMethodGet(this, T, _stopDrawing2).call(this, e.offsetX, e.offsetY)
          this.canvas.removeEventListener('pointerleave', _classPrivateFieldGet(this, u))
          this.canvas.removeEventListener('pointermove', _classPrivateFieldGet(this, h))
          this.parent.addToAnnotationStorage(this)
        }
        function _createCanvas2() {
          this.canvas = document.createElement('canvas')
          this.canvas.width = this.canvas.height = 0
          this.canvas.className = 'inkEditorCanvas'
          InkEditor._l10nPromise.get('editor_ink_canvas_aria_label').then((e) => {
            let t
            return (t = this.canvas) === null || void 0 === t
              ? void 0
              : t.setAttribute('aria-label', e)
          })
          this.div.append(this.canvas)
          this.ctx = this.canvas.getContext('2d')
        }
        function _createObserver2() {
          _classPrivateFieldSet(
            this,
            _,
            new ResizeObserver((e) => {
              const t = e[0].contentRect
              t.width && t.height && this.setDimensions(t.width, t.height)
            })
          )
          _classPrivateFieldGet(this, _).observe(this.div)
        }
        function _setCanvasDims2() {
          if (!_classPrivateFieldGet(this, m)) return
          const [e, t] = this.parent.viewportBaseDimensions
          this.canvas.width = Math.ceil(this.width * e)
          this.canvas.height = Math.ceil(this.height * t)
          _classPrivateMethodGet(this, N, _updateTransform2).call(this)
        }
        function _setScaleFactor2(e, t) {
          const i = _classPrivateMethodGet(this, j, _getPadding2).call(this)
          const n = (e - i) / _classPrivateFieldGet(this, d)
          const s = (t - i) / _classPrivateFieldGet(this, c)
          this.scaleFactor = Math.min(n, s)
        }
        function _updateTransform2() {
          const e = _classPrivateMethodGet(this, j, _getPadding2).call(this) / 2
          this.ctx.setTransform(
            this.scaleFactor,
            0,
            0,
            this.scaleFactor,
            this.translationX * this.scaleFactor + e,
            this.translationY * this.scaleFactor + e
          )
        }
        function _buildPath2D(e) {
          const t = new Path2D()
          for (let i = 0, n = e.length; i < n; i++) {
            const [n, s, a, r] = e[i]
            i === 0 && t.moveTo(...n)
            t.bezierCurveTo(s[0], s[1], a[0], a[1], r[0], r[1])
          }
          return t
        }
        function _serializePaths2(e, t, i, n) {
          const s = []
          const a = this.thickness / 2
          let r
          let o
          for (const l of this.paths) {
            r = []
            o = []
            for (let s = 0, c = l.length; s < c; s++) {
              const [c, d, h, u] = l[s]
              const p = e * (c[0] + t) + a
              const g = n - e * (c[1] + i) - a
              const f = e * (d[0] + t) + a
              const m = n - e * (d[1] + i) - a
              const v = e * (h[0] + t) + a
              const _ = n - e * (h[1] + i) - a
              const b = e * (u[0] + t) + a
              const w = n - e * (u[1] + i) - a
              if (s === 0) {
                r.push(p, g)
                o.push(p, g)
              }
              r.push(f, m, v, _, b, w)
              _classPrivateMethodGet(this, G, _extractPointsOnBezier2).call(
                this,
                p,
                g,
                f,
                m,
                v,
                _,
                b,
                w,
                4,
                o
              )
            }
            s.push({ bezier: r, points: o })
          }
          return s
        }
        function _extractPointsOnBezier2(e, t, i, n, s, a, r, o, l, c) {
          if (_classPrivateMethodGet(this, V, _isAlmostFlat2).call(this, e, t, i, n, s, a, r, o))
            c.push(r, o)
          else {
            for (let d = 1; d < l - 1; d++) {
              const h = d / l
              const u = 1 - h
              let p = h * e + u * i
              let g = h * t + u * n
              let f = h * i + u * s
              let m = h * n + u * a
              p = h * p + u * f
              g = h * g + u * m
              f = h * f + u * (h * s + u * r)
              m = h * m + u * (h * a + u * o)
              p = h * p + u * f
              g = h * g + u * m
              c.push(p, g)
            }
            c.push(r, o)
          }
        }
        function _isAlmostFlat2(e, t, i, n, s, a, r, o) {
          const l = (3 * i - 2 * e - r) ** 2
          const c = (3 * n - 2 * t - o) ** 2
          const d = (3 * s - e - 2 * r) ** 2
          const h = (3 * a - t - 2 * o) ** 2
          return Math.max(l, d) + Math.max(c, h) <= 10
        }
        function _getBbox2() {
          let e = 1 / 0
          let t = -1 / 0
          let i = 1 / 0
          let s = -1 / 0
          for (const a of this.paths)
            for (const [r, o, l, c] of a) {
              const a = n.Util.bezierBoundingBox(...r, ...o, ...l, ...c)
              e = Math.min(e, a[0])
              i = Math.min(i, a[1])
              t = Math.max(t, a[2])
              s = Math.max(s, a[3])
            }
          return [e, i, t, s]
        }
        function _getPadding2() {
          return _classPrivateFieldGet(this, f)
            ? Math.ceil(this.thickness * this.parent.scaleFactor)
            : 0
        }
        function _fitToContent2() {
          const e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
          if (this.isEmpty()) return
          if (!_classPrivateFieldGet(this, f)) {
            _classPrivateMethodGet(this, k, _redraw2).call(this)
            return
          }
          const t = _classPrivateMethodGet(this, W, _getBbox2).call(this)
          const i = _classPrivateMethodGet(this, j, _getPadding2).call(this)
          _classPrivateFieldSet(this, d, Math.max(o, t[2] - t[0]))
          _classPrivateFieldSet(this, c, Math.max(o, t[3] - t[1]))
          const n = Math.ceil(i + _classPrivateFieldGet(this, d) * this.scaleFactor)
          const s = Math.ceil(i + _classPrivateFieldGet(this, c) * this.scaleFactor)
          const [a, r] = this.parent.viewportBaseDimensions
          this.width = n / a
          this.height = s / r
          _classPrivateFieldSet(this, l, n / s)
          _classPrivateMethodGet(this, z, _setMinDims2).call(this)
          const h = this.translationX
          const u = this.translationY
          this.translationX = -t[0]
          this.translationY = -t[1]
          _classPrivateMethodGet(this, R, _setCanvasDims2).call(this)
          _classPrivateMethodGet(this, k, _redraw2).call(this)
          _classPrivateFieldSet(this, b, n)
          _classPrivateFieldSet(this, w, s)
          this.setDims(n, s)
          const p = e ? i / this.scaleFactor / 2 : 0
          this.translate(h - this.translationX - p, u - this.translationY - p)
        }
        function _setMinDims2() {
          const { style: e } = this.div
          if (_classPrivateFieldGet(this, l) >= 1) {
            e.minHeight = '16px'
            e.minWidth = `${Math.round(_classPrivateFieldGet(this, l) * o)}px`
          } else {
            e.minWidth = '16px'
            e.minHeight = `${Math.round(o / _classPrivateFieldGet(this, l))}px`
          }
        }
        _defineProperty(InkEditor, '_defaultColor', null)
        _defineProperty(InkEditor, '_defaultOpacity', 1)
        _defineProperty(InkEditor, '_defaultThickness', 1)
        _defineProperty(InkEditor, '_l10nPromise', void 0)
        _defineProperty(InkEditor, '_type', 'ink')
      },
      (e, t, i) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.fitCurve = void 0
        const n = i(153)
        t.fitCurve = n
      },
      (e) => {
        function fitCubic(e, t, i, n, s) {
          let a
          let r
          let o
          let l
          let c
          let d
          let h
          let u
          let p
          let g
          let f
          let m
          let v
          if (e.length === 2) {
            m = maths.vectorLen(maths.subtract(e[0], e[1])) / 3
            return [
              (a = [
                e[0],
                maths.addArrays(e[0], maths.mulItems(t, m)),
                maths.addArrays(e[1], maths.mulItems(i, m)),
                e[1]
              ])
            ]
          }
          r = (function chordLengthParameterize(e) {
            let t
            let i
            let n
            let s = []
            e.forEach((e, a) => {
              t = a ? i + maths.vectorLen(maths.subtract(e, n)) : 0
              s.push(t)
              i = t
              n = e
            })
            return (s = s.map((e) => e / i))
          })(e)
          ;[a, l, d] = generateAndReport(e, r, r, t, i, s)
          if (l === 0 || l < n) return [a]
          if (l < n * n) {
            o = r
            c = l
            h = d
            for (v = 0; v < 20; v++) {
              o = reparameterize(a, e, o)
              ;[a, l, d] = generateAndReport(e, r, o, t, i, s)
              if (l < n) return [a]
              if (d === h) {
                const e = l / c
                if (e > 0.9999 && e < 1.0001) break
              }
              c = l
              h = d
            }
          }
          f = []
          if ((u = maths.subtract(e[d - 1], e[d + 1])).every((e) => e === 0)) {
            u = maths.subtract(e[d - 1], e[d])
            ;[u[0], u[1]] = [-u[1], u[0]]
          }
          p = maths.normalize(u)
          g = maths.mulItems(p, -1)
          return (f = (f = f.concat(fitCubic(e.slice(0, d + 1), t, p, n, s))).concat(
            fitCubic(e.slice(d), g, i, n, s)
          ))
        }
        function generateAndReport(e, t, i, n, s, a) {
          let r
          let o
          let l
          r = (function generateBezier(e, t, i, n) {
            let s
            let a
            let r
            let o
            let l
            let c
            let d
            let h
            let u
            let p
            let g
            let f
            let m
            let v
            let _
            let b
            let w
            const P = e[0]
            const y = e[e.length - 1]
            s = [P, null, null, y]
            a = maths.zeros_Xx2x2(t.length)
            for (m = 0, v = t.length; m < v; m++) {
              w = 1 - (b = t[m])
              ;(r = a[m])[0] = maths.mulItems(i, 3 * b * (w * w))
              r[1] = maths.mulItems(n, 3 * w * (b * b))
            }
            o = [
              [0, 0],
              [0, 0]
            ]
            l = [0, 0]
            for (m = 0, v = e.length; m < v; m++) {
              b = t[m]
              r = a[m]
              o[0][0] += maths.dot(r[0], r[0])
              o[0][1] += maths.dot(r[0], r[1])
              o[1][0] += maths.dot(r[0], r[1])
              o[1][1] += maths.dot(r[1], r[1])
              _ = maths.subtract(e[m], bezier.q([P, P, y, y], b))
              l[0] += maths.dot(r[0], _)
              l[1] += maths.dot(r[1], _)
            }
            c = o[0][0] * o[1][1] - o[1][0] * o[0][1]
            d = o[0][0] * l[1] - o[1][0] * l[0]
            h = l[0] * o[1][1] - l[1] * o[0][1]
            u = c === 0 ? 0 : h / c
            p = c === 0 ? 0 : d / c
            f = maths.vectorLen(maths.subtract(P, y))
            if (u < (g = 1e-6 * f) || p < g) {
              s[1] = maths.addArrays(P, maths.mulItems(i, f / 3))
              s[2] = maths.addArrays(y, maths.mulItems(n, f / 3))
            } else {
              s[1] = maths.addArrays(P, maths.mulItems(i, u))
              s[2] = maths.addArrays(y, maths.mulItems(n, p))
            }
            return s
          })(e, i, n, s)
          ;[o, l] = (function computeMaxError(e, t, i) {
            let n
            let s
            let a
            let r
            let o
            let l
            let c
            let d
            s = 0
            a = Math.floor(e.length / 2)
            const h = mapTtoRelativeDistances(t, 10)
            for (o = 0, l = e.length; o < l; o++) {
              c = e[o]
              d = find_t(t, i[o], h, 10)
              if ((n = (r = maths.subtract(bezier.q(t, d), c))[0] * r[0] + r[1] * r[1]) > s) {
                s = n
                a = o
              }
            }
            return [s, a]
          })(e, r, t)
          a && a({ bez: r, points: e, params: t, maxErr: o, maxPoint: l })
          return [r, o, l]
        }
        function reparameterize(e, t, i) {
          return i.map((i, n) => newtonRaphsonRootFind(e, t[n], i))
        }
        function newtonRaphsonRootFind(e, t, i) {
          const n = maths.subtract(bezier.q(e, i), t)
          const s = bezier.qprime(e, i)
          const a = maths.mulMatrix(n, s)
          const r =
            maths.sum(maths.squareItems(s)) + 2 * maths.mulMatrix(n, bezier.qprimeprime(e, i))
          return r === 0 ? i : i - a / r
        }
        var mapTtoRelativeDistances = function (e, t) {
          for (var i, n = [0], s = e[0], a = 0, r = 1; r <= t; r++) {
            i = bezier.q(e, r / t)
            a += maths.vectorLen(maths.subtract(i, s))
            n.push(a)
            s = i
          }
          return (n = n.map((e) => e / a))
        }
        function find_t(e, t, i, n) {
          if (t < 0) return 0
          if (t > 1) return 1
          for (var s, a, r, o, l = 1; l <= n; l++)
            if (t <= i[l]) {
              r = (l - 1) / n
              a = l / n
              o = ((t - (s = i[l - 1])) / (i[l] - s)) * (a - r) + r
              break
            }
          return o
        }
        function createTangent(e, t) {
          return maths.normalize(maths.subtract(e, t))
        }
        class maths {
          static zeros_Xx2x2(e) {
            for (var t = []; e--; ) t.push([0, 0])
            return t
          }

          static mulItems(e, t) {
            return e.map((e) => e * t)
          }

          static mulMatrix(e, t) {
            return e.reduce((e, i, n) => e + i * t[n], 0)
          }

          static subtract(e, t) {
            return e.map((e, i) => e - t[i])
          }

          static addArrays(e, t) {
            return e.map((e, i) => e + t[i])
          }

          static addItems(e, t) {
            return e.map((e) => e + t)
          }

          static sum(e) {
            return e.reduce((e, t) => e + t)
          }

          static dot(e, t) {
            return maths.mulMatrix(e, t)
          }

          static vectorLen(e) {
            return Math.hypot(...e)
          }

          static divItems(e, t) {
            return e.map((e) => e / t)
          }

          static squareItems(e) {
            return e.map((e) => e * e)
          }

          static normalize(e) {
            return this.divItems(e, this.vectorLen(e))
          }
        }
        class bezier {
          static q(e, t) {
            const i = 1 - t
            const n = maths.mulItems(e[0], i * i * i)
            const s = maths.mulItems(e[1], 3 * i * i * t)
            const a = maths.mulItems(e[2], 3 * i * t * t)
            const r = maths.mulItems(e[3], t * t * t)
            return maths.addArrays(maths.addArrays(n, s), maths.addArrays(a, r))
          }

          static qprime(e, t) {
            const i = 1 - t
            const n = maths.mulItems(maths.subtract(e[1], e[0]), 3 * i * i)
            const s = maths.mulItems(maths.subtract(e[2], e[1]), 6 * i * t)
            const a = maths.mulItems(maths.subtract(e[3], e[2]), 3 * t * t)
            return maths.addArrays(maths.addArrays(n, s), a)
          }

          static qprimeprime(e, t) {
            return maths.addArrays(
              maths.mulItems(
                maths.addArrays(maths.subtract(e[2], maths.mulItems(e[1], 2)), e[0]),
                6 * (1 - t)
              ),
              maths.mulItems(
                maths.addArrays(maths.subtract(e[3], maths.mulItems(e[2], 2)), e[1]),
                6 * t
              )
            )
          }
        }
        e.exports = function fitCurve(e, t, i) {
          if (!Array.isArray(e)) throw new TypeError('First argument should be an array')
          e.forEach((t) => {
            if (
              !Array.isArray(t) ||
              t.some((e) => typeof e !== 'number') ||
              t.length !== e[0].length
            )
              throw Error(
                'Each point should be an array of numbers. Each point should have the same amount of numbers.'
              )
          })
          if ((e = e.filter((t, i) => i === 0 || !t.every((t, n) => t === e[i - 1][n]))).length < 2)
            return []
          const n = e.length
          const s = createTangent(e[1], e[0])
          const a = createTangent(e[n - 2], e[n - 1])
          return fitCubic(e, s, a, t, i)
        }
        e.exports.fitCubic = fitCubic
        e.exports.createTangent = createTangent
      },
      (e, t, i) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.AnnotationLayer = void 0
        const n = i(1)
        const s = i(133)
        const a = i(130)
        const r = i(155)
        const o = i(156)
        function _classStaticPrivateMethodGet(e, t, i) {
          !(function _classCheckPrivateStaticAccess(e, t) {
            if (e !== t) throw new TypeError('Private static access of wrong provenance')
          })(e, t)
          return i
        }
        const l = 1e3
        const c = new WeakSet()
        function getRectDims(e) {
          return { width: e[2] - e[0], height: e[3] - e[1] }
        }
        class AnnotationElementFactory {
          static create(e) {
            switch (e.data.annotationType) {
              case n.AnnotationType.LINK:
                return new LinkAnnotationElement(e)
              case n.AnnotationType.TEXT:
                return new TextAnnotationElement(e)
              case n.AnnotationType.WIDGET:
                switch (e.data.fieldType) {
                  case 'Tx':
                    return new TextWidgetAnnotationElement(e)
                  case 'Btn':
                    return e.data.radioButton
                      ? new RadioButtonWidgetAnnotationElement(e)
                      : e.data.checkBox
                      ? new CheckboxWidgetAnnotationElement(e)
                      : new PushButtonWidgetAnnotationElement(e)
                  case 'Ch':
                    return new ChoiceWidgetAnnotationElement(e)
                  case 'Sig':
                    e.data.dest = parent.document
                    return new SigWidgetAnnotationElement(e)
                }
                return new WidgetAnnotationElement(e)
              case n.AnnotationType.POPUP:
                return new PopupAnnotationElement(e)
              case n.AnnotationType.FREETEXT:
                return new FreeTextAnnotationElement(e)
              case n.AnnotationType.LINE:
                return new LineAnnotationElement(e)
              case n.AnnotationType.SQUARE:
                return new SquareAnnotationElement(e)
              case n.AnnotationType.CIRCLE:
                return new CircleAnnotationElement(e)
              case n.AnnotationType.POLYLINE:
                return new PolylineAnnotationElement(e)
              case n.AnnotationType.CARET:
                return new CaretAnnotationElement(e)
              case n.AnnotationType.INK:
                return new InkAnnotationElement(e)
              case n.AnnotationType.POLYGON:
                return new PolygonAnnotationElement(e)
              case n.AnnotationType.HIGHLIGHT:
                return new HighlightAnnotationElement(e)
              case n.AnnotationType.UNDERLINE:
                return new UnderlineAnnotationElement(e)
              case n.AnnotationType.SQUIGGLY:
                return new SquigglyAnnotationElement(e)
              case n.AnnotationType.STRIKEOUT:
                return new StrikeOutAnnotationElement(e)
              case n.AnnotationType.STAMP:
                return new StampAnnotationElement(e)
              case n.AnnotationType.FILEATTACHMENT:
                return new FileAttachmentAnnotationElement(e)
              default:
                return new AnnotationElement(e)
            }
          }
        }
        class AnnotationElement {
          constructor(e) {
            const {
              isRenderable: t = !1,
              ignoreBorder: i = !1,
              createQuadrilaterals: n = !1
            } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
            this.isRenderable = t
            this.data = e.data
            this.layer = e.layer
            this.page = e.page
            this.viewport = e.viewport
            this.linkService = e.linkService
            this.downloadManager = e.downloadManager
            this.imageResourcesPath = e.imageResourcesPath
            this.renderForms = e.renderForms
            this.svgFactory = e.svgFactory
            this.annotationStorage = e.annotationStorage
            this.enableScripting = e.enableScripting
            this.hasJSActions = e.hasJSActions
            this._fieldObjects = e.fieldObjects
            this._mouseState = e.mouseState
            t && (this.container = this._createContainer(i))
            n && (this.quadrilaterals = this._createQuadrilaterals(i))
          }

          _createContainer() {
            const e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
            const t = this.data
            const i = this.page
            const s = this.viewport
            const a = document.createElement('section')
            const { width: r, height: o } = getRectDims(t.rect)
            const [l, c, d, h] = s.viewBox
            const u = d - l
            const p = h - c
            a.setAttribute('data-annotation-id', t.id)
            const g = n.Util.normalizeRect([
              t.rect[0],
              i.view[3] - t.rect[1] + i.view[1],
              t.rect[2],
              i.view[3] - t.rect[3] + i.view[1]
            ])
            if (!e && t.borderStyle.width > 0) {
              a.style.borderWidth = `${t.borderStyle.width}px`
              const e = t.borderStyle.horizontalCornerRadius
              const i = t.borderStyle.verticalCornerRadius
              if (e > 0 || i > 0) {
                const t = `calc(${e}px * var(--scale-factor)) / calc(${i}px * var(--scale-factor))`
                a.style.borderRadius = t
              } else if (this instanceof RadioButtonWidgetAnnotationElement) {
                const e = `calc(${r}px * var(--scale-factor)) / calc(${o}px * var(--scale-factor))`
                a.style.borderRadius = e
              }
              switch (t.borderStyle.style) {
                case n.AnnotationBorderStyleType.SOLID:
                  a.style.borderStyle = 'solid'
                  break
                case n.AnnotationBorderStyleType.DASHED:
                  a.style.borderStyle = 'dashed'
                  break
                case n.AnnotationBorderStyleType.BEVELED:
                  ;(0, n.warn)('Unimplemented border style: beveled')
                  break
                case n.AnnotationBorderStyleType.INSET:
                  ;(0, n.warn)('Unimplemented border style: inset')
                  break
                case n.AnnotationBorderStyleType.UNDERLINE:
                  a.style.borderBottomStyle = 'solid'
              }
              const s = t.borderColor || null
              s
                ? (a.style.borderColor = n.Util.makeHexColor(0 | s[0], 0 | s[1], 0 | s[2]))
                : (a.style.borderWidth = 0)
            }
            a.style.left = `${(100 * (g[0] - l)) / u}%`
            a.style.top = `${(100 * (g[1] - c)) / p}%`
            const { rotation: f } = t
            if (t.hasOwnCanvas || f === 0) {
              a.style.width = `${(100 * r) / u}%`
              a.style.height = `${(100 * o) / p}%`
            } else this.setRotation(f, a)
            return a
          }

          setRotation(e) {
            const t =
              arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.container
            const [i, n, s, a] = this.viewport.viewBox
            const r = s - i
            const o = a - n
            const { width: l, height: c } = getRectDims(this.data.rect)
            let d
            let h
            if (e % 180 == 0) {
              d = (100 * l) / r
              h = (100 * c) / o
            } else {
              d = (100 * c) / r
              h = (100 * l) / o
            }
            t.style.width = `${d}%`
            t.style.height = `${h}%`
            t.setAttribute('data-main-rotation', (360 - e) % 360)
          }

          get _commonActions() {
            const setColor = (e, t, i) => {
              const n = i.detail[e]
              i.target.style[t] = r.ColorConverters[`${n[0]}_HTML`](n.slice(1))
            }
            return (0, n.shadow)(this, '_commonActions', {
              display: (e) => {
                const t = e.detail.display % 2 == 1
                this.container.style.visibility = t ? 'hidden' : 'visible'
                this.annotationStorage.setValue(this.data.id, {
                  hidden: t,
                  print: e.detail.display === 0 || e.detail.display === 3
                })
              },
              print: (e) => {
                this.annotationStorage.setValue(this.data.id, { print: e.detail.print })
              },
              hidden: (e) => {
                this.container.style.visibility = e.detail.hidden ? 'hidden' : 'visible'
                this.annotationStorage.setValue(this.data.id, { hidden: e.detail.hidden })
              },
              focus: (e) => {
                setTimeout(() => e.target.focus({ preventScroll: !1 }), 0)
              },
              userName: (e) => {
                e.target.title = e.detail.userName
              },
              readonly: (e) => {
                e.detail.readonly
                  ? e.target.setAttribute('readonly', '')
                  : e.target.removeAttribute('readonly')
              },
              required: (e) => {
                this._setRequired(e.target, e.detail.required)
              },
              bgColor: (e) => {
                setColor('bgColor', 'backgroundColor', e)
              },
              fillColor: (e) => {
                setColor('fillColor', 'backgroundColor', e)
              },
              fgColor: (e) => {
                setColor('fgColor', 'color', e)
              },
              textColor: (e) => {
                setColor('textColor', 'color', e)
              },
              borderColor: (e) => {
                setColor('borderColor', 'borderColor', e)
              },
              strokeColor: (e) => {
                setColor('strokeColor', 'borderColor', e)
              },
              rotation: (e) => {
                const t = e.detail.rotation
                this.setRotation(t)
                this.annotationStorage.setValue(this.data.id, { rotation: t })
              }
            })
          }

          _dispatchEventFromSandbox(e, t) {
            const i = this._commonActions
            for (const n of Object.keys(t.detail)) {
              const s = e[n] || i[n]
              s && s(t)
            }
          }

          _setDefaultPropertiesFromJS(e) {
            if (!this.enableScripting) return
            const t = this.annotationStorage.getRawValue(this.data.id)
            if (!t) return
            const i = this._commonActions
            for (const [n, s] of Object.entries(t)) {
              const a = i[n]
              if (a) {
                a({ detail: { [n]: s }, target: e })
                delete t[n]
              }
            }
          }

          _createQuadrilaterals() {
            const e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
            if (!this.data.quadPoints) return null
            const t = []
            const i = this.data.rect
            for (const i of this.data.quadPoints) {
              this.data.rect = [i[2].x, i[2].y, i[1].x, i[1].y]
              t.push(this._createContainer(e))
            }
            this.data.rect = i
            return t
          }

          _createPopup(e, t) {
            let i = this.container
            if (this.quadrilaterals) {
              e = e || this.quadrilaterals
              i = this.quadrilaterals[0]
            }
            if (!e) {
              ;(e = document.createElement('div')).className = 'popupTriggerArea'
              i.append(e)
            }
            const n = new PopupElement({
              container: i,
              trigger: e,
              color: t.color,
              titleObj: t.titleObj,
              modificationDate: t.modificationDate,
              contentsObj: t.contentsObj,
              richText: t.richText,
              hideWrapper: !0
            }).render()
            n.style.left = '100%'
            i.append(n)
          }

          _renderQuadrilaterals(e) {
            for (const t of this.quadrilaterals) t.className = e
            return this.quadrilaterals
          }

          render() {
            ;(0, n.unreachable)('Abstract method `AnnotationElement.render` called')
          }

          _getElementsByName(e) {
            const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
            const i = []
            if (this._fieldObjects) {
              const s = this._fieldObjects[e]
              if (s)
                for (const { page: e, id: a, exportValues: r } of s) {
                  if (e === -1) continue
                  if (a === t) continue
                  const s = typeof r === 'string' ? r : null
                  const o = document.querySelector(`[data-element-id="${a}"]`)
                  !o || c.has(o)
                    ? i.push({ id: a, exportValue: s, domElement: o })
                    : (0, n.warn)(`_getElementsByName - element not allowed: ${a}`)
                }
              return i
            }
            for (const n of document.getElementsByName(e)) {
              const { id: e, exportValue: s } = n
              e !== t && c.has(n) && i.push({ id: e, exportValue: s, domElement: n })
            }
            return i
          }

          static get platform() {
            const e = typeof navigator !== 'undefined' ? navigator.platform : ''
            return (0, n.shadow)(this, 'platform', {
              isWin: e.includes('Win'),
              isMac: e.includes('Mac')
            })
          }
        }
        class LinkAnnotationElement extends AnnotationElement {
          constructor(e) {
            const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
            super(e, {
              isRenderable: !0,
              ignoreBorder: !(t == null || !t.ignoreBorder),
              createQuadrilaterals: !0
            })
            this.isTooltipOnly = e.data.isTooltipOnly
          }

          render() {
            const { data: e, linkService: t } = this
            const i = document.createElement('a')
            i.setAttribute('data-element-id', e.id)
            let n = !1
            if (e.url) {
              t.addLinkAttributes(i, e.url, e.newWindow)
              n = !0
            } else if (e.action) {
              this._bindNamedAction(i, e.action)
              n = !0
            } else if (e.dest) {
              this._bindLink(i, e.dest)
              n = !0
            } else {
              if (
                e.actions &&
                (e.actions.Action || e.actions['Mouse Up'] || e.actions['Mouse Down']) &&
                this.enableScripting &&
                this.hasJSActions
              ) {
                this._bindJSAction(i, e)
                n = !0
              }
              if (e.resetForm) {
                this._bindResetFormAction(i, e.resetForm)
                n = !0
              } else if (this.isTooltipOnly && !n) {
                this._bindLink(i, '')
                n = !0
              }
            }
            if (this.quadrilaterals)
              return this._renderQuadrilaterals('linkAnnotation').map((e, t) => {
                const n = t === 0 ? i : i.cloneNode()
                e.append(n)
                return e
              })
            this.container.className = 'linkAnnotation'
            n && this.container.append(i)
            return this.container
          }

          _bindLink(e, t) {
            e.href = this.linkService.getDestinationHash(t)
            e.onclick = () => {
              t && this.linkService.goToDestination(t)
              return !1
            }
            ;(t || t === '') && (e.className = 'internalLink')
          }

          _bindNamedAction(e, t) {
            e.href = this.linkService.getAnchorUrl('')
            e.onclick = () => {
              this.linkService.executeNamedAction(t)
              return !1
            }
            e.className = 'internalLink'
          }

          _bindJSAction(e, t) {
            e.href = this.linkService.getAnchorUrl('')
            const i = new Map([
              ['Action', 'onclick'],
              ['Mouse Up', 'onmouseup'],
              ['Mouse Down', 'onmousedown']
            ])
            for (const n of Object.keys(t.actions)) {
              const s = i.get(n)
              s &&
                (e[s] = () => {
                  let e
                  ;(e = this.linkService.eventBus) === null ||
                    void 0 === e ||
                    e.dispatch('dispatcheventinsandbox', {
                      source: this,
                      detail: { id: t.id, name: n }
                    })
                  return !1
                })
            }
            e.onclick || (e.onclick = () => !1)
            e.className = 'internalLink'
          }

          _bindResetFormAction(e, t) {
            const i = e.onclick
            i || (e.href = this.linkService.getAnchorUrl(''))
            e.className = 'internalLink'
            if (this._fieldObjects)
              e.onclick = () => {
                i && i()
                const { fields: e, refs: s, include: a } = t
                const r = []
                if (e.length !== 0 || s.length !== 0) {
                  const t = new Set(s)
                  for (const i of e) {
                    const e = this._fieldObjects[i] || []
                    for (const { id: i } of e) t.add(i)
                  }
                  for (const e of Object.values(this._fieldObjects))
                    for (const i of e) t.has(i.id) === a && r.push(i)
                } else for (const e of Object.values(this._fieldObjects)) r.push(...e)
                const o = this.annotationStorage
                const l = []
                for (const e of r) {
                  const { id: t } = e
                  l.push(t)
                  switch (e.type) {
                    case 'text': {
                      const i = e.defaultValue || ''
                      o.setValue(t, { value: i })
                      break
                    }
                    case 'checkbox':
                    case 'radiobutton': {
                      const i = e.defaultValue === e.exportValues
                      o.setValue(t, { value: i })
                      break
                    }
                    case 'combobox':
                    case 'listbox': {
                      const i = e.defaultValue || ''
                      o.setValue(t, { value: i })
                      break
                    }
                    default:
                      continue
                  }
                  const i = document.querySelector(`[data-element-id="${t}"]`)
                  i &&
                    (c.has(i)
                      ? i.dispatchEvent(new Event('resetform'))
                      : (0, n.warn)(`_bindResetFormAction - element not allowed: ${t}`))
                }
                if (this.enableScripting) {
                  let d
                  ;(d = this.linkService.eventBus) === null ||
                    void 0 === d ||
                    d.dispatch('dispatcheventinsandbox', {
                      source: this,
                      detail: { id: 'app', ids: l, name: 'ResetForm' }
                    })
                }
                return !1
              }
            else {
              ;(0, n.warn)(
                '_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.'
              )
              i || (e.onclick = () => !1)
            }
          }
        }
        class TextAnnotationElement extends AnnotationElement {
          constructor(e) {
            let t
            let i
            let n
            super(e, {
              isRenderable: !!(
                e.data.hasPopup ||
                ((t = e.data.titleObj) !== null && void 0 !== t && t.str) ||
                ((i = e.data.contentsObj) !== null && void 0 !== i && i.str) ||
                ((n = e.data.richText) !== null && void 0 !== n && n.str)
              )
            })
          }

          render() {
            this.container.className = 'textAnnotation'
            const e = document.createElement('img')
            e.src = `${this.imageResourcesPath}annotation-${this.data.name.toLowerCase()}.svg`
            e.alt = '[{{type}} Annotation]'
            e.dataset.l10nId = 'text_annotation_type'
            e.dataset.l10nArgs = JSON.stringify({ type: this.data.name })
            this.data.hasPopup || this._createPopup(e, this.data)
            this.container.append(e)
            return this.container
          }
        }
        class WidgetAnnotationElement extends AnnotationElement {
          render() {
            this.data.alternativeText && (this.container.title = this.data.alternativeText)
            return this.container
          }

          _getKeyModifier(e) {
            const { isWin: t, isMac: i } = AnnotationElement.platform
            return (t && e.ctrlKey) || (i && e.metaKey)
          }

          _setEventListener(e, t, i, n) {
            t.includes('mouse')
              ? e.addEventListener(t, (e) => {
                  let t
                  ;(t = this.linkService.eventBus) === null ||
                    void 0 === t ||
                    t.dispatch('dispatcheventinsandbox', {
                      source: this,
                      detail: {
                        id: this.data.id,
                        name: i,
                        value: n(e),
                        shift: e.shiftKey,
                        modifier: this._getKeyModifier(e)
                      }
                    })
                })
              : e.addEventListener(t, (e) => {
                  let t
                  ;(t = this.linkService.eventBus) === null ||
                    void 0 === t ||
                    t.dispatch('dispatcheventinsandbox', {
                      source: this,
                      detail: { id: this.data.id, name: i, value: n(e) }
                    })
                })
          }

          _setEventListeners(e, t, i) {
            for (const [s, a] of t) {
              var n
              ;(a === 'Action' || ((n = this.data.actions) !== null && void 0 !== n && n[a])) &&
                this._setEventListener(e, s, a, i)
            }
          }

          _setBackgroundColor(e) {
            const t = this.data.backgroundColor || null
            e.style.backgroundColor =
              t === null ? 'transparent' : n.Util.makeHexColor(t[0], t[1], t[2])
          }

          _setTextStyle(e) {
            const t = ['left', 'center', 'right']
            const { fontColor: i } = this.data.defaultAppearanceData
            const s = this.data.defaultAppearanceData.fontSize || 9
            const a = e.style
            let r
            if (this.data.multiLine) {
              const e = Math.abs(this.data.rect[3] - this.data.rect[1])
              const t = e / (Math.round(e / (n.LINE_FACTOR * s)) || 1)
              r = Math.min(s, Math.round(t / n.LINE_FACTOR))
            } else {
              const e = Math.abs(this.data.rect[3] - this.data.rect[1])
              r = Math.min(s, Math.round(e / n.LINE_FACTOR))
            }
            a.fontSize = `calc(${r}px * var(--scale-factor))`
            a.color = n.Util.makeHexColor(i[0], i[1], i[2])
            this.data.textAlignment !== null && (a.textAlign = t[this.data.textAlignment])
          }

          _setRequired(e, t) {
            t ? e.setAttribute('required', !0) : e.removeAttribute('required')
            e.setAttribute('aria-required', t)
          }
        }
        class TextWidgetAnnotationElement extends WidgetAnnotationElement {
          constructor(e) {
            super(e, {
              isRenderable: e.renderForms || (!e.data.hasAppearance && !!e.data.fieldValue)
            })
          }

          setPropertyOnSiblings(e, t, i, n) {
            const s = this.annotationStorage
            for (const a of this._getElementsByName(e.name, e.id)) {
              a.domElement && (a.domElement[t] = i)
              s.setValue(a.id, { [n]: i })
            }
          }

          render() {
            const e = this.annotationStorage
            const t = this.data.id
            this.container.className = 'textWidgetAnnotation'
            let i = null
            if (this.renderForms) {
              const s = e.getValue(t, { value: this.data.fieldValue })
              let a = s.formattedValue || s.value || ''
              const r = e.getValue(t, { charLimit: this.data.maxLen }).charLimit
              r && a.length > r && (a = a.slice(0, r))
              const o = { userValue: a, formattedValue: null, valueOnFocus: '' }
              if (this.data.multiLine) {
                i = document.createElement('textarea')
                i.textContent = a
                this.data.doNotScroll && (i.style.overflowY = 'hidden')
              } else {
                i = document.createElement('input')
                i.type = 'text'
                i.setAttribute('value', a)
                this.data.doNotScroll && (i.style.overflowX = 'hidden')
              }
              c.add(i)
              i.setAttribute('data-element-id', t)
              i.disabled = this.data.readOnly
              i.name = this.data.fieldName
              i.tabIndex = l
              this._setRequired(i, this.data.required)
              r && (i.maxLength = r)
              i.addEventListener('input', (n) => {
                e.setValue(t, { value: n.target.value })
                this.setPropertyOnSiblings(i, 'value', n.target.value, 'value')
              })
              i.addEventListener('resetform', (e) => {
                let t
                const n = (t = this.data.defaultFieldValue) !== null && void 0 !== t ? t : ''
                i.value = o.userValue = n
                o.formattedValue = null
              })
              let blurListener = (e) => {
                const { formattedValue: t } = o
                t != null && (e.target.value = t)
                e.target.scrollLeft = 0
              }
              if (this.enableScripting && this.hasJSActions) {
                let n
                i.addEventListener('focus', (e) => {
                  o.userValue && (e.target.value = o.userValue)
                  o.valueOnFocus = e.target.value
                })
                i.addEventListener('updatefromsandbox', (i) => {
                  const n = {
                    value(i) {
                      let n
                      o.userValue = (n = i.detail.value) !== null && void 0 !== n ? n : ''
                      e.setValue(t, { value: o.userValue.toString() })
                      i.target.value = o.userValue
                    },
                    formattedValue(i) {
                      const { formattedValue: n } = i.detail
                      o.formattedValue = n
                      n != null && i.target !== document.activeElement && (i.target.value = n)
                      e.setValue(t, { formattedValue: n })
                    },
                    selRange(e) {
                      e.target.setSelectionRange(...e.detail.selRange)
                    },
                    charLimit: (i) => {
                      let n
                      const { charLimit: s } = i.detail
                      const { target: a } = i
                      if (s === 0) {
                        a.removeAttribute('maxLength')
                        return
                      }
                      a.setAttribute('maxLength', s)
                      let r = o.userValue
                      if (r && !(r.length <= s)) {
                        r = r.slice(0, s)
                        a.value = o.userValue = r
                        e.setValue(t, { value: r })((n = this.linkService.eventBus)) === null ||
                          void 0 === n ||
                          n.dispatch('dispatcheventinsandbox', {
                            source: this,
                            detail: {
                              id: t,
                              name: 'Keystroke',
                              value: r,
                              willCommit: !0,
                              commitKey: 1,
                              selStart: a.selectionStart,
                              selEnd: a.selectionEnd
                            }
                          })
                      }
                    }
                  }
                  this._dispatchEventFromSandbox(n, i)
                })
                i.addEventListener('keydown', (e) => {
                  let i
                  let n = -1
                  e.key === 'Escape'
                    ? (n = 0)
                    : e.key === 'Enter'
                    ? (n = 2)
                    : e.key === 'Tab' && (n = 3)
                  if (n === -1) return
                  const { value: s } = e.target
                  if (o.valueOnFocus !== s) {
                    o.userValue =
                      s((i = this.linkService.eventBus)) === null ||
                      void 0 === i ||
                      i.dispatch('dispatcheventinsandbox', {
                        source: this,
                        detail: {
                          id: t,
                          name: 'Keystroke',
                          value: s,
                          willCommit: !0,
                          commitKey: n,
                          selStart: e.target.selectionStart,
                          selEnd: e.target.selectionEnd
                        }
                      })
                  }
                })
                const s = blurListener
                blurListener = null
                i.addEventListener('blur', (e) => {
                  const { value: i } = e.target
                  o.userValue = i
                  if (this._mouseState.isDown && o.valueOnFocus !== i) {
                    let n
                    ;(n = this.linkService.eventBus) === null ||
                      void 0 === n ||
                      n.dispatch('dispatcheventinsandbox', {
                        source: this,
                        detail: {
                          id: t,
                          name: 'Keystroke',
                          value: i,
                          willCommit: !0,
                          commitKey: 1,
                          selStart: e.target.selectionStart,
                          selEnd: e.target.selectionEnd
                        }
                      })
                  }
                  s(e)
                })((n = this.data.actions)) !== null &&
                  void 0 !== n &&
                  n.Keystroke &&
                  i.addEventListener('beforeinput', (e) => {
                    let i
                    const { data: n, target: s } = e
                    const { value: a, selectionStart: r, selectionEnd: o } = s
                    let l = r
                    let c = o
                    switch (e.inputType) {
                      case 'deleteWordBackward': {
                        const e = a.substring(0, r).match(/\w*[^\w]*$/)
                        e && (l -= e[0].length)
                        break
                      }
                      case 'deleteWordForward': {
                        const e = a.substring(r).match(/^[^\w]*\w*/)
                        e && (c += e[0].length)
                        break
                      }
                      case 'deleteContentBackward':
                        r === o && (l -= 1)
                        break
                      case 'deleteContentForward':
                        r === o && (c += 1)
                    }
                    e.preventDefault()((i = this.linkService.eventBus)) === null ||
                      void 0 === i ||
                      i.dispatch('dispatcheventinsandbox', {
                        source: this,
                        detail: {
                          id: t,
                          name: 'Keystroke',
                          value: a,
                          change: n || '',
                          willCommit: !1,
                          selStart: l,
                          selEnd: c
                        }
                      })
                  })
                this._setEventListeners(
                  i,
                  [
                    ['focus', 'Focus'],
                    ['blur', 'Blur'],
                    ['mousedown', 'Mouse Down'],
                    ['mouseenter', 'Mouse Enter'],
                    ['mouseleave', 'Mouse Exit'],
                    ['mouseup', 'Mouse Up']
                  ],
                  (e) => e.target.value
                )
              }
              blurListener && i.addEventListener('blur', blurListener)
              if (this.data.comb) {
                const e = (this.data.rect[2] - this.data.rect[0]) / r
                i.classList.add('comb')
                i.style.letterSpacing = `calc(${e}px * var(--scale-factor) - 1ch)`
              }
            } else {
              i = document.createElement('div')
              i.textContent = this.data.fieldValue
              i.style.verticalAlign = 'middle'
              i.style.display = 'table-cell'
            }
            this._setTextStyle(i)
            this._setBackgroundColor(i)
            this._setDefaultPropertiesFromJS(i)
            this.container.append(i)
            return this.container
          }
        }
        class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
          constructor(e) {
            super(e, { isRenderable: e.renderForms })
          }

          render() {
            const e = this.annotationStorage
            const t = this.data
            const i = t.id
            let n = e.getValue(i, { value: t.exportValue === t.fieldValue }).value
            if (typeof n === 'string') {
              n = n !== 'Off'
              e.setValue(i, { value: n })
            }
            this.container.className = 'buttonWidgetAnnotation checkBox'
            const s = document.createElement('input')
            c.add(s)
            s.setAttribute('data-element-id', i)
            s.disabled = t.readOnly
            this._setRequired(s, this.data.required)
            s.type = 'checkbox'
            s.name = t.fieldName
            n && s.setAttribute('checked', !0)
            s.setAttribute('exportValue', t.exportValue)
            s.tabIndex = l
            s.addEventListener('change', (n) => {
              const { name: s, checked: a } = n.target
              for (const n of this._getElementsByName(s, i)) {
                const i = a && n.exportValue === t.exportValue
                n.domElement && (n.domElement.checked = i)
                e.setValue(n.id, { value: i })
              }
              e.setValue(i, { value: a })
            })
            s.addEventListener('resetform', (e) => {
              const i = t.defaultFieldValue || 'Off'
              e.target.checked = i === t.exportValue
            })
            if (this.enableScripting && this.hasJSActions) {
              s.addEventListener('updatefromsandbox', (t) => {
                const n = {
                  value(t) {
                    t.target.checked = t.detail.value !== 'Off'
                    e.setValue(i, { value: t.target.checked })
                  }
                }
                this._dispatchEventFromSandbox(n, t)
              })
              this._setEventListeners(
                s,
                [
                  ['change', 'Validate'],
                  ['change', 'Action'],
                  ['focus', 'Focus'],
                  ['blur', 'Blur'],
                  ['mousedown', 'Mouse Down'],
                  ['mouseenter', 'Mouse Enter'],
                  ['mouseleave', 'Mouse Exit'],
                  ['mouseup', 'Mouse Up']
                ],
                (e) => e.target.checked
              )
            }
            this._setBackgroundColor(s)
            this._setDefaultPropertiesFromJS(s)
            this.container.append(s)
            return this.container
          }
        }
        class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
          constructor(e) {
            super(e, { isRenderable: e.renderForms })
          }

          render() {
            this.container.className = 'buttonWidgetAnnotation radioButton'
            const e = this.annotationStorage
            const t = this.data
            const i = t.id
            let n = e.getValue(i, { value: t.fieldValue === t.buttonValue }).value
            if (typeof n === 'string') {
              n = n !== t.buttonValue
              e.setValue(i, { value: n })
            }
            const s = document.createElement('input')
            c.add(s)
            s.setAttribute('data-element-id', i)
            s.disabled = t.readOnly
            this._setRequired(s, this.data.required)
            s.type = 'radio'
            s.name = t.fieldName
            n && s.setAttribute('checked', !0)
            s.tabIndex = l
            s.addEventListener('change', (t) => {
              const { name: n, checked: s } = t.target
              for (const t of this._getElementsByName(n, i)) e.setValue(t.id, { value: !1 })
              e.setValue(i, { value: s })
            })
            s.addEventListener('resetform', (e) => {
              const i = t.defaultFieldValue
              e.target.checked = i != null && i === t.buttonValue
            })
            if (this.enableScripting && this.hasJSActions) {
              const n = t.buttonValue
              s.addEventListener('updatefromsandbox', (t) => {
                const s = {
                  value: (t) => {
                    const s = n === t.detail.value
                    for (const n of this._getElementsByName(t.target.name)) {
                      const t = s && n.id === i
                      n.domElement && (n.domElement.checked = t)
                      e.setValue(n.id, { value: t })
                    }
                  }
                }
                this._dispatchEventFromSandbox(s, t)
              })
              this._setEventListeners(
                s,
                [
                  ['change', 'Validate'],
                  ['change', 'Action'],
                  ['focus', 'Focus'],
                  ['blur', 'Blur'],
                  ['mousedown', 'Mouse Down'],
                  ['mouseenter', 'Mouse Enter'],
                  ['mouseleave', 'Mouse Exit'],
                  ['mouseup', 'Mouse Up']
                ],
                (e) => e.target.checked
              )
            }
            this._setBackgroundColor(s)
            this._setDefaultPropertiesFromJS(s)
            this.container.append(s)
            return this.container
          }
        }
        class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
          constructor(e) {
            super(e, { ignoreBorder: e.data.hasAppearance })
          }

          render() {
            const e = super.render()
            e.className = 'buttonWidgetAnnotation pushButton'
            this.data.alternativeText && (e.title = this.data.alternativeText)
            const t = e.lastChild
            if (this.enableScripting && this.hasJSActions && t) {
              this._setDefaultPropertiesFromJS(t)
              t.addEventListener('updatefromsandbox', (e) => {
                this._dispatchEventFromSandbox({}, e)
              })
            }
            return e
          }
        }
        class SigWidgetAnnotationElement extends LinkAnnotationElement {
          render() {
            const e = super.render()
            e.className = 'sigWidgetAnnotation'
            return e
          }

          _bindLink(e, t) {
            e.href = ''
            e.name = this.data.fieldName
            this.data.subtype === 'Widget'
              ? e.setAttribute('alg', 'RSA')
              : e.setAttribute('alg', 'SM2')
            e.onclick = () => {
              !(function dispatchCustomEvent(e, t, i) {
                const n = document.createEvent('CustomEvent')
                n.initCustomEvent(e, !0, !0, t)
                i.dispatchEvent(n)
              })(
                'clickSignature',
                {
                  pageIndex: this.page._pageIndex + 1,
                  rect: this.data.rect,
                  fieldName: this.data.fieldName,
                  alg: e.getAttribute('alg')
                },
                t
              )
              return !1
            }
            t && (e.className = 'internalLink')
          }

          _bindNamedAction(e, t) {
            e.href = this.linkService.getAnchorUrl('')
            e.onclick = () => {
              this.linkService.executeNamedAction(t)
              return !1
            }
            e.className = 'internalLink'
          }
        }
        class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
          constructor(e) {
            super(e, { isRenderable: e.renderForms })
          }

          render() {
            this.container.className = 'choiceWidgetAnnotation'
            const e = this.annotationStorage
            const t = this.data.id
            const i = e.getValue(t, { value: this.data.fieldValue })
            const n = document.createElement('select')
            c.add(n)
            n.setAttribute('data-element-id', t)
            n.disabled = this.data.readOnly
            this._setRequired(n, this.data.required)
            n.name = this.data.fieldName
            n.tabIndex = l
            let s = this.data.combo && this.data.options.length > 0
            if (!this.data.combo) {
              n.size = this.data.options.length
              this.data.multiSelect && (n.multiple = !0)
            }
            n.addEventListener('resetform', (e) => {
              const t = this.data.defaultFieldValue
              for (const e of n.options) e.selected = e.value === t
            })
            for (const e of this.data.options) {
              const t = document.createElement('option')
              t.textContent = e.displayValue
              t.value = e.exportValue
              if (i.value.includes(e.exportValue)) {
                t.setAttribute('selected', !0)
                s = !1
              }
              n.append(t)
            }
            let a = null
            if (s) {
              const e = document.createElement('option')
              e.value = ' '
              e.setAttribute('hidden', !0)
              e.setAttribute('selected', !0)
              n.prepend(e)
              a = () => {
                e.remove()
                n.removeEventListener('input', a)
                a = null
              }
              n.addEventListener('input', a)
            }
            const getValue = (e, t) => {
              const i = t ? 'value' : 'textContent'
              const n = e.target.options
              return e.target.multiple
                ? Array.prototype.filter.call(n, (e) => e.selected).map((e) => e[i])
                : n.selectedIndex === -1
                ? null
                : n[n.selectedIndex][i]
            }
            const getItems = (e) => {
              const t = e.target.options
              return Array.prototype.map.call(t, (e) => ({
                displayValue: e.textContent,
                exportValue: e.value
              }))
            }
            if (this.enableScripting && this.hasJSActions) {
              n.addEventListener('updatefromsandbox', (i) => {
                const s = {
                  value(i) {
                    let s
                    ;(s = a) === null || void 0 === s || s()
                    const r = i.detail.value
                    const o = new Set(Array.isArray(r) ? r : [r])
                    for (const e of n.options) e.selected = o.has(e.value)
                    e.setValue(t, { value: getValue(i, !0) })
                  },
                  multipleSelection(e) {
                    n.multiple = !0
                  },
                  remove(i) {
                    const s = n.options
                    const a = i.detail.remove
                    s[a].selected = !1
                    n.remove(a)
                    if (s.length > 0) {
                      Array.prototype.findIndex.call(s, (e) => e.selected) === -1 &&
                        (s[0].selected = !0)
                    }
                    e.setValue(t, { value: getValue(i, !0), items: getItems(i) })
                  },
                  clear(i) {
                    for (; n.length !== 0; ) n.remove(0)
                    e.setValue(t, { value: null, items: [] })
                  },
                  insert(i) {
                    const { index: s, displayValue: a, exportValue: r } = i.detail.insert
                    const o = n.children[s]
                    const l = document.createElement('option')
                    l.textContent = a
                    l.value = r
                    o ? o.before(l) : n.append(l)
                    e.setValue(t, { value: getValue(i, !0), items: getItems(i) })
                  },
                  items(i) {
                    const { items: s } = i.detail
                    for (; n.length !== 0; ) n.remove(0)
                    for (const e of s) {
                      const { displayValue: t, exportValue: i } = e
                      const s = document.createElement('option')
                      s.textContent = t
                      s.value = i
                      n.append(s)
                    }
                    n.options.length > 0 && (n.options[0].selected = !0)
                    e.setValue(t, { value: getValue(i, !0), items: getItems(i) })
                  },
                  indices(i) {
                    const n = new Set(i.detail.indices)
                    for (const e of i.target.options) e.selected = n.has(e.index)
                    e.setValue(t, { value: getValue(i, !0) })
                  },
                  editable(e) {
                    e.target.disabled = !e.detail.editable
                  }
                }
                this._dispatchEventFromSandbox(s, i)
              })
              n.addEventListener('input', (i) => {
                let n
                const s = getValue(i, !0)
                const a = getValue(i, !1)
                e.setValue(t, { value: s })((n = this.linkService.eventBus)) === null ||
                  void 0 === n ||
                  n.dispatch('dispatcheventinsandbox', {
                    source: this,
                    detail: {
                      id: t,
                      name: 'Keystroke',
                      value: a,
                      changeEx: s,
                      willCommit: !0,
                      commitKey: 1,
                      keyDown: !1
                    }
                  })
              })
              this._setEventListeners(
                n,
                [
                  ['focus', 'Focus'],
                  ['blur', 'Blur'],
                  ['mousedown', 'Mouse Down'],
                  ['mouseenter', 'Mouse Enter'],
                  ['mouseleave', 'Mouse Exit'],
                  ['mouseup', 'Mouse Up'],
                  ['input', 'Action']
                ],
                (e) => e.target.checked
              )
            } else
              n.addEventListener('input', function (i) {
                e.setValue(t, { value: getValue(i, !0) })
              })
            this.data.combo && this._setTextStyle(n)
            this._setBackgroundColor(n)
            this._setDefaultPropertiesFromJS(n)
            this.container.append(n)
            return this.container
          }
        }
        class PopupAnnotationElement extends AnnotationElement {
          constructor(e) {
            let t
            let i
            let n
            super(e, {
              isRenderable: !!(
                ((t = e.data.titleObj) !== null && void 0 !== t && t.str) ||
                ((i = e.data.contentsObj) !== null && void 0 !== i && i.str) ||
                ((n = e.data.richText) !== null && void 0 !== n && n.str)
              )
            })
          }

          render() {
            this.container.className = 'popupAnnotation'
            if (
              ['Line', 'Square', 'Circle', 'PolyLine', 'Polygon', 'Ink'].includes(
                this.data.parentType
              )
            )
              return this.container
            const e = `[data-annotation-id="${this.data.parentId}"]`
            const t = this.layer.querySelectorAll(e)
            if (t.length === 0) return this.container
            const i = new PopupElement({
              container: this.container,
              trigger: Array.from(t),
              color: this.data.color,
              titleObj: this.data.titleObj,
              modificationDate: this.data.modificationDate,
              contentsObj: this.data.contentsObj,
              richText: this.data.richText
            })
            const s = this.page
            const a = n.Util.normalizeRect([
              this.data.parentRect[0],
              s.view[3] - this.data.parentRect[1] + s.view[1],
              this.data.parentRect[2],
              s.view[3] - this.data.parentRect[3] + s.view[1]
            ])
            const r = a[0] + this.data.parentRect[2] - this.data.parentRect[0]
            const o = a[1]
            const [l, c, d, h] = this.viewport.viewBox
            const u = d - l
            const p = h - c
            this.container.style.left = `${(100 * (r - l)) / u}%`
            this.container.style.top = `${(100 * (o - c)) / p}%`
            this.container.append(i.render())
            return this.container
          }
        }
        class PopupElement {
          constructor(e) {
            this.container = e.container
            this.trigger = e.trigger
            this.color = e.color
            this.titleObj = e.titleObj
            this.modificationDate = e.modificationDate
            this.contentsObj = e.contentsObj
            this.richText = e.richText
            this.hideWrapper = e.hideWrapper || !1
            this.pinned = !1
          }

          render() {
            let e
            let t
            const i = document.createElement('div')
            i.className = 'popupWrapper'
            this.hideElement = this.hideWrapper ? i : this.container
            this.hideElement.hidden = !0
            const a = document.createElement('div')
            a.className = 'popup'
            const r = this.color
            if (r) {
              const e = 0.7 * (255 - r[0]) + r[0]
              const t = 0.7 * (255 - r[1]) + r[1]
              const i = 0.7 * (255 - r[2]) + r[2]
              a.style.backgroundColor = n.Util.makeHexColor(0 | e, 0 | t, 0 | i)
            }
            const l = document.createElement('h1')
            l.dir = this.titleObj.dir
            l.textContent = this.titleObj.str
            a.append(l)
            const c = s.PDFDateString.toDateObject(this.modificationDate)
            if (c) {
              const e = document.createElement('span')
              e.className = 'popupDate'
              e.textContent = '{{date}}, {{time}}'
              e.dataset.l10nId = 'annotation_date_string'
              e.dataset.l10nArgs = JSON.stringify({
                date: c.toLocaleDateString(),
                time: c.toLocaleTimeString()
              })
              a.append(e)
            }
            if (
              (e = this.richText) === null ||
              void 0 === e ||
              !e.str ||
              ((t = this.contentsObj) !== null &&
                void 0 !== t &&
                t.str &&
                this.contentsObj.str !== this.richText.str)
            ) {
              const e = this._formatContents(this.contentsObj)
              a.append(e)
            } else {
              o.XfaLayer.render({ xfaHtml: this.richText.html, intent: 'richText', div: a })
              a.lastChild.className = 'richText popupContent'
            }
            Array.isArray(this.trigger) || (this.trigger = [this.trigger])
            for (const e of this.trigger) {
              e.addEventListener('click', this._toggle.bind(this))
              e.addEventListener('mouseover', this._show.bind(this, !1))
              e.addEventListener('mouseout', this._hide.bind(this, !1))
            }
            a.addEventListener('click', this._hide.bind(this, !0))
            i.append(a)
            return i
          }

          _formatContents(e) {
            const { str: t, dir: i } = e
            const n = document.createElement('p')
            n.className = 'popupContent'
            n.dir = i
            const s = t.split(/(?:\r\n?|\n)/)
            for (let e = 0, t = s.length; e < t; ++e) {
              const i = s[e]
              n.append(document.createTextNode(i))
              e < t - 1 && n.append(document.createElement('br'))
            }
            return n
          }

          _toggle() {
            this.pinned ? this._hide(!0) : this._show(!0)
          }

          _show() {
            arguments.length > 0 && void 0 !== arguments[0] && arguments[0] && (this.pinned = !0)
            if (this.hideElement.hidden) {
              this.hideElement.hidden = !1
              this.container.style.zIndex = parseInt(this.container.style.zIndex) + 1e3
            }
          }

          _hide() {
            ;(!(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]) &&
              (this.pinned = !1)
            if (!this.hideElement.hidden && !this.pinned) {
              this.hideElement.hidden = !0
              this.container.style.zIndex = parseInt(this.container.style.zIndex) - 1e3
            }
          }
        }
        class FreeTextAnnotationElement extends AnnotationElement {
          constructor(e) {
            let t
            let i
            let n
            super(e, {
              isRenderable: !!(
                e.data.hasPopup ||
                ((t = e.data.titleObj) !== null && void 0 !== t && t.str) ||
                ((i = e.data.contentsObj) !== null && void 0 !== i && i.str) ||
                ((n = e.data.richText) !== null && void 0 !== n && n.str)
              ),
              ignoreBorder: !0
            })
            this.textContent = e.data.textContent
          }

          render() {
            this.container.className = 'freeTextAnnotation'
            if (this.textContent) {
              const e = document.createElement('div')
              e.className = 'annotationTextContent'
              e.setAttribute('role', 'comment')
              for (const t of this.textContent) {
                const i = document.createElement('span')
                i.textContent = t
                e.append(i)
              }
              this.container.append(e)
            }
            this.data.hasPopup || this._createPopup(null, this.data)
            return this.container
          }
        }
        class LineAnnotationElement extends AnnotationElement {
          constructor(e) {
            let t
            let i
            let n
            super(e, {
              isRenderable: !!(
                e.data.hasPopup ||
                ((t = e.data.titleObj) !== null && void 0 !== t && t.str) ||
                ((i = e.data.contentsObj) !== null && void 0 !== i && i.str) ||
                ((n = e.data.richText) !== null && void 0 !== n && n.str)
              ),
              ignoreBorder: !0
            })
          }

          render() {
            this.container.className = 'lineAnnotation'
            const e = this.data
            const { width: t, height: i } = getRectDims(e.rect)
            const n = this.svgFactory.create(t, i, !0)
            const s = this.svgFactory.createElement('svg:line')
            s.setAttribute('x1', e.rect[2] - e.lineCoordinates[0])
            s.setAttribute('y1', e.rect[3] - e.lineCoordinates[1])
            s.setAttribute('x2', e.rect[2] - e.lineCoordinates[2])
            s.setAttribute('y2', e.rect[3] - e.lineCoordinates[3])
            s.setAttribute('stroke-width', e.borderStyle.width || 1)
            s.setAttribute('stroke', 'transparent')
            s.setAttribute('fill', 'transparent')
            n.append(s)
            this.container.append(n)
            this._createPopup(s, e)
            return this.container
          }
        }
        class SquareAnnotationElement extends AnnotationElement {
          constructor(e) {
            let t
            let i
            let n
            super(e, {
              isRenderable: !!(
                e.data.hasPopup ||
                ((t = e.data.titleObj) !== null && void 0 !== t && t.str) ||
                ((i = e.data.contentsObj) !== null && void 0 !== i && i.str) ||
                ((n = e.data.richText) !== null && void 0 !== n && n.str)
              ),
              ignoreBorder: !0
            })
          }

          render() {
            this.container.className = 'squareAnnotation'
            const e = this.data
            const { width: t, height: i } = getRectDims(e.rect)
            const n = this.svgFactory.create(t, i, !0)
            const s = e.borderStyle.width
            const a = this.svgFactory.createElement('svg:rect')
            a.setAttribute('x', s / 2)
            a.setAttribute('y', s / 2)
            a.setAttribute('width', t - s)
            a.setAttribute('height', i - s)
            a.setAttribute('stroke-width', s || 1)
            a.setAttribute('stroke', 'transparent')
            a.setAttribute('fill', 'transparent')
            n.append(a)
            this.container.append(n)
            this._createPopup(a, e)
            return this.container
          }
        }
        class CircleAnnotationElement extends AnnotationElement {
          constructor(e) {
            let t
            let i
            let n
            super(e, {
              isRenderable: !!(
                e.data.hasPopup ||
                ((t = e.data.titleObj) !== null && void 0 !== t && t.str) ||
                ((i = e.data.contentsObj) !== null && void 0 !== i && i.str) ||
                ((n = e.data.richText) !== null && void 0 !== n && n.str)
              ),
              ignoreBorder: !0
            })
          }

          render() {
            this.container.className = 'circleAnnotation'
            const e = this.data
            const { width: t, height: i } = getRectDims(e.rect)
            const n = this.svgFactory.create(t, i, !0)
            const s = e.borderStyle.width
            const a = this.svgFactory.createElement('svg:ellipse')
            a.setAttribute('cx', t / 2)
            a.setAttribute('cy', i / 2)
            a.setAttribute('rx', t / 2 - s / 2)
            a.setAttribute('ry', i / 2 - s / 2)
            a.setAttribute('stroke-width', s || 1)
            a.setAttribute('stroke', 'transparent')
            a.setAttribute('fill', 'transparent')
            n.append(a)
            this.container.append(n)
            this._createPopup(a, e)
            return this.container
          }
        }
        class PolylineAnnotationElement extends AnnotationElement {
          constructor(e) {
            let t
            let i
            let n
            super(e, {
              isRenderable: !!(
                e.data.hasPopup ||
                ((t = e.data.titleObj) !== null && void 0 !== t && t.str) ||
                ((i = e.data.contentsObj) !== null && void 0 !== i && i.str) ||
                ((n = e.data.richText) !== null && void 0 !== n && n.str)
              ),
              ignoreBorder: !0
            })
            this.containerClassName = 'polylineAnnotation'
            this.svgElementName = 'svg:polyline'
          }

          render() {
            this.container.className = this.containerClassName
            const e = this.data
            const { width: t, height: i } = getRectDims(e.rect)
            const n = this.svgFactory.create(t, i, !0)
            let s = []
            for (const t of e.vertices) {
              const i = t.x - e.rect[0]
              const n = e.rect[3] - t.y
              s.push(`${i},${n}`)
            }
            s = s.join(' ')
            const a = this.svgFactory.createElement(this.svgElementName)
            a.setAttribute('points', s)
            a.setAttribute('stroke-width', e.borderStyle.width || 1)
            a.setAttribute('stroke', 'transparent')
            a.setAttribute('fill', 'transparent')
            n.append(a)
            this.container.append(n)
            this._createPopup(a, e)
            return this.container
          }
        }
        class PolygonAnnotationElement extends PolylineAnnotationElement {
          constructor(e) {
            super(e)
            this.containerClassName = 'polygonAnnotation'
            this.svgElementName = 'svg:polygon'
          }
        }
        class CaretAnnotationElement extends AnnotationElement {
          constructor(e) {
            let t
            let i
            let n
            super(e, {
              isRenderable: !!(
                e.data.hasPopup ||
                ((t = e.data.titleObj) !== null && void 0 !== t && t.str) ||
                ((i = e.data.contentsObj) !== null && void 0 !== i && i.str) ||
                ((n = e.data.richText) !== null && void 0 !== n && n.str)
              ),
              ignoreBorder: !0
            })
          }

          render() {
            this.container.className = 'caretAnnotation'
            this.data.hasPopup || this._createPopup(null, this.data)
            return this.container
          }
        }
        class InkAnnotationElement extends AnnotationElement {
          constructor(e) {
            let t
            let i
            let n
            super(e, {
              isRenderable: !!(
                e.data.hasPopup ||
                ((t = e.data.titleObj) !== null && void 0 !== t && t.str) ||
                ((i = e.data.contentsObj) !== null && void 0 !== i && i.str) ||
                ((n = e.data.richText) !== null && void 0 !== n && n.str)
              ),
              ignoreBorder: !0
            })
            this.containerClassName = 'inkAnnotation'
            this.svgElementName = 'svg:polyline'
          }

          render() {
            this.container.className = this.containerClassName
            const e = this.data
            const { width: t, height: i } = getRectDims(e.rect)
            const n = this.svgFactory.create(t, i, !0)
            for (const t of e.inkLists) {
              let i = []
              for (const n of t) {
                const t = n.x - e.rect[0]
                const s = e.rect[3] - n.y
                i.push(`${t},${s}`)
              }
              i = i.join(' ')
              const s = this.svgFactory.createElement(this.svgElementName)
              s.setAttribute('points', i)
              s.setAttribute('stroke-width', e.borderStyle.width || 1)
              s.setAttribute('stroke', 'transparent')
              s.setAttribute('fill', 'transparent')
              this._createPopup(s, e)
              n.append(s)
            }
            this.container.append(n)
            return this.container
          }
        }
        class HighlightAnnotationElement extends AnnotationElement {
          constructor(e) {
            let t
            let i
            let n
            super(e, {
              isRenderable: !!(
                e.data.hasPopup ||
                ((t = e.data.titleObj) !== null && void 0 !== t && t.str) ||
                ((i = e.data.contentsObj) !== null && void 0 !== i && i.str) ||
                ((n = e.data.richText) !== null && void 0 !== n && n.str)
              ),
              ignoreBorder: !0,
              createQuadrilaterals: !0
            })
          }

          render() {
            this.data.hasPopup || this._createPopup(null, this.data)
            if (this.quadrilaterals) return this._renderQuadrilaterals('highlightAnnotation')
            this.container.className = 'highlightAnnotation'
            return this.container
          }
        }
        class UnderlineAnnotationElement extends AnnotationElement {
          constructor(e) {
            let t
            let i
            let n
            super(e, {
              isRenderable: !!(
                e.data.hasPopup ||
                ((t = e.data.titleObj) !== null && void 0 !== t && t.str) ||
                ((i = e.data.contentsObj) !== null && void 0 !== i && i.str) ||
                ((n = e.data.richText) !== null && void 0 !== n && n.str)
              ),
              ignoreBorder: !0,
              createQuadrilaterals: !0
            })
          }

          render() {
            this.data.hasPopup || this._createPopup(null, this.data)
            if (this.quadrilaterals) return this._renderQuadrilaterals('underlineAnnotation')
            this.container.className = 'underlineAnnotation'
            return this.container
          }
        }
        class SquigglyAnnotationElement extends AnnotationElement {
          constructor(e) {
            let t
            let i
            let n
            super(e, {
              isRenderable: !!(
                e.data.hasPopup ||
                ((t = e.data.titleObj) !== null && void 0 !== t && t.str) ||
                ((i = e.data.contentsObj) !== null && void 0 !== i && i.str) ||
                ((n = e.data.richText) !== null && void 0 !== n && n.str)
              ),
              ignoreBorder: !0,
              createQuadrilaterals: !0
            })
          }

          render() {
            this.data.hasPopup || this._createPopup(null, this.data)
            if (this.quadrilaterals) return this._renderQuadrilaterals('squigglyAnnotation')
            this.container.className = 'squigglyAnnotation'
            return this.container
          }
        }
        class StrikeOutAnnotationElement extends AnnotationElement {
          constructor(e) {
            let t
            let i
            let n
            super(e, {
              isRenderable: !!(
                e.data.hasPopup ||
                ((t = e.data.titleObj) !== null && void 0 !== t && t.str) ||
                ((i = e.data.contentsObj) !== null && void 0 !== i && i.str) ||
                ((n = e.data.richText) !== null && void 0 !== n && n.str)
              ),
              ignoreBorder: !0,
              createQuadrilaterals: !0
            })
          }

          render() {
            this.data.hasPopup || this._createPopup(null, this.data)
            if (this.quadrilaterals) return this._renderQuadrilaterals('strikeoutAnnotation')
            this.container.className = 'strikeoutAnnotation'
            return this.container
          }
        }
        class StampAnnotationElement extends AnnotationElement {
          constructor(e) {
            let t
            let i
            let n
            super(e, {
              isRenderable: !!(
                e.data.hasPopup ||
                ((t = e.data.titleObj) !== null && void 0 !== t && t.str) ||
                ((i = e.data.contentsObj) !== null && void 0 !== i && i.str) ||
                ((n = e.data.richText) !== null && void 0 !== n && n.str)
              ),
              ignoreBorder: !0
            })
          }

          render() {
            this.container.className = 'stampAnnotation'
            this.data.hasPopup || this._createPopup(null, this.data)
            return this.container
          }
        }
        class FileAttachmentAnnotationElement extends AnnotationElement {
          constructor(e) {
            let t
            super(e, { isRenderable: !0 })
            const { filename: i, content: n } = this.data.file
            this.filename = (0, s.getFilenameFromUrl)(i)
            this.content =
              n((t = this.linkService.eventBus)) === null ||
              void 0 === t ||
              t.dispatch('fileattachmentannotation', { source: this, filename: i, content: n })
          }

          render() {
            let e
            let t
            this.container.className = 'fileAttachmentAnnotation'
            const i = document.createElement('div')
            i.className = 'popupTriggerArea'
            i.addEventListener('dblclick', this._download.bind(this))
            !this.data.hasPopup &&
              (((e = this.data.titleObj) !== null && void 0 !== e && e.str) ||
                ((t = this.data.contentsObj) !== null && void 0 !== t && t.str) ||
                this.data.richText) &&
              this._createPopup(i, this.data)
            this.container.append(i)
            return this.container
          }

          _download() {
            let e
            ;(e = this.downloadManager) === null ||
              void 0 === e ||
              e.openOrDownloadData(this.container, this.content, this.filename)
          }
        }
        class AnnotationLayer {
          static render(e) {
            const { annotations: t, div: i, viewport: r, accessibilityManager: o } = e
            _classStaticPrivateMethodGet(this, AnnotationLayer, _setDimensions).call(this, i, r)
            let l = 0
            for (const c of t) {
              if (c.annotationType !== n.AnnotationType.POPUP) {
                const { width: e, height: t } = getRectDims(c.rect)
                if (e <= 0 || t <= 0) continue
              }
              const t = AnnotationElementFactory.create({
                data: c,
                layer: i,
                page: e.page,
                viewport: r,
                linkService: e.linkService,
                downloadManager: e.downloadManager,
                imageResourcesPath: e.imageResourcesPath || '',
                renderForms: !1 !== e.renderForms,
                svgFactory: new s.DOMSVGFactory(),
                annotationStorage: e.annotationStorage || new a.AnnotationStorage(),
                enableScripting: e.enableScripting,
                hasJSActions: e.hasJSActions,
                fieldObjects: e.fieldObjects,
                mouseState: e.mouseState || { isDown: !1 }
              })
              if (t.isRenderable) {
                const e = t.render()
                c.hidden && (e.style.visibility = 'hidden')
                if (Array.isArray(e))
                  for (const t of e) {
                    t.style.zIndex = l++
                    _classStaticPrivateMethodGet(
                      AnnotationLayer,
                      AnnotationLayer,
                      _appendElement
                    ).call(AnnotationLayer, t, c.id, i, o)
                  }
                else {
                  e.style.zIndex = l++
                  t instanceof PopupAnnotationElement
                    ? i.prepend(e)
                    : _classStaticPrivateMethodGet(
                        AnnotationLayer,
                        AnnotationLayer,
                        _appendElement
                      ).call(AnnotationLayer, e, c.id, i, o)
                }
              }
            }
            _classStaticPrivateMethodGet(this, AnnotationLayer, _setAnnotationCanvasMap).call(
              this,
              i,
              e.annotationCanvasMap
            )
          }

          static update(e) {
            const { annotationCanvasMap: t, div: i, viewport: n } = e
            _classStaticPrivateMethodGet(this, AnnotationLayer, _setDimensions).call(this, i, n)
            _classStaticPrivateMethodGet(this, AnnotationLayer, _setAnnotationCanvasMap).call(
              this,
              i,
              t
            )
            i.hidden = !1
          }
        }
        t.AnnotationLayer = AnnotationLayer
        function _appendElement(e, t, i, n) {
          const a = e.firstChild || e
          a.id = `${s.AnnotationPrefix}${t}`
          i.append(e)
          n == null || n.moveElementInDOM(i, e, a, !1)
        }
        function _setDimensions(e, t) {
          const { width: i, height: n, rotation: s } = t
          const { style: a } = e
          const r = s % 180 != 0
          const o = `${Math.floor(i)}px`
          const l = `${Math.floor(n)}px`
          a.width = r ? l : o
          a.height = r ? o : l
          e.setAttribute('data-main-rotation', s)
        }
        function _setAnnotationCanvasMap(e, t) {
          if (t) {
            for (const [i, n] of t) {
              const t = e.querySelector(`[data-annotation-id="${i}"]`)
              if (!t) continue
              const { firstChild: s } = t
              s ? (s.nodeName === 'CANVAS' ? s.replaceWith(n) : s.before(n)) : t.append(n)
            }
            t.clear()
          }
        }
      },
      (e, t) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.ColorConverters = void 0
        function makeColorComp(e) {
          return Math.floor(255 * Math.max(0, Math.min(1, e)))
            .toString(16)
            .padStart(2, '0')
        }
        t.ColorConverters = class ColorConverters {
          static CMYK_G(e) {
            const [t, i, n, s] = e
            return ['G', 1 - Math.min(1, 0.3 * t + 0.59 * n + 0.11 * i + s)]
          }

          static G_CMYK(e) {
            const [t] = e
            return ['CMYK', 0, 0, 0, 1 - t]
          }

          static G_RGB(e) {
            const [t] = e
            return ['RGB', t, t, t]
          }

          static G_HTML(e) {
            const [t] = e
            const i = makeColorComp(t)
            return `#${i}${i}${i}`
          }

          static RGB_G(e) {
            const [t, i, n] = e
            return ['G', 0.3 * t + 0.59 * i + 0.11 * n]
          }

          static RGB_HTML(e) {
            const [t, i, n] = e
            return `#${makeColorComp(t)}${makeColorComp(i)}${makeColorComp(n)}`
          }

          static T_HTML() {
            return '#00000000'
          }

          static CMYK_RGB(e) {
            const [t, i, n, s] = e
            return ['RGB', 1 - Math.min(1, t + s), 1 - Math.min(1, n + s), 1 - Math.min(1, i + s)]
          }

          static CMYK_HTML(e) {
            const t = this.CMYK_RGB(e).slice(1)
            return this.RGB_HTML(t)
          }

          static RGB_CMYK(e) {
            const [t, i, n] = e
            const s = 1 - t
            const a = 1 - i
            const r = 1 - n
            return ['CMYK', s, a, r, Math.min(s, a, r)]
          }
        }
      },
      (e, t, i) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.XfaLayer = void 0
        const n = i(147)
        t.XfaLayer = class XfaLayer {
          static setupStorage(e, t, i, n, s) {
            const a = n.getValue(t, { value: null })
            switch (i.name) {
              case 'textarea':
                a.value !== null && (e.textContent = a.value)
                if (s === 'print') break
                e.addEventListener('input', (e) => {
                  n.setValue(t, { value: e.target.value })
                })
                break
              case 'input':
                if (i.attributes.type === 'radio' || i.attributes.type === 'checkbox') {
                  a.value === i.attributes.xfaOn
                    ? e.setAttribute('checked', !0)
                    : a.value === i.attributes.xfaOff && e.removeAttribute('checked')
                  if (s === 'print') break
                  e.addEventListener('change', (e) => {
                    n.setValue(t, {
                      value: e.target.checked
                        ? e.target.getAttribute('xfaOn')
                        : e.target.getAttribute('xfaOff')
                    })
                  })
                } else {
                  a.value !== null && e.setAttribute('value', a.value)
                  if (s === 'print') break
                  e.addEventListener('input', (e) => {
                    n.setValue(t, { value: e.target.value })
                  })
                }
                break
              case 'select':
                if (a.value !== null)
                  for (const e of i.children)
                    e.attributes.value === a.value && (e.attributes.selected = !0)
                e.addEventListener('input', (e) => {
                  const i = e.target.options
                  const s = i.selectedIndex === -1 ? '' : i[i.selectedIndex].value
                  n.setValue(t, { value: s })
                })
            }
          }

          static setAttributes(e) {
            const { html: t, element: i, storage: n = null, intent: s, linkService: a } = e
            const { attributes: r } = i
            const o = t instanceof HTMLAnchorElement
            r.type === 'radio' && (r.name = `${r.name}-${s}`)
            for (const [e, i] of Object.entries(r))
              if (i != null)
                switch (e) {
                  case 'class':
                    i.length && t.setAttribute(e, i.join(' '))
                    break
                  case 'dataId':
                    break
                  case 'id':
                    t.setAttribute('data-element-id', i)
                    break
                  case 'style':
                    Object.assign(t.style, i)
                    break
                  case 'textContent':
                    t.textContent = i
                    break
                  default:
                    ;(!o || (e !== 'href' && e !== 'newWindow')) && t.setAttribute(e, i)
                }
            o && a.addLinkAttributes(t, r.href, r.newWindow)
            n && r.dataId && this.setupStorage(t, r.dataId, i, n)
          }

          static render(e) {
            const t = e.annotationStorage
            const i = e.linkService
            const s = e.xfaHtml
            const a = e.intent || 'display'
            const r = document.createElement(s.name)
            s.attributes && this.setAttributes({ html: r, element: s, intent: a, linkService: i })
            const o = [[s, -1, r]]
            const l = e.div
            l.append(r)
            if (e.viewport) {
              const t = `matrix(${e.viewport.transform.join(',')})`
              l.style.transform = t
            }
            a !== 'richText' && l.setAttribute('class', 'xfaLayer xfaFont')
            const c = []
            for (; o.length > 0; ) {
              var d
              const [e, s, r] = o.at(-1)
              if (s + 1 === e.children.length) {
                o.pop()
                continue
              }
              const l = e.children[++o.at(-1)[1]]
              if (l === null) continue
              const { name: h } = l
              if (h === '#text') {
                const e = document.createTextNode(l.value)
                c.push(e)
                r.append(e)
                continue
              }
              let u
              u =
                l != null && (d = l.attributes) !== null && void 0 !== d && d.xmlns
                  ? document.createElementNS(l.attributes.xmlns, h)
                  : document.createElement(h)
              r.append(u)
              l.attributes &&
                this.setAttributes({ html: u, element: l, storage: t, intent: a, linkService: i })
              if (l.children && l.children.length > 0) o.push([l, -1, u])
              else if (l.value) {
                const e = document.createTextNode(l.value)
                n.XfaText.shouldBuildText(h) && c.push(e)
                u.append(e)
              }
            }
            for (const e of l.querySelectorAll(
              '.xfaNonInteractive input, .xfaNonInteractive textarea'
            ))
              e.setAttribute('readOnly', !0)
            return { textDivs: c }
          }

          static update(e) {
            const t = `matrix(${e.viewport.transform.join(',')})`
            e.div.style.transform = t
            e.div.hidden = !1
          }
        }
      },
      (e, t, i) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.TextLayerRenderTask = void 0
        t.renderTextLayer = function renderTextLayer(e) {
          const t = new TextLayerRenderTask({
            textContent: e.textContent,
            textContentStream: e.textContentStream,
            container: e.container,
            viewport: e.viewport,
            textDivs: e.textDivs,
            textContentItemsStr: e.textContentItemsStr,
            enhanceTextSelection: e.enhanceTextSelection
          })
          t._render(e.timeout)
          return t
        }
        const n = i(1)
        const s = i(140)
        const a = i(133)
        const r = 30
        const o = new Map()
        const l = /^\s+$/g
        function appendText(e, t, i, a) {
          const c = document.createElement('span')
          const d = e._enhanceTextSelection
            ? {
                angle: 0,
                canvasWidth: 0,
                hasText: t.str !== '',
                hasEOL: t.hasEOL,
                originalTransform: null,
                paddingBottom: 0,
                paddingLeft: 0,
                paddingRight: 0,
                paddingTop: 0,
                scale: 1,
                fontSize: 0
              }
            : { angle: 0, canvasWidth: 0, hasText: t.str !== '', hasEOL: t.hasEOL, fontSize: 0 }
          e._textDivs.push(c)
          t.str = (0, s.replaceSensitiveWord)(t.str)
          const h = n.Util.transform(e._viewport.transform, t.transform)
          let u = Math.atan2(h[1], h[0])
          const p = i[t.fontName]
          p.vertical && (u += Math.PI / 2)
          const g = Math.hypot(h[2], h[3])
          const f =
            g *
            (function getAscent(e, t) {
              const i = o.get(e)
              if (i) return i
              t.save()
              t.font = `30px ${e}`
              const n = t.measureText('')
              let s = n.fontBoundingBoxAscent
              let a = Math.abs(n.fontBoundingBoxDescent)
              if (s) {
                t.restore()
                const i = s / (s + a)
                o.set(e, i)
                return i
              }
              t.strokeStyle = 'red'
              t.clearRect(0, 0, r, r)
              t.strokeText('g', 0, 0)
              let l = t.getImageData(0, 0, r, r).data
              a = 0
              for (let e = l.length - 1 - 3; e >= 0; e -= 4)
                if (l[e] > 0) {
                  a = Math.ceil(e / 4 / r)
                  break
                }
              t.clearRect(0, 0, r, r)
              t.strokeText('A', 0, r)
              l = t.getImageData(0, 0, r, r).data
              s = 0
              for (let e = 0, t = l.length; e < t; e += 4)
                if (l[e] > 0) {
                  s = r - Math.floor(e / 4 / r)
                  break
                }
              t.restore()
              if (s) {
                const t = s / (s + a)
                o.set(e, t)
                return t
              }
              o.set(e, 0.8)
              return 0.8
            })(p.fontFamily, a)
          let m
          let v
          if (u === 0) {
            m = h[4]
            v = h[5] - f
          } else {
            m = h[4] + f * Math.sin(u)
            v = h[5] - f * Math.cos(u)
          }
          c.style.left = `${m}px`
          c.style.top = `${v}px`
          c.style.fontSize = `${g}px`
          c.style.fontFamily = p.fontFamily
          d.fontSize = g
          c.setAttribute('role', 'presentation')
          c.textContent = t.str
          c.dir = t.dir
          e._fontInspectorEnabled && (c.dataset.fontName = t.fontName)
          u !== 0 && (d.angle = u * (180 / Math.PI))
          let _ = !1
          if (t.str.length > 1 || (e._enhanceTextSelection && l.test(t.str))) _ = !0
          else if (t.str !== ' ' && t.transform[0] !== t.transform[3]) {
            const e = Math.abs(t.transform[0])
            const i = Math.abs(t.transform[3])
            e !== i && Math.max(e, i) / Math.min(e, i) > 1.5 && (_ = !0)
          }
          _ &&
            (p.vertical
              ? (d.canvasWidth = t.height * e._viewport.scale)
              : (d.canvasWidth = t.width * e._viewport.scale))
          e._textDivProperties.set(c, d)
          e._textContentStream && e._layoutText(c)
          if (e._enhanceTextSelection && d.hasText) {
            let i = 1
            let s = 0
            if (u !== 0) {
              i = Math.cos(u)
              s = Math.sin(u)
            }
            const a = (p.vertical ? t.height : t.width) * e._viewport.scale
            const r = g
            let o
            let l
            if (u !== 0) {
              o = [i, s, -s, i, m, v]
              l = n.Util.getAxialAlignedBoundingBox([0, 0, a, r], o)
            } else l = [m, v, m + a, v + r]
            e._bounds.push({
              left: l[0],
              top: l[1],
              right: l[2],
              bottom: l[3],
              div: c,
              size: [a, r],
              m: o
            })
          }
        }
        function render(e) {
          if (e._canceled) return
          const t = e._textDivs
          const i = e._capability
          const n = t.length
          if (n > 1e5) {
            e._renderingDone = !0
            i.resolve()
          } else {
            if (!e._textContentStream) for (let i = 0; i < n; i++) e._layoutText(t[i])
            e._renderingDone = !0
            i.resolve()
          }
        }
        function findPositiveMin(e, t, i) {
          let n = 0
          for (let s = 0; s < i; s++) {
            const i = e[t++]
            i > 0 && (n = n ? Math.min(i, n) : i)
          }
          return n
        }
        function expand(e) {
          const t = e._bounds
          const i = e._viewport
          const s = (function expandBounds(e, t, i) {
            const n = i.map(function (e, t) {
              return {
                x1: e.left,
                y1: e.top,
                x2: e.right,
                y2: e.bottom,
                index: t,
                x1New: void 0,
                x2New: void 0
              }
            })
            expandBoundsLTR(e, n)
            const s = new Array(i.length)
            for (const e of n) {
              const t = e.index
              s[t] = { left: e.x1New, top: 0, right: e.x2New, bottom: 0 }
            }
            i.map(function (t, i) {
              const a = s[i]
              const r = n[i]
              r.x1 = t.top
              r.y1 = e - a.right
              r.x2 = t.bottom
              r.y2 = e - a.left
              r.index = i
              r.x1New = void 0
              r.x2New = void 0
            })
            expandBoundsLTR(t, n)
            for (const e of n) {
              const t = e.index
              s[t].top = e.x1New
              s[t].bottom = e.x2New
            }
            return s
          })(i.width, i.height, t)
          for (let i = 0; i < s.length; i++) {
            const a = t[i].div
            const r = e._textDivProperties.get(a)
            if (r.angle === 0) {
              r.paddingLeft = t[i].left - s[i].left
              r.paddingTop = t[i].top - s[i].top
              r.paddingRight = s[i].right - t[i].right
              r.paddingBottom = s[i].bottom - t[i].bottom
              e._textDivProperties.set(a, r)
              continue
            }
            const o = s[i]
            const l = t[i]
            const c = l.m
            const d = c[0]
            const h = c[1]
            const u = [[0, 0], [0, l.size[1]], [l.size[0], 0], l.size]
            const p = new Float64Array(64)
            for (let e = 0, t = u.length; e < t; e++) {
              const t = n.Util.applyTransform(u[e], c)
              p[e + 0] = d && (o.left - t[0]) / d
              p[e + 4] = h && (o.top - t[1]) / h
              p[e + 8] = d && (o.right - t[0]) / d
              p[e + 12] = h && (o.bottom - t[1]) / h
              p[e + 16] = h && (o.left - t[0]) / -h
              p[e + 20] = d && (o.top - t[1]) / d
              p[e + 24] = h && (o.right - t[0]) / -h
              p[e + 28] = d && (o.bottom - t[1]) / d
              p[e + 32] = d && (o.left - t[0]) / -d
              p[e + 36] = h && (o.top - t[1]) / -h
              p[e + 40] = d && (o.right - t[0]) / -d
              p[e + 44] = h && (o.bottom - t[1]) / -h
              p[e + 48] = h && (o.left - t[0]) / h
              p[e + 52] = d && (o.top - t[1]) / -d
              p[e + 56] = h && (o.right - t[0]) / h
              p[e + 60] = d && (o.bottom - t[1]) / -d
            }
            const g = 1 + Math.min(Math.abs(d), Math.abs(h))
            r.paddingLeft = findPositiveMin(p, 32, 16) / g
            r.paddingTop = findPositiveMin(p, 48, 16) / g
            r.paddingRight = findPositiveMin(p, 0, 16) / g
            r.paddingBottom = findPositiveMin(p, 16, 16) / g
            e._textDivProperties.set(a, r)
          }
        }
        function expandBoundsLTR(e, t) {
          t.sort(function (e, t) {
            return e.x1 - t.x1 || e.index - t.index
          })
          const i = [
            {
              start: -1 / 0,
              end: 1 / 0,
              boundary: {
                x1: -1 / 0,
                y1: -1 / 0,
                x2: 0,
                y2: 1 / 0,
                index: -1,
                x1New: 0,
                x2New: 0
              }
            }
          ]
          for (const e of t) {
            let t = 0
            for (; t < i.length && i[t].end <= e.y1; ) t++
            let n
            let s
            let a = i.length - 1
            for (; a >= 0 && i[a].start >= e.y2; ) a--
            let r
            let o
            let l = -1 / 0
            for (r = t; r <= a; r++) {
              n = i[r]
              s = n.boundary
              let t
              t =
                s.x2 > e.x1
                  ? s.index > e.index
                    ? s.x1New
                    : e.x1
                  : void 0 === s.x2New
                  ? (s.x2 + e.x1) / 2
                  : s.x2New
              t > l && (l = t)
            }
            e.x1New = l
            for (r = t; r <= a; r++) {
              n = i[r]
              s = n.boundary
              void 0 === s.x2New
                ? s.x2 > e.x1
                  ? s.index > e.index && (s.x2New = s.x2)
                  : (s.x2New = l)
                : s.x2New > l && (s.x2New = Math.max(l, s.x2))
            }
            const c = []
            let d = null
            for (r = t; r <= a; r++) {
              n = i[r]
              s = n.boundary
              const t = s.x2 > e.x2 ? s : e
              if (d === t) c.at(-1).end = n.end
              else {
                c.push({ start: n.start, end: n.end, boundary: t })
                d = t
              }
            }
            if (i[t].start < e.y1) {
              c[0].start = e.y1
              c.unshift({ start: i[t].start, end: e.y1, boundary: i[t].boundary })
            }
            if (e.y2 < i[a].end) {
              c.at(-1).end = e.y2
              c.push({ start: e.y2, end: i[a].end, boundary: i[a].boundary })
            }
            for (r = t; r <= a; r++) {
              n = i[r]
              s = n.boundary
              if (void 0 !== s.x2New) continue
              let e = !1
              for (o = t - 1; !e && o >= 0 && i[o].start >= s.y1; o--) e = i[o].boundary === s
              for (o = a + 1; !e && o < i.length && i[o].end <= s.y2; o++) e = i[o].boundary === s
              for (o = 0; !e && o < c.length; o++) e = c[o].boundary === s
              e || (s.x2New = l)
            }
            Array.prototype.splice.apply(i, [t, a - t + 1, ...c])
          }
          for (const t of i) {
            const i = t.boundary
            void 0 === i.x2New && (i.x2New = Math.max(e, i.x2))
          }
        }
        class TextLayerRenderTask {
          constructor(e) {
            let t
            const {
              textContent: i,
              textContentStream: s,
              container: r,
              viewport: o,
              textDivs: l,
              textContentItemsStr: c,
              enhanceTextSelection: d
            } = e
            d &&
              (0, a.deprecated)(
                'The `enhanceTextSelection` functionality will be removed in the future.'
              )
            this._textContent = i
            this._textContentStream = s
            this._container = r
            this._document = r.ownerDocument
            this._viewport = o
            this._textDivs = l || []
            this._textContentItemsStr = c || []
            this._enhanceTextSelection = !!d
            this._fontInspectorEnabled = !(
              (t = globalThis.FontInspector) === null ||
              void 0 === t ||
              !t.enabled
            )
            this._reader = null
            this._layoutTextLastFontSize = null
            this._layoutTextLastFontFamily = null
            this._layoutTextCtx = null
            this._textDivProperties = new WeakMap()
            this._renderingDone = !1
            this._canceled = !1
            this._capability = (0, n.createPromiseCapability)()
            this._renderTimer = null
            this._bounds = []
            this._devicePixelRatio = globalThis.devicePixelRatio || 1
            this._capability.promise
              .finally(() => {
                this._enhanceTextSelection || (this._textDivProperties = null)
                if (this._layoutTextCtx) {
                  this._layoutTextCtx.canvas.width = 0
                  this._layoutTextCtx.canvas.height = 0
                  this._layoutTextCtx = null
                }
              })
              .catch(() => {})
          }

          get promise() {
            return this._capability.promise
          }

          cancel() {
            this._canceled = !0
            if (this._reader) {
              this._reader.cancel(new n.AbortException('TextLayer task cancelled.')).catch(() => {})
              this._reader = null
            }
            if (this._renderTimer !== null) {
              clearTimeout(this._renderTimer)
              this._renderTimer = null
            }
            this._capability.reject(new Error('TextLayer task cancelled.'))
          }

          _processItems(e, t) {
            for (let i = 0, n = e.length; i < n; i++)
              if (void 0 !== e[i].str) {
                this._textContentItemsStr.push(e[i].str)
                appendText(this, e[i], t, this._layoutTextCtx)
              } else if (
                e[i].type === 'beginMarkedContentProps' ||
                e[i].type === 'beginMarkedContent'
              ) {
                const t = this._container
                this._container = document.createElement('span')
                this._container.classList.add('markedContent')
                e[i].id !== null && this._container.setAttribute('id', `${e[i].id}`)
                t.append(this._container)
              } else
                e[i].type === 'endMarkedContent' && (this._container = this._container.parentNode)
          }

          _layoutText(e) {
            const t = this._textDivProperties.get(e)
            let i = ''
            if (t.canvasWidth !== 0 && t.hasText) {
              const { fontFamily: n } = e.style
              const { fontSize: s } = t
              if (s !== this._layoutTextLastFontSize || n !== this._layoutTextLastFontFamily) {
                this._layoutTextCtx.font = `${s * this._devicePixelRatio}px ${n}`
                this._layoutTextLastFontSize = s
                this._layoutTextLastFontFamily = n
              }
              const { width: a } = this._layoutTextCtx.measureText(e.textContent)
              if (a > 0) {
                const e = (this._devicePixelRatio * t.canvasWidth) / a
                this._enhanceTextSelection && (t.scale = e)
                i = `scaleX(${e})`
              }
            }
            t.angle !== 0 && (i = `rotate(${t.angle}deg) ${i}`)
            if (i.length > 0) {
              this._enhanceTextSelection && (t.originalTransform = i)
              e.style.transform = i
            }
            t.hasText && this._container.append(e)
            if (t.hasEOL) {
              const e = document.createElement('br')
              e.setAttribute('role', 'presentation')
              this._container.append(e)
            }
          }

          _render() {
            const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
            const t = (0, n.createPromiseCapability)()
            let i = Object.create(null)
            const s = this._document.createElement('canvas')
            s.height = s.width = r
            this._layoutTextCtx = s.getContext('2d', { alpha: !1 })
            if (this._textContent) {
              const e = this._textContent.items
              const i = this._textContent.styles
              this._processItems(e, i)
              t.resolve()
            } else {
              if (!this._textContentStream)
                throw new Error(
                  'Neither "textContent" nor "textContentStream" parameters specified.'
                )
              {
                const pump = () => {
                  this._reader.read().then((e) => {
                    const { value: n, done: s } = e
                    if (s) t.resolve()
                    else {
                      Object.assign(i, n.styles)
                      this._processItems(n.items, i)
                      pump()
                    }
                  }, t.reject)
                }
                this._reader = this._textContentStream.getReader()
                pump()
              }
            }
            t.promise.then(() => {
              i = null
              e
                ? (this._renderTimer = setTimeout(() => {
                    render(this)
                    this._renderTimer = null
                  }, e))
                : render(this)
            }, this._capability.reject)
          }

          expandTextDivs() {
            const e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
            if (!this._enhanceTextSelection || !this._renderingDone) return
            if (this._bounds !== null) {
              expand(this)
              this._bounds = null
            }
            const t = []
            const i = []
            for (let n = 0, s = this._textDivs.length; n < s; n++) {
              const s = this._textDivs[n]
              const a = this._textDivProperties.get(s)
              if (a.hasText)
                if (e) {
                  t.length = 0
                  i.length = 0
                  a.originalTransform && t.push(a.originalTransform)
                  if (a.paddingTop > 0) {
                    i.push(`${a.paddingTop}px`)
                    t.push(`translateY(${-a.paddingTop}px)`)
                  } else i.push(0)
                  a.paddingRight > 0 ? i.push(`${a.paddingRight / a.scale}px`) : i.push(0)
                  a.paddingBottom > 0 ? i.push(`${a.paddingBottom}px`) : i.push(0)
                  if (a.paddingLeft > 0) {
                    i.push(`${a.paddingLeft / a.scale}px`)
                    t.push(`translateX(${-a.paddingLeft / a.scale}px)`)
                  } else i.push(0)
                  s.style.padding = i.join(' ')
                  t.length && (s.style.transform = t.join(' '))
                } else {
                  s.style.padding = null
                  s.style.transform = a.originalTransform
                }
            }
          }
        }
        t.TextLayerRenderTask = TextLayerRenderTask
      },
      (e, t, i) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.SVGGraphics = void 0
        const n = i(133)
        const s = i(1)
        const a = i(3)
        let r = class {
          constructor() {
            ;(0, s.unreachable)('Not implemented: SVGGraphics')
          }
        }
        t.SVGGraphics = r
        {
          const o = { fontStyle: 'normal', fontWeight: 'normal', fillColor: '#000000' }
          const l = 'http://www.w3.org/XML/1998/namespace'
          const c = 'http://www.w3.org/1999/xlink'
          const d = ['butt', 'round', 'square']
          const h = ['miter', 'round', 'bevel']
          const createObjectURL = function (e) {
            const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ''
            const i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
            if (URL.createObjectURL && typeof Blob !== 'undefined' && !i)
              return URL.createObjectURL(new Blob([e], { type: t }))
            const n = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
            let s = `data:${t};base64,`
            for (let t = 0, i = e.length; t < i; t += 3) {
              const a = 255 & e[t]
              const r = 255 & e[t + 1]
              const o = 255 & e[t + 2]
              const l = ((3 & a) << 4) | (r >> 4)
              const c = t + 1 < i ? ((15 & r) << 2) | (o >> 6) : 64
              const d = t + 2 < i ? 63 & o : 64
              s += n[a >> 2] + n[l] + n[c] + n[d]
            }
            return s
          }
          const u = (function () {
            const e = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10])
            const t = new Int32Array(256)
            for (let e = 0; e < 256; e++) {
              let i = e
              for (let e = 0; e < 8; e++)
                i = 1 & i ? 3988292384 ^ ((i >> 1) & 2147483647) : (i >> 1) & 2147483647
              t[e] = i
            }
            function writePngChunk(e, i, n, s) {
              let a = s
              const r = i.length
              n[a] = (r >> 24) & 255
              n[a + 1] = (r >> 16) & 255
              n[a + 2] = (r >> 8) & 255
              n[a + 3] = 255 & r
              a += 4
              n[a] = 255 & e.charCodeAt(0)
              n[a + 1] = 255 & e.charCodeAt(1)
              n[a + 2] = 255 & e.charCodeAt(2)
              n[a + 3] = 255 & e.charCodeAt(3)
              a += 4
              n.set(i, a)
              a += i.length
              const o = (function crc32(e, i, n) {
                let s = -1
                for (let a = i; a < n; a++) {
                  const i = 255 & (s ^ e[a])
                  s = (s >>> 8) ^ t[i]
                }
                return -1 ^ s
              })(n, s + 4, a)
              n[a] = (o >> 24) & 255
              n[a + 1] = (o >> 16) & 255
              n[a + 2] = (o >> 8) & 255
              n[a + 3] = 255 & o
            }
            function deflateSyncUncompressed(e) {
              let t = e.length
              const i = 65535
              const n = Math.ceil(t / i)
              const s = new Uint8Array(2 + t + 5 * n + 4)
              let a = 0
              s[a++] = 120
              s[a++] = 156
              let r = 0
              for (; t > i; ) {
                s[a++] = 0
                s[a++] = 255
                s[a++] = 255
                s[a++] = 0
                s[a++] = 0
                s.set(e.subarray(r, r + i), a)
                a += i
                r += i
                t -= i
              }
              s[a++] = 1
              s[a++] = 255 & t
              s[a++] = (t >> 8) & 255
              s[a++] = 255 & ~t
              s[a++] = ((65535 & ~t) >> 8) & 255
              s.set(e.subarray(r), a)
              a += e.length - r
              const o = (function adler32(e, t, i) {
                let n = 1
                let s = 0
                for (let a = t; a < i; ++a) {
                  n = (n + (255 & e[a])) % 65521
                  s = (s + n) % 65521
                }
                return (s << 16) | n
              })(e, 0, e.length)
              s[a++] = (o >> 24) & 255
              s[a++] = (o >> 16) & 255
              s[a++] = (o >> 8) & 255
              s[a++] = 255 & o
              return s
            }
            function encode(t, i, n, r) {
              const o = t.width
              const l = t.height
              let c
              let d
              let h
              const u = t.data
              switch (i) {
                case s.ImageKind.GRAYSCALE_1BPP:
                  d = 0
                  c = 1
                  h = (o + 7) >> 3
                  break
                case s.ImageKind.RGB_24BPP:
                  d = 2
                  c = 8
                  h = 3 * o
                  break
                case s.ImageKind.RGBA_32BPP:
                  d = 6
                  c = 8
                  h = 4 * o
                  break
                default:
                  throw new Error('invalid format')
              }
              const p = new Uint8Array((1 + h) * l)
              let g = 0
              let f = 0
              for (let e = 0; e < l; ++e) {
                p[g++] = 0
                p.set(u.subarray(f, f + h), g)
                f += h
                g += h
              }
              if (i === s.ImageKind.GRAYSCALE_1BPP && r) {
                g = 0
                for (let e = 0; e < l; e++) {
                  g++
                  for (let e = 0; e < h; e++) p[g++] ^= 255
                }
              }
              const m = new Uint8Array([
                (o >> 24) & 255,
                (o >> 16) & 255,
                (o >> 8) & 255,
                255 & o,
                (l >> 24) & 255,
                (l >> 16) & 255,
                (l >> 8) & 255,
                255 & l,
                c,
                d,
                0,
                0,
                0
              ])
              const v = (function deflateSync(e) {
                if (!a.isNodeJS) return deflateSyncUncompressed(e)
                try {
                  let t
                  t = parseInt(process.versions.node) >= 8 ? e : Buffer.from(e)
                  const i = require('zlib').deflateSync(t, { level: 9 })
                  return i instanceof Uint8Array ? i : new Uint8Array(i)
                } catch (e) {
                  ;(0, s.warn)(`Not compressing PNG because zlib.deflateSync is unavailable: ${e}`)
                }
                return deflateSyncUncompressed(e)
              })(p)
              const _ = e.length + 36 + m.length + v.length
              const b = new Uint8Array(_)
              let w = 0
              b.set(e, w)
              w += e.length
              writePngChunk('IHDR', m, b, w)
              w += 12 + m.length
              writePngChunk('IDATA', v, b, w)
              w += 12 + v.length
              writePngChunk('IEND', new Uint8Array(0), b, w)
              return createObjectURL(b, 'image/png', n)
            }
            return function convertImgDataToPng(e, t, i) {
              return encode(e, void 0 === e.kind ? s.ImageKind.GRAYSCALE_1BPP : e.kind, t, i)
            }
          })()
          class SVGExtraState {
            constructor() {
              this.fontSizeScale = 1
              this.fontWeight = o.fontWeight
              this.fontSize = 0
              this.textMatrix = s.IDENTITY_MATRIX
              this.fontMatrix = s.FONT_IDENTITY_MATRIX
              this.leading = 0
              this.textRenderingMode = s.TextRenderingMode.FILL
              this.textMatrixScale = 1
              this.x = 0
              this.y = 0
              this.lineX = 0
              this.lineY = 0
              this.charSpacing = 0
              this.wordSpacing = 0
              this.textHScale = 1
              this.textRise = 0
              this.fillColor = o.fillColor
              this.strokeColor = '#000000'
              this.fillAlpha = 1
              this.strokeAlpha = 1
              this.lineWidth = 1
              this.lineJoin = ''
              this.lineCap = ''
              this.miterLimit = 0
              this.dashArray = []
              this.dashPhase = 0
              this.dependencies = []
              this.activeClipUrl = null
              this.clipGroup = null
              this.maskId = ''
            }

            clone() {
              return Object.create(this)
            }

            setCurrentPoint(e, t) {
              this.x = e
              this.y = t
            }
          }
          function opListToTree(e) {
            let t = []
            const i = []
            for (const n of e)
              if (n.fn !== 'save') n.fn === 'restore' ? (t = i.pop()) : t.push(n)
              else {
                t.push({ fnId: 92, fn: 'group', items: [] })
                i.push(t)
                t = t.at(-1).items
              }
            return t
          }
          function pf(e) {
            if (Number.isInteger(e)) return e.toString()
            const t = e.toFixed(10)
            let i = t.length - 1
            if (t[i] !== '0') return t
            do {
              i--
            } while (t[i] === '0')
            return t.substring(0, t[i] === '.' ? i : i + 1)
          }
          function pm(e) {
            if (e[4] === 0 && e[5] === 0) {
              if (e[1] === 0 && e[2] === 0)
                return e[0] === 1 && e[3] === 1 ? '' : `scale(${pf(e[0])} ${pf(e[3])})`
              if (e[0] === e[3] && e[1] === -e[2]) {
                return `rotate(${pf((180 * Math.acos(e[0])) / Math.PI)})`
              }
            } else if (e[0] === 1 && e[1] === 0 && e[2] === 0 && e[3] === 1)
              return `translate(${pf(e[4])} ${pf(e[5])})`
            return `matrix(${pf(e[0])} ${pf(e[1])} ${pf(e[2])} ${pf(e[3])} ${pf(e[4])} ${pf(e[5])})`
          }
          let p = 0
          let g = 0
          let f = 0
          t.SVGGraphics = r = class {
            constructor(e, t) {
              const i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
              ;(0, n.deprecated)(
                'The SVG back-end is no longer maintained and *may* be removed in the future.'
              )
              this.svgFactory = new n.DOMSVGFactory()
              this.current = new SVGExtraState()
              this.transformMatrix = s.IDENTITY_MATRIX
              this.transformStack = []
              this.extraStack = []
              this.commonObjs = e
              this.objs = t
              this.pendingClip = null
              this.pendingEOFill = !1
              this.embedFonts = !1
              this.embeddedFonts = Object.create(null)
              this.cssStyle = null
              this.forceDataSchema = !!i
              this._operatorIdMapping = []
              for (const e in s.OPS) this._operatorIdMapping[s.OPS[e]] = e
            }

            save() {
              this.transformStack.push(this.transformMatrix)
              const e = this.current
              this.extraStack.push(e)
              this.current = e.clone()
            }

            restore() {
              this.transformMatrix = this.transformStack.pop()
              this.current = this.extraStack.pop()
              this.pendingClip = null
              this.tgrp = null
            }

            group(e) {
              this.save()
              this.executeOpTree(e)
              this.restore()
            }

            loadDependencies(e) {
              const t = e.fnArray
              const i = e.argsArray
              for (let e = 0, n = t.length; e < n; e++)
                if (t[e] === s.OPS.dependency)
                  for (const t of i[e]) {
                    const e = t.startsWith('g_') ? this.commonObjs : this.objs
                    const i = new Promise((i) => {
                      e.get(t, i)
                    })
                    this.current.dependencies.push(i)
                  }
              return Promise.all(this.current.dependencies)
            }

            transform(e, t, i, n, a, r) {
              const o = [e, t, i, n, a, r]
              this.transformMatrix = s.Util.transform(this.transformMatrix, o)
              this.tgrp = null
            }

            getSVG(e, t) {
              this.viewport = t
              const i = this._initialize(t)
              return this.loadDependencies(e).then(() => {
                this.transformMatrix = s.IDENTITY_MATRIX
                this.executeOpTree(this.convertOpList(e))
                return i
              })
            }

            convertOpList(e) {
              const t = this._operatorIdMapping
              const i = e.argsArray
              const n = e.fnArray
              const s = []
              for (let e = 0, a = n.length; e < a; e++) {
                const a = n[e]
                s.push({ fnId: a, fn: t[a], args: i[e] })
              }
              return opListToTree(s)
            }

            executeOpTree(e) {
              for (const t of e) {
                const e = t.fn
                const i = t.fnId
                const n = t.args
                switch (0 | i) {
                  case s.OPS.beginText:
                    this.beginText()
                    break
                  case s.OPS.dependency:
                    break
                  case s.OPS.setLeading:
                    this.setLeading(n)
                    break
                  case s.OPS.setLeadingMoveText:
                    this.setLeadingMoveText(n[0], n[1])
                    break
                  case s.OPS.setFont:
                    this.setFont(n)
                    break
                  case s.OPS.showText:
                  case s.OPS.showSpacedText:
                    this.showText(n[0])
                    break
                  case s.OPS.endText:
                    this.endText()
                    break
                  case s.OPS.moveText:
                    this.moveText(n[0], n[1])
                    break
                  case s.OPS.setCharSpacing:
                    this.setCharSpacing(n[0])
                    break
                  case s.OPS.setWordSpacing:
                    this.setWordSpacing(n[0])
                    break
                  case s.OPS.setHScale:
                    this.setHScale(n[0])
                    break
                  case s.OPS.setTextMatrix:
                    this.setTextMatrix(n[0], n[1], n[2], n[3], n[4], n[5])
                    break
                  case s.OPS.setTextRise:
                    this.setTextRise(n[0])
                    break
                  case s.OPS.setTextRenderingMode:
                    this.setTextRenderingMode(n[0])
                    break
                  case s.OPS.setLineWidth:
                    this.setLineWidth(n[0])
                    break
                  case s.OPS.setLineJoin:
                    this.setLineJoin(n[0])
                    break
                  case s.OPS.setLineCap:
                    this.setLineCap(n[0])
                    break
                  case s.OPS.setMiterLimit:
                    this.setMiterLimit(n[0])
                    break
                  case s.OPS.setFillRGBColor:
                    this.setFillRGBColor(n[0], n[1], n[2])
                    break
                  case s.OPS.setStrokeRGBColor:
                    this.setStrokeRGBColor(n[0], n[1], n[2])
                    break
                  case s.OPS.setStrokeColorN:
                    this.setStrokeColorN(n)
                    break
                  case s.OPS.setFillColorN:
                    this.setFillColorN(n)
                    break
                  case s.OPS.shadingFill:
                    this.shadingFill(n[0])
                    break
                  case s.OPS.setDash:
                    this.setDash(n[0], n[1])
                    break
                  case s.OPS.setRenderingIntent:
                    this.setRenderingIntent(n[0])
                    break
                  case s.OPS.setFlatness:
                    this.setFlatness(n[0])
                    break
                  case s.OPS.setGState:
                    this.setGState(n[0])
                    break
                  case s.OPS.fill:
                    this.fill()
                    break
                  case s.OPS.eoFill:
                    this.eoFill()
                    break
                  case s.OPS.stroke:
                    this.stroke()
                    break
                  case s.OPS.fillStroke:
                    this.fillStroke()
                    break
                  case s.OPS.eoFillStroke:
                    this.eoFillStroke()
                    break
                  case s.OPS.clip:
                    this.clip('nonzero')
                    break
                  case s.OPS.eoClip:
                    this.clip('evenodd')
                    break
                  case s.OPS.paintSolidColorImageMask:
                    this.paintSolidColorImageMask()
                    break
                  case s.OPS.paintImageXObject:
                    this.paintImageXObject(n[0])
                    break
                  case s.OPS.paintInlineImageXObject:
                    this.paintInlineImageXObject(n[0])
                    break
                  case s.OPS.paintImageMaskXObject:
                    this.paintImageMaskXObject(n[0])
                    break
                  case s.OPS.paintFormXObjectBegin:
                    this.paintFormXObjectBegin(n[0], n[1])
                    break
                  case s.OPS.paintFormXObjectEnd:
                    this.paintFormXObjectEnd()
                    break
                  case s.OPS.closePath:
                    this.closePath()
                    break
                  case s.OPS.closeStroke:
                    this.closeStroke()
                    break
                  case s.OPS.closeFillStroke:
                    this.closeFillStroke()
                    break
                  case s.OPS.closeEOFillStroke:
                    this.closeEOFillStroke()
                    break
                  case s.OPS.nextLine:
                    this.nextLine()
                    break
                  case s.OPS.transform:
                    this.transform(n[0], n[1], n[2], n[3], n[4], n[5])
                    break
                  case s.OPS.constructPath:
                    this.constructPath(n[0], n[1])
                    break
                  case s.OPS.endPath:
                    this.endPath()
                    break
                  case 92:
                    this.group(t.items)
                    break
                  default:
                    ;(0, s.warn)(`Unimplemented operator ${e}`)
                }
              }
            }

            setWordSpacing(e) {
              this.current.wordSpacing = e
            }

            setCharSpacing(e) {
              this.current.charSpacing = e
            }

            nextLine() {
              this.moveText(0, this.current.leading)
            }

            setTextMatrix(e, t, i, n, s, a) {
              const r = this.current
              r.textMatrix = r.lineMatrix = [e, t, i, n, s, a]
              r.textMatrixScale = Math.hypot(e, t)
              r.x = r.lineX = 0
              r.y = r.lineY = 0
              r.xcoords = []
              r.ycoords = []
              r.tspan = this.svgFactory.createElement('svg:tspan')
              r.tspan.setAttributeNS(null, 'font-family', r.fontFamily)
              r.tspan.setAttributeNS(null, 'font-size', `${pf(r.fontSize)}px`)
              r.tspan.setAttributeNS(null, 'y', pf(-r.y))
              r.txtElement = this.svgFactory.createElement('svg:text')
              r.txtElement.append(r.tspan)
            }

            beginText() {
              const e = this.current
              e.x = e.lineX = 0
              e.y = e.lineY = 0
              e.textMatrix = s.IDENTITY_MATRIX
              e.lineMatrix = s.IDENTITY_MATRIX
              e.textMatrixScale = 1
              e.tspan = this.svgFactory.createElement('svg:tspan')
              e.txtElement = this.svgFactory.createElement('svg:text')
              e.txtgrp = this.svgFactory.createElement('svg:g')
              e.xcoords = []
              e.ycoords = []
            }

            moveText(e, t) {
              const i = this.current
              i.x = i.lineX += e
              i.y = i.lineY += t
              i.xcoords = []
              i.ycoords = []
              i.tspan = this.svgFactory.createElement('svg:tspan')
              i.tspan.setAttributeNS(null, 'font-family', i.fontFamily)
              i.tspan.setAttributeNS(null, 'font-size', `${pf(i.fontSize)}px`)
              i.tspan.setAttributeNS(null, 'y', pf(-i.y))
            }

            showText(e) {
              const t = this.current
              const i = t.font
              const n = t.fontSize
              if (n === 0) return
              const a = t.fontSizeScale
              const r = t.charSpacing
              const c = t.wordSpacing
              const d = t.fontDirection
              const h = t.textHScale * d
              const u = i.vertical
              const p = u ? 1 : -1
              const g = i.defaultVMetrics
              const f = n * t.fontMatrix[0]
              let m = 0
              for (const s of e) {
                if (s === null) {
                  m += d * c
                  continue
                }
                if (typeof s === 'number') {
                  m += (p * s * n) / 1e3
                  continue
                }
                const e = (s.isSpace ? c : 0) + r
                const o = s.fontChar
                let l
                let h
                let v
                let _ = s.width
                if (u) {
                  let e
                  const t = s.vmetric || g
                  e = s.vmetric ? t[1] : 0.5 * _
                  e = -e * f
                  const i = t[2] * f
                  _ = t ? -t[0] : _
                  l = e / a
                  h = (m + i) / a
                } else {
                  l = m / a
                  h = 0
                }
                if (s.isInFont || i.missingFile) {
                  t.xcoords.push(t.x + l)
                  u && t.ycoords.push(-t.y + h)
                  t.tspan.textContent += o
                }
                v = u ? _ * f - e * d : _ * f + e * d
                m += v
              }
              t.tspan.setAttributeNS(null, 'x', t.xcoords.map(pf).join(' '))
              u
                ? t.tspan.setAttributeNS(null, 'y', t.ycoords.map(pf).join(' '))
                : t.tspan.setAttributeNS(null, 'y', pf(-t.y))
              u ? (t.y -= m) : (t.x += m * h)
              t.tspan.setAttributeNS(null, 'font-family', t.fontFamily)
              t.tspan.setAttributeNS(null, 'font-size', `${pf(t.fontSize)}px`)
              t.fontStyle !== o.fontStyle && t.tspan.setAttributeNS(null, 'font-style', t.fontStyle)
              t.fontWeight !== o.fontWeight &&
                t.tspan.setAttributeNS(null, 'font-weight', t.fontWeight)
              const v = t.textRenderingMode & s.TextRenderingMode.FILL_STROKE_MASK
              if (v === s.TextRenderingMode.FILL || v === s.TextRenderingMode.FILL_STROKE) {
                t.fillColor !== o.fillColor && t.tspan.setAttributeNS(null, 'fill', t.fillColor)
                t.fillAlpha < 1 && t.tspan.setAttributeNS(null, 'fill-opacity', t.fillAlpha)
              } else
                t.textRenderingMode === s.TextRenderingMode.ADD_TO_PATH
                  ? t.tspan.setAttributeNS(null, 'fill', 'transparent')
                  : t.tspan.setAttributeNS(null, 'fill', 'none')
              if (v === s.TextRenderingMode.STROKE || v === s.TextRenderingMode.FILL_STROKE) {
                const e = 1 / (t.textMatrixScale || 1)
                this._setStrokeAttributes(t.tspan, e)
              }
              let _ = t.textMatrix
              if (t.textRise !== 0) {
                _ = _.slice()
                _[5] += t.textRise
              }
              t.txtElement.setAttributeNS(null, 'transform', `${pm(_)} scale(${pf(h)}, -1)`)
              t.txtElement.setAttributeNS(l, 'xml:space', 'preserve')
              t.txtElement.append(t.tspan)
              t.txtgrp.append(t.txtElement)
              this._ensureTransformGroup().append(t.txtElement)
            }

            setLeadingMoveText(e, t) {
              this.setLeading(-t)
              this.moveText(e, t)
            }

            addFontStyle(e) {
              if (!e.data)
                throw new Error(
                  'addFontStyle: No font data available, ensure that the "fontExtraProperties" API parameter is set.'
                )
              if (!this.cssStyle) {
                this.cssStyle = this.svgFactory.createElement('svg:style')
                this.cssStyle.setAttributeNS(null, 'type', 'text/css')
                this.defs.append(this.cssStyle)
              }
              const t = createObjectURL(e.data, e.mimetype, this.forceDataSchema)
              this.cssStyle.textContent += `@font-face { font-family: "${e.loadedName}"; src: url(${t}); }\n`
            }

            setFont(e) {
              const t = this.current
              const i = this.commonObjs.get(e[0])
              let n = e[1]
              t.font = i
              if (this.embedFonts && !i.missingFile && !this.embeddedFonts[i.loadedName]) {
                this.addFontStyle(i)
                this.embeddedFonts[i.loadedName] = i
              }
              t.fontMatrix = i.fontMatrix || s.FONT_IDENTITY_MATRIX
              let a = 'normal'
              i.black ? (a = '900') : i.bold && (a = 'bold')
              const r = i.italic ? 'italic' : 'normal'
              if (n < 0) {
                n = -n
                t.fontDirection = -1
              } else t.fontDirection = 1
              t.fontSize = n
              t.fontFamily = i.loadedName
              t.fontWeight = a
              t.fontStyle = r
              t.tspan = this.svgFactory.createElement('svg:tspan')
              t.tspan.setAttributeNS(null, 'y', pf(-t.y))
              t.xcoords = []
              t.ycoords = []
            }

            endText() {
              let e
              const t = this.current
              if (
                t.textRenderingMode & s.TextRenderingMode.ADD_TO_PATH_FLAG &&
                (e = t.txtElement) !== null &&
                void 0 !== e &&
                e.hasChildNodes()
              ) {
                t.element = t.txtElement
                this.clip('nonzero')
                this.endPath()
              }
            }

            setLineWidth(e) {
              e > 0 && (this.current.lineWidth = e)
            }

            setLineCap(e) {
              this.current.lineCap = d[e]
            }

            setLineJoin(e) {
              this.current.lineJoin = h[e]
            }

            setMiterLimit(e) {
              this.current.miterLimit = e
            }

            setStrokeAlpha(e) {
              this.current.strokeAlpha = e
            }

            setStrokeRGBColor(e, t, i) {
              this.current.strokeColor = s.Util.makeHexColor(e, t, i)
            }

            setFillAlpha(e) {
              this.current.fillAlpha = e
            }

            setFillRGBColor(e, t, i) {
              this.current.fillColor = s.Util.makeHexColor(e, t, i)
              this.current.tspan = this.svgFactory.createElement('svg:tspan')
              this.current.xcoords = []
              this.current.ycoords = []
            }

            setStrokeColorN(e) {
              this.current.strokeColor = this._makeColorN_Pattern(e)
            }

            setFillColorN(e) {
              this.current.fillColor = this._makeColorN_Pattern(e)
            }

            shadingFill(e) {
              const t = this.viewport.width
              const i = this.viewport.height
              const n = s.Util.inverseTransform(this.transformMatrix)
              const a = s.Util.applyTransform([0, 0], n)
              const r = s.Util.applyTransform([0, i], n)
              const o = s.Util.applyTransform([t, 0], n)
              const l = s.Util.applyTransform([t, i], n)
              const c = Math.min(a[0], r[0], o[0], l[0])
              const d = Math.min(a[1], r[1], o[1], l[1])
              const h = Math.max(a[0], r[0], o[0], l[0])
              const u = Math.max(a[1], r[1], o[1], l[1])
              const p = this.svgFactory.createElement('svg:rect')
              p.setAttributeNS(null, 'x', c)
              p.setAttributeNS(null, 'y', d)
              p.setAttributeNS(null, 'width', h - c)
              p.setAttributeNS(null, 'height', u - d)
              p.setAttributeNS(null, 'fill', this._makeShadingPattern(e))
              this.current.fillAlpha < 1 &&
                p.setAttributeNS(null, 'fill-opacity', this.current.fillAlpha)
              this._ensureTransformGroup().append(p)
            }

            _makeColorN_Pattern(e) {
              return e[0] === 'TilingPattern'
                ? this._makeTilingPattern(e)
                : this._makeShadingPattern(e)
            }

            _makeTilingPattern(e) {
              const t = e[1]
              const i = e[2]
              const n = e[3] || s.IDENTITY_MATRIX
              const [a, r, o, l] = e[4]
              const c = e[5]
              const d = e[6]
              const h = e[7]
              const u = `shading${f++}`
              const [p, g, m, v] = s.Util.normalizeRect([
                ...s.Util.applyTransform([a, r], n),
                ...s.Util.applyTransform([o, l], n)
              ])
              const [_, b] = s.Util.singularValueDecompose2dScale(n)
              const w = c * _
              const P = d * b
              const y = this.svgFactory.createElement('svg:pattern')
              y.setAttributeNS(null, 'id', u)
              y.setAttributeNS(null, 'patternUnits', 'userSpaceOnUse')
              y.setAttributeNS(null, 'width', w)
              y.setAttributeNS(null, 'height', P)
              y.setAttributeNS(null, 'x', `${p}`)
              y.setAttributeNS(null, 'y', `${g}`)
              const S = this.svg
              const A = this.transformMatrix
              const E = this.current.fillColor
              const x = this.current.strokeColor
              const C = this.svgFactory.create(m - p, v - g)
              this.svg = C
              this.transformMatrix = n
              if (h === 2) {
                const e = s.Util.makeHexColor(...t)
                this.current.fillColor = e
                this.current.strokeColor = e
              }
              this.executeOpTree(this.convertOpList(i))
              this.svg = S
              this.transformMatrix = A
              this.current.fillColor = E
              this.current.strokeColor = x
              y.append(C.childNodes[0])
              this.defs.append(y)
              return `url(#${u})`
            }

            _makeShadingPattern(e) {
              typeof e === 'string' && (e = this.objs.get(e))
              switch (e[0]) {
                case 'RadialAxial':
                  const t = `shading${f++}`
                  const i = e[3]
                  let n
                  switch (e[1]) {
                    case 'axial':
                      const i = e[4]
                      const s = e[5]
                      n = this.svgFactory.createElement('svg:linearGradient')
                      n.setAttributeNS(null, 'id', t)
                      n.setAttributeNS(null, 'gradientUnits', 'userSpaceOnUse')
                      n.setAttributeNS(null, 'x1', i[0])
                      n.setAttributeNS(null, 'y1', i[1])
                      n.setAttributeNS(null, 'x2', s[0])
                      n.setAttributeNS(null, 'y2', s[1])
                      break
                    case 'radial':
                      const a = e[4]
                      const r = e[5]
                      const o = e[6]
                      const l = e[7]
                      n = this.svgFactory.createElement('svg:radialGradient')
                      n.setAttributeNS(null, 'id', t)
                      n.setAttributeNS(null, 'gradientUnits', 'userSpaceOnUse')
                      n.setAttributeNS(null, 'cx', r[0])
                      n.setAttributeNS(null, 'cy', r[1])
                      n.setAttributeNS(null, 'r', l)
                      n.setAttributeNS(null, 'fx', a[0])
                      n.setAttributeNS(null, 'fy', a[1])
                      n.setAttributeNS(null, 'fr', o)
                      break
                    default:
                      throw new Error(`Unknown RadialAxial type: ${e[1]}`)
                  }
                  for (const e of i) {
                    const t = this.svgFactory.createElement('svg:stop')
                    t.setAttributeNS(null, 'offset', e[0])
                    t.setAttributeNS(null, 'stop-color', e[1])
                    n.append(t)
                  }
                  this.defs.append(n)
                  return `url(#${t})`
                case 'Mesh':
                  ;(0, s.warn)('Unimplemented pattern Mesh')
                  return null
                case 'Dummy':
                  return 'hotpink'
                default:
                  throw new Error(`Unknown IR type: ${e[0]}`)
              }
            }

            setDash(e, t) {
              this.current.dashArray = e
              this.current.dashPhase = t
            }

            constructPath(e, t) {
              const i = this.current
              let n = i.x
              let a = i.y
              let r = []
              let o = 0
              for (const i of e)
                switch (0 | i) {
                  case s.OPS.rectangle:
                    n = t[o++]
                    a = t[o++]
                    const e = n + t[o++]
                    const i = a + t[o++]
                    r.push(
                      'M',
                      pf(n),
                      pf(a),
                      'L',
                      pf(e),
                      pf(a),
                      'L',
                      pf(e),
                      pf(i),
                      'L',
                      pf(n),
                      pf(i),
                      'Z'
                    )
                    break
                  case s.OPS.moveTo:
                    n = t[o++]
                    a = t[o++]
                    r.push('M', pf(n), pf(a))
                    break
                  case s.OPS.lineTo:
                    n = t[o++]
                    a = t[o++]
                    r.push('L', pf(n), pf(a))
                    break
                  case s.OPS.curveTo:
                    n = t[o + 4]
                    a = t[o + 5]
                    r.push('C', pf(t[o]), pf(t[o + 1]), pf(t[o + 2]), pf(t[o + 3]), pf(n), pf(a))
                    o += 6
                    break
                  case s.OPS.curveTo2:
                    r.push('C', pf(n), pf(a), pf(t[o]), pf(t[o + 1]), pf(t[o + 2]), pf(t[o + 3]))
                    n = t[o + 2]
                    a = t[o + 3]
                    o += 4
                    break
                  case s.OPS.curveTo3:
                    n = t[o + 2]
                    a = t[o + 3]
                    r.push('C', pf(t[o]), pf(t[o + 1]), pf(n), pf(a), pf(n), pf(a))
                    o += 4
                    break
                  case s.OPS.closePath:
                    r.push('Z')
                }
              r = r.join(' ')
              if (i.path && e.length > 0 && e[0] !== s.OPS.rectangle && e[0] !== s.OPS.moveTo)
                r = i.path.getAttributeNS(null, 'd') + r
              else {
                i.path = this.svgFactory.createElement('svg:path')
                this._ensureTransformGroup().append(i.path)
              }
              i.path.setAttributeNS(null, 'd', r)
              i.path.setAttributeNS(null, 'fill', 'none')
              i.element = i.path
              i.setCurrentPoint(n, a)
            }

            endPath() {
              const e = this.current
              e.path = null
              if (!this.pendingClip) return
              if (!e.element) {
                this.pendingClip = null
                return
              }
              const t = `clippath${p++}`
              const i = this.svgFactory.createElement('svg:clipPath')
              i.setAttributeNS(null, 'id', t)
              i.setAttributeNS(null, 'transform', pm(this.transformMatrix))
              const n = e.element.cloneNode(!0)
              this.pendingClip === 'evenodd'
                ? n.setAttributeNS(null, 'clip-rule', 'evenodd')
                : n.setAttributeNS(null, 'clip-rule', 'nonzero')
              this.pendingClip = null
              i.append(n)
              this.defs.append(i)
              if (e.activeClipUrl) {
                e.clipGroup = null
                for (const e of this.extraStack) e.clipGroup = null
                i.setAttributeNS(null, 'clip-path', e.activeClipUrl)
              }
              e.activeClipUrl = `url(#${t})`
              this.tgrp = null
            }

            clip(e) {
              this.pendingClip = e
            }

            closePath() {
              const e = this.current
              if (e.path) {
                const t = `${e.path.getAttributeNS(null, 'd')}Z`
                e.path.setAttributeNS(null, 'd', t)
              }
            }

            setLeading(e) {
              this.current.leading = -e
            }

            setTextRise(e) {
              this.current.textRise = e
            }

            setTextRenderingMode(e) {
              this.current.textRenderingMode = e
            }

            setHScale(e) {
              this.current.textHScale = e / 100
            }

            setRenderingIntent(e) {}

            setFlatness(e) {}

            setGState(e) {
              for (const [t, i] of e)
                switch (t) {
                  case 'LW':
                    this.setLineWidth(i)
                    break
                  case 'LC':
                    this.setLineCap(i)
                    break
                  case 'LJ':
                    this.setLineJoin(i)
                    break
                  case 'ML':
                    this.setMiterLimit(i)
                    break
                  case 'D':
                    this.setDash(i[0], i[1])
                    break
                  case 'RI':
                    this.setRenderingIntent(i)
                    break
                  case 'FL':
                    this.setFlatness(i)
                    break
                  case 'Font':
                    this.setFont(i)
                    break
                  case 'CA':
                    this.setStrokeAlpha(i)
                    break
                  case 'ca':
                    this.setFillAlpha(i)
                    break
                  default:
                    ;(0, s.warn)(`Unimplemented graphic state operator ${t}`)
                }
            }

            fill() {
              const e = this.current
              if (e.element) {
                e.element.setAttributeNS(null, 'fill', e.fillColor)
                e.element.setAttributeNS(null, 'fill-opacity', e.fillAlpha)
                this.endPath()
              }
            }

            stroke() {
              const e = this.current
              if (e.element) {
                this._setStrokeAttributes(e.element)
                e.element.setAttributeNS(null, 'fill', 'none')
                this.endPath()
              }
            }

            _setStrokeAttributes(e) {
              const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1
              const i = this.current
              let n = i.dashArray
              t !== 1 &&
                n.length > 0 &&
                (n = n.map(function (e) {
                  return t * e
                }))
              e.setAttributeNS(null, 'stroke', i.strokeColor)
              e.setAttributeNS(null, 'stroke-opacity', i.strokeAlpha)
              e.setAttributeNS(null, 'stroke-miterlimit', pf(i.miterLimit))
              e.setAttributeNS(null, 'stroke-linecap', i.lineCap)
              e.setAttributeNS(null, 'stroke-linejoin', i.lineJoin)
              e.setAttributeNS(null, 'stroke-width', `${pf(t * i.lineWidth)}px`)
              e.setAttributeNS(null, 'stroke-dasharray', n.map(pf).join(' '))
              e.setAttributeNS(null, 'stroke-dashoffset', `${pf(t * i.dashPhase)}px`)
            }

            eoFill() {
              this.current.element &&
                this.current.element.setAttributeNS(null, 'fill-rule', 'evenodd')
              this.fill()
            }

            fillStroke() {
              this.stroke()
              this.fill()
            }

            eoFillStroke() {
              this.current.element &&
                this.current.element.setAttributeNS(null, 'fill-rule', 'evenodd')
              this.fillStroke()
            }

            closeStroke() {
              this.closePath()
              this.stroke()
            }

            closeFillStroke() {
              this.closePath()
              this.fillStroke()
            }

            closeEOFillStroke() {
              this.closePath()
              this.eoFillStroke()
            }

            paintSolidColorImageMask() {
              const e = this.svgFactory.createElement('svg:rect')
              e.setAttributeNS(null, 'x', '0')
              e.setAttributeNS(null, 'y', '0')
              e.setAttributeNS(null, 'width', '1px')
              e.setAttributeNS(null, 'height', '1px')
              e.setAttributeNS(null, 'fill', this.current.fillColor)
              this._ensureTransformGroup().append(e)
            }

            paintImageXObject(e) {
              const t = e.startsWith('g_') ? this.commonObjs.get(e) : this.objs.get(e)
              t
                ? this.paintInlineImageXObject(t)
                : (0, s.warn)(`Dependent image with object ID ${e} is not ready yet`)
            }

            paintInlineImageXObject(e, t) {
              const i = e.width
              const n = e.height
              const s = u(e, this.forceDataSchema, !!t)
              const a = this.svgFactory.createElement('svg:rect')
              a.setAttributeNS(null, 'x', '0')
              a.setAttributeNS(null, 'y', '0')
              a.setAttributeNS(null, 'width', pf(i))
              a.setAttributeNS(null, 'height', pf(n))
              this.current.element = a
              this.clip('nonzero')
              const r = this.svgFactory.createElement('svg:image')
              r.setAttributeNS(c, 'xlink:href', s)
              r.setAttributeNS(null, 'x', '0')
              r.setAttributeNS(null, 'y', pf(-n))
              r.setAttributeNS(null, 'width', `${pf(i)}px`)
              r.setAttributeNS(null, 'height', `${pf(n)}px`)
              r.setAttributeNS(null, 'transform', `scale(${pf(1 / i)} ${pf(-1 / n)})`)
              t ? t.append(r) : this._ensureTransformGroup().append(r)
            }

            paintImageMaskXObject(e) {
              const t = this.current
              const i = e.width
              const n = e.height
              const s = t.fillColor
              t.maskId = `mask${g++}`
              const a = this.svgFactory.createElement('svg:mask')
              a.setAttributeNS(null, 'id', t.maskId)
              const r = this.svgFactory.createElement('svg:rect')
              r.setAttributeNS(null, 'x', '0')
              r.setAttributeNS(null, 'y', '0')
              r.setAttributeNS(null, 'width', pf(i))
              r.setAttributeNS(null, 'height', pf(n))
              r.setAttributeNS(null, 'fill', s)
              r.setAttributeNS(null, 'mask', `url(#${t.maskId})`)
              this.defs.append(a)
              this._ensureTransformGroup().append(r)
              this.paintInlineImageXObject(e, a)
            }

            paintFormXObjectBegin(e, t) {
              Array.isArray(e) &&
                e.length === 6 &&
                this.transform(e[0], e[1], e[2], e[3], e[4], e[5])
              if (t) {
                const e = t[2] - t[0]
                const i = t[3] - t[1]
                const n = this.svgFactory.createElement('svg:rect')
                n.setAttributeNS(null, 'x', t[0])
                n.setAttributeNS(null, 'y', t[1])
                n.setAttributeNS(null, 'width', pf(e))
                n.setAttributeNS(null, 'height', pf(i))
                this.current.element = n
                this.clip('nonzero')
                this.endPath()
              }
            }

            paintFormXObjectEnd() {}

            _initialize(e) {
              const t = this.svgFactory.create(e.width, e.height)
              const i = this.svgFactory.createElement('svg:defs')
              t.append(i)
              this.defs = i
              const n = this.svgFactory.createElement('svg:g')
              n.setAttributeNS(null, 'transform', pm(e.transform))
              t.append(n)
              this.svg = n
              return t
            }

            _ensureClipGroup() {
              if (!this.current.clipGroup) {
                const e = this.svgFactory.createElement('svg:g')
                e.setAttributeNS(null, 'clip-path', this.current.activeClipUrl)
                this.svg.append(e)
                this.current.clipGroup = e
              }
              return this.current.clipGroup
            }

            _ensureTransformGroup() {
              if (!this.tgrp) {
                this.tgrp = this.svgFactory.createElement('svg:g')
                this.tgrp.setAttributeNS(null, 'transform', pm(this.transformMatrix))
                this.current.activeClipUrl
                  ? this._ensureClipGroup().append(this.tgrp)
                  : this.svg.append(this.tgrp)
              }
              return this.tgrp
            }
          }
        }
      },
      (e, t, i) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.PDFNodeStream = void 0
        const n = i(1)
        const s = i(160)
        const a = require('fs')
        const r = require('http')
        const o = require('https')
        const l = require('url')
        const c = /^file:\/\/\/[a-zA-Z]:\//
        t.PDFNodeStream = class PDFNodeStream {
          constructor(e) {
            this.source = e
            this.url = (function parseUrl(e) {
              const t = l.parse(e)
              if (t.protocol === 'file:' || t.host) return t
              if (/^[a-z]:[/\\]/i.test(e)) return l.parse(`file:///${e}`)
              t.host || (t.protocol = 'file:')
              return t
            })(e.url)
            this.isHttp = this.url.protocol === 'http:' || this.url.protocol === 'https:'
            this.isFsUrl = this.url.protocol === 'file:'
            this.httpHeaders = (this.isHttp && e.httpHeaders) || {}
            this._fullRequestReader = null
            this._rangeRequestReaders = []
          }

          get _progressiveDataLength() {
            let e
            let t
            return (e =
              (t = this._fullRequestReader) === null || void 0 === t ? void 0 : t._loaded) !==
              null && void 0 !== e
              ? e
              : 0
          }

          getFullReader() {
            ;(0, n.assert)(
              !this._fullRequestReader,
              'PDFNodeStream.getFullReader can only be called once.'
            )
            this._fullRequestReader = this.isFsUrl
              ? new PDFNodeStreamFsFullReader(this)
              : new PDFNodeStreamFullReader(this)
            return this._fullRequestReader
          }

          getRangeReader(e, t) {
            if (t <= this._progressiveDataLength) return null
            const i = this.isFsUrl
              ? new PDFNodeStreamFsRangeReader(this, e, t)
              : new PDFNodeStreamRangeReader(this, e, t)
            this._rangeRequestReaders.push(i)
            return i
          }

          cancelAllRequests(e) {
            this._fullRequestReader && this._fullRequestReader.cancel(e)
            for (const t of this._rangeRequestReaders.slice(0)) t.cancel(e)
          }
        }
        class BaseFullReader {
          constructor(e) {
            this._url = e.url
            this._done = !1
            this._storedError = null
            this.onProgress = null
            const t = e.source
            this._contentLength = t.length
            this._loaded = 0
            this._filename = null
            this._disableRange = t.disableRange || !1
            this._rangeChunkSize = t.rangeChunkSize
            this._rangeChunkSize || this._disableRange || (this._disableRange = !0)
            this._isStreamingSupported = !t.disableStream
            this._isRangeSupported = !t.disableRange
            this._readableStream = null
            this._readCapability = (0, n.createPromiseCapability)()
            this._headersCapability = (0, n.createPromiseCapability)()
          }

          get headersReady() {
            return this._headersCapability.promise
          }

          get filename() {
            return this._filename
          }

          get contentLength() {
            return this._contentLength
          }

          get isRangeSupported() {
            return this._isRangeSupported
          }

          get isStreamingSupported() {
            return this._isStreamingSupported
          }

          async read() {
            await this._readCapability.promise
            if (this._done) return { value: void 0, done: !0 }
            if (this._storedError) throw this._storedError
            const e = this._readableStream.read()
            if (e === null) {
              this._readCapability = (0, n.createPromiseCapability)()
              return this.read()
            }
            this._loaded += e.length
            this.onProgress && this.onProgress({ loaded: this._loaded, total: this._contentLength })
            return { value: new Uint8Array(e).buffer, done: !1 }
          }

          cancel(e) {
            this._readableStream ? this._readableStream.destroy(e) : this._error(e)
          }

          _error(e) {
            this._storedError = e
            this._readCapability.resolve()
          }

          _setReadableStream(e) {
            this._readableStream = e
            e.on('readable', () => {
              this._readCapability.resolve()
            })
            e.on('end', () => {
              e.destroy()
              this._done = !0
              this._readCapability.resolve()
            })
            e.on('error', (e) => {
              this._error(e)
            })
            !this._isStreamingSupported &&
              this._isRangeSupported &&
              this._error(new n.AbortException('streaming is disabled'))
            this._storedError && this._readableStream.destroy(this._storedError)
          }
        }
        class BaseRangeReader {
          constructor(e) {
            this._url = e.url
            this._done = !1
            this._storedError = null
            this.onProgress = null
            this._loaded = 0
            this._readableStream = null
            this._readCapability = (0, n.createPromiseCapability)()
            const t = e.source
            this._isStreamingSupported = !t.disableStream
          }

          get isStreamingSupported() {
            return this._isStreamingSupported
          }

          async read() {
            await this._readCapability.promise
            if (this._done) return { value: void 0, done: !0 }
            if (this._storedError) throw this._storedError
            const e = this._readableStream.read()
            if (e === null) {
              this._readCapability = (0, n.createPromiseCapability)()
              return this.read()
            }
            this._loaded += e.length
            this.onProgress && this.onProgress({ loaded: this._loaded })
            return { value: new Uint8Array(e).buffer, done: !1 }
          }

          cancel(e) {
            this._readableStream ? this._readableStream.destroy(e) : this._error(e)
          }

          _error(e) {
            this._storedError = e
            this._readCapability.resolve()
          }

          _setReadableStream(e) {
            this._readableStream = e
            e.on('readable', () => {
              this._readCapability.resolve()
            })
            e.on('end', () => {
              e.destroy()
              this._done = !0
              this._readCapability.resolve()
            })
            e.on('error', (e) => {
              this._error(e)
            })
            this._storedError && this._readableStream.destroy(this._storedError)
          }
        }
        function createRequestOptions(e, t) {
          return {
            protocol: e.protocol,
            auth: e.auth,
            host: e.hostname,
            port: e.port,
            path: e.path,
            method: 'GET',
            headers: t
          }
        }
        class PDFNodeStreamFullReader extends BaseFullReader {
          constructor(e) {
            super(e)
            const handleResponse = (t) => {
              if (t.statusCode === 404) {
                const e = new n.MissingPDFException(`Missing PDF "${this._url}".`)
                this._storedError = e
                this._headersCapability.reject(e)
                return
              }
              this._headersCapability.resolve()
              this._setReadableStream(t)
              const getResponseHeader = (e) => this._readableStream.headers[e.toLowerCase()]
              const { allowRangeRequests: i, suggestedLength: a } = (0,
              s.validateRangeRequestCapabilities)({
                getResponseHeader,
                isHttp: e.isHttp,
                rangeChunkSize: this._rangeChunkSize,
                disableRange: this._disableRange
              })
              this._isRangeSupported = i
              this._contentLength = a || this._contentLength
              this._filename = (0, s.extractFilenameFromHeader)(getResponseHeader)
            }
            this._request = null
            this._url.protocol === 'http:'
              ? (this._request = r.request(
                  createRequestOptions(this._url, e.httpHeaders),
                  handleResponse
                ))
              : (this._request = o.request(
                  createRequestOptions(this._url, e.httpHeaders),
                  handleResponse
                ))
            this._request.on('error', (e) => {
              this._storedError = e
              this._headersCapability.reject(e)
            })
            this._request.end()
          }
        }
        class PDFNodeStreamRangeReader extends BaseRangeReader {
          constructor(e, t, i) {
            super(e)
            this._httpHeaders = {}
            for (const t in e.httpHeaders) {
              const i = e.httpHeaders[t]
              void 0 !== i && (this._httpHeaders[t] = i)
            }
            this._httpHeaders.Range = `bytes=${t}-${i - 1}`
            const handleResponse = (e) => {
              if (e.statusCode !== 404) this._setReadableStream(e)
              else {
                const e = new n.MissingPDFException(`Missing PDF "${this._url}".`)
                this._storedError = e
              }
            }
            this._request = null
            this._url.protocol === 'http:'
              ? (this._request = r.request(
                  createRequestOptions(this._url, this._httpHeaders),
                  handleResponse
                ))
              : (this._request = o.request(
                  createRequestOptions(this._url, this._httpHeaders),
                  handleResponse
                ))
            this._request.on('error', (e) => {
              this._storedError = e
            })
            this._request.end()
          }
        }
        class PDFNodeStreamFsFullReader extends BaseFullReader {
          constructor(e) {
            super(e)
            let t = decodeURIComponent(this._url.path)
            c.test(this._url.href) && (t = t.replace(/^\//, ''))
            a.lstat(t, (e, i) => {
              if (e) {
                e.code === 'ENOENT' && (e = new n.MissingPDFException(`Missing PDF "${t}".`))
                this._storedError = e
                this._headersCapability.reject(e)
              } else {
                this._contentLength = i.size
                this._setReadableStream(a.createReadStream(t))
                this._headersCapability.resolve()
              }
            })
          }
        }
        class PDFNodeStreamFsRangeReader extends BaseRangeReader {
          constructor(e, t, i) {
            super(e)
            let n = decodeURIComponent(this._url.path)
            c.test(this._url.href) && (n = n.replace(/^\//, ''))
            this._setReadableStream(a.createReadStream(n, { start: t, end: i - 1 }))
          }
        }
      },
      (e, t, i) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.createResponseStatusError = function createResponseStatusError(e, t) {
          if (e === 404 || (e === 0 && t.startsWith('file:')))
            return new n.MissingPDFException(`Missing PDF "${t}".`)
          return new n.UnexpectedResponseException(
            `Unexpected server response (${e}) while retrieving PDF "${t}".`,
            e
          )
        }
        t.extractFilenameFromHeader = function extractFilenameFromHeader(e) {
          const t = e('Content-Disposition')
          if (t) {
            let e = (0, s.getFilenameFromContentDispositionHeader)(t)
            if (e.includes('%'))
              try {
                e = decodeURIComponent(e)
              } catch (e) {}
            if ((0, a.isPdfFile)(e)) return e
          }
          return null
        }
        t.validateRangeRequestCapabilities = function validateRangeRequestCapabilities(e) {
          const { getResponseHeader: t, isHttp: i, rangeChunkSize: n, disableRange: s } = e
          const a = { allowRangeRequests: !1, suggestedLength: void 0 }
          const r = parseInt(t('Content-Length'), 10)
          if (!Number.isInteger(r)) return a
          a.suggestedLength = r
          if (r <= 2 * n) return a
          if (s || !i) return a
          if (t('Accept-Ranges') !== 'bytes') return a
          if ((t('Content-Encoding') || 'identity') !== 'identity') return a
          a.allowRangeRequests = !0
          return a
        }
        t.validateResponseStatus = function validateResponseStatus(e) {
          return e === 200 || e === 206
        }
        var n = i(1)
        var s = i(161)
        var a = i(133)
      },
      (e, t, i) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.getFilenameFromContentDispositionHeader =
          function getFilenameFromContentDispositionHeader(e) {
            let t = !0
            let i = toParamRegExp('filename\\*', 'i').exec(e)
            if (i) {
              i = i[1]
              let e = rfc2616unquote(i)
              e = unescape(e)
              e = rfc5987decode(e)
              e = rfc2047decode(e)
              return fixupEncoding(e)
            }
            i = (function rfc2231getparam(e) {
              const t = []
              let i
              const n = toParamRegExp('filename\\*((?!0\\d)\\d+)(\\*?)', 'ig')
              for (; (i = n.exec(e)) !== null; ) {
                let [, e, n, s] = i
                e = parseInt(e, 10)
                if (e in t) {
                  if (e === 0) break
                } else t[e] = [n, s]
              }
              const s = []
              for (let e = 0; e < t.length && e in t; ++e) {
                let [i, n] = t[e]
                n = rfc2616unquote(n)
                if (i) {
                  n = unescape(n)
                  e === 0 && (n = rfc5987decode(n))
                }
                s.push(n)
              }
              return s.join('')
            })(e)
            if (i) {
              return fixupEncoding(rfc2047decode(i))
            }
            i = toParamRegExp('filename', 'i').exec(e)
            if (i) {
              i = i[1]
              let e = rfc2616unquote(i)
              e = rfc2047decode(e)
              return fixupEncoding(e)
            }
            function toParamRegExp(e, t) {
              return new RegExp(
                `(?:^|;)\\s*${e}\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)`,
                t
              )
            }
            function textdecode(e, i) {
              if (e) {
                if (!/^[\x00-\xFF]+$/.test(i)) return i
                try {
                  const s = new TextDecoder(e, { fatal: !0 })
                  const a = (0, n.stringToBytes)(i)
                  i = s.decode(a)
                  t = !1
                } catch (e) {}
              }
              return i
            }
            function fixupEncoding(e) {
              if (t && /[\x80-\xff]/.test(e)) {
                e = textdecode('utf-8', e)
                t && (e = textdecode('iso-8859-1', e))
              }
              return e
            }
            function rfc2616unquote(e) {
              if (e.startsWith('"')) {
                const t = e.slice(1).split('\\"')
                for (let e = 0; e < t.length; ++e) {
                  const i = t[e].indexOf('"')
                  if (i !== -1) {
                    t[e] = t[e].slice(0, i)
                    t.length = e + 1
                  }
                  t[e] = t[e].replace(/\\(.)/g, '$1')
                }
                e = t.join('"')
              }
              return e
            }
            function rfc5987decode(e) {
              const t = e.indexOf("'")
              if (t === -1) return e
              return textdecode(e.slice(0, t), e.slice(t + 1).replace(/^[^']*'/, ''))
            }
            function rfc2047decode(e) {
              return !e.startsWith('=?') || /[\x00-\x19\x80-\xff]/.test(e)
                ? e
                : e.replace(
                    /=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g,
                    function (e, t, i, n) {
                      if (i === 'q' || i === 'Q')
                        return textdecode(
                          t,
                          (n = (n = n.replace(/_/g, ' ')).replace(
                            /=([0-9a-fA-F]{2})/g,
                            function (e, t) {
                              return String.fromCharCode(parseInt(t, 16))
                            }
                          ))
                        )
                      try {
                        n = atob(n)
                      } catch (e) {}
                      return textdecode(t, n)
                    }
                  )
            }
            return ''
          }
        var n = i(1)
      },
      (e, t, i) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.PDFNetworkStream = void 0
        const n = i(1)
        const s = i(160)
        class NetworkManager {
          constructor(e) {
            const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
            this.url = e
            this.isHttp = /^https?:/i.test(e)
            this.httpHeaders = (this.isHttp && t.httpHeaders) || Object.create(null)
            this.withCredentials = t.withCredentials || !1
            this.getXhr =
              t.getXhr ||
              function NetworkManager_getXhr() {
                return new XMLHttpRequest()
              }
            this.currXhrId = 0
            this.pendingRequests = Object.create(null)
          }

          requestRange(e, t, i) {
            const n = { begin: e, end: t }
            for (const e in i) n[e] = i[e]
            return this.request(n)
          }

          requestFull(e) {
            return this.request(e)
          }

          request(e) {
            const t = this.getXhr()
            const i = this.currXhrId++
            const n = (this.pendingRequests[i] = { xhr: t })
            t.open('GET', this.url)
            t.withCredentials = this.withCredentials
            for (const e in this.httpHeaders) {
              const i = this.httpHeaders[e]
              void 0 !== i && t.setRequestHeader(e, i)
            }
            if (this.isHttp && 'begin' in e && 'end' in e) {
              t.setRequestHeader('Range', `bytes=${e.begin}-${e.end - 1}`)
              n.expectedStatus = 206
            } else n.expectedStatus = 200
            t.responseType = 'arraybuffer'
            e.onError &&
              (t.onerror = function (i) {
                e.onError(t.status)
              })
            t.onreadystatechange = this.onStateChange.bind(this, i)
            t.onprogress = this.onProgress.bind(this, i)
            n.onHeadersReceived = e.onHeadersReceived
            n.onDone = e.onDone
            n.onError = e.onError
            n.onProgress = e.onProgress
            t.send(null)
            return i
          }

          onProgress(e, t) {
            let i
            const n = this.pendingRequests[e]
            n && ((i = n.onProgress) === null || void 0 === i || i.call(n, t))
          }

          onStateChange(e, t) {
            const i = this.pendingRequests[e]
            if (!i) return
            const s = i.xhr
            if (s.readyState >= 2 && i.onHeadersReceived) {
              i.onHeadersReceived()
              delete i.onHeadersReceived
            }
            if (s.readyState !== 4) return
            if (!(e in this.pendingRequests)) return
            delete this.pendingRequests[e]
            if (s.status === 0 && this.isHttp) {
              let a
              ;(a = i.onError) === null || void 0 === a || a.call(i, s.status)
              return
            }
            const r = s.status || 200
            if (!(r === 200 && i.expectedStatus === 206) && r !== i.expectedStatus) {
              let o
              ;(o = i.onError) === null || void 0 === o || o.call(i, s.status)
              return
            }
            const l = (function getArrayBuffer(e) {
              const t = e.response
              return typeof t !== 'string' ? t : (0, n.stringToBytes)(t).buffer
            })(s)
            if (r === 206) {
              const e = s.getResponseHeader('Content-Range')
              const t = /bytes (\d+)-(\d+)\/(\d+)/.exec(e)
              i.onDone({ begin: parseInt(t[1], 10), chunk: l })
            } else if (l) i.onDone({ begin: 0, chunk: l })
            else {
              let c
              ;(c = i.onError) === null || void 0 === c || c.call(i, s.status)
            }
          }

          getRequestXhr(e) {
            return this.pendingRequests[e].xhr
          }

          isPendingRequest(e) {
            return e in this.pendingRequests
          }

          abortRequest(e) {
            const t = this.pendingRequests[e].xhr
            delete this.pendingRequests[e]
            t.abort()
          }
        }
        t.PDFNetworkStream = class PDFNetworkStream {
          constructor(e) {
            this._source = e
            this._manager = new NetworkManager(e.url, {
              httpHeaders: e.httpHeaders,
              withCredentials: e.withCredentials
            })
            this._rangeChunkSize = e.rangeChunkSize
            this._fullRequestReader = null
            this._rangeRequestReaders = []
          }

          _onRangeRequestReaderClosed(e) {
            const t = this._rangeRequestReaders.indexOf(e)
            t >= 0 && this._rangeRequestReaders.splice(t, 1)
          }

          getFullReader() {
            ;(0, n.assert)(
              !this._fullRequestReader,
              'PDFNetworkStream.getFullReader can only be called once.'
            )
            this._fullRequestReader = new PDFNetworkStreamFullRequestReader(
              this._manager,
              this._source
            )
            return this._fullRequestReader
          }

          getRangeReader(e, t) {
            const i = new PDFNetworkStreamRangeRequestReader(this._manager, e, t)
            i.onClosed = this._onRangeRequestReaderClosed.bind(this)
            this._rangeRequestReaders.push(i)
            return i
          }

          cancelAllRequests(e) {
            let t
            ;(t = this._fullRequestReader) === null || void 0 === t || t.cancel(e)
            for (const t of this._rangeRequestReaders.slice(0)) t.cancel(e)
          }
        }
        class PDFNetworkStreamFullRequestReader {
          constructor(e, t) {
            this._manager = e
            const i = {
              onHeadersReceived: this._onHeadersReceived.bind(this),
              onDone: this._onDone.bind(this),
              onError: this._onError.bind(this),
              onProgress: this._onProgress.bind(this)
            }
            this._url = t.url
            this._fullRequestId = e.requestFull(i)
            this._headersReceivedCapability = (0, n.createPromiseCapability)()
            this._disableRange = t.disableRange || !1
            this._contentLength = t.length
            this._rangeChunkSize = t.rangeChunkSize
            this._rangeChunkSize || this._disableRange || (this._disableRange = !0)
            this._isStreamingSupported = !1
            this._isRangeSupported = !1
            this._cachedChunks = []
            this._requests = []
            this._done = !1
            this._storedError = void 0
            this._filename = null
            this.onProgress = null
          }

          _onHeadersReceived() {
            const e = this._fullRequestId
            const t = this._manager.getRequestXhr(e)
            const getResponseHeader = (e) => t.getResponseHeader(e)
            const { allowRangeRequests: i, suggestedLength: n } = (0,
            s.validateRangeRequestCapabilities)({
              getResponseHeader,
              isHttp: this._manager.isHttp,
              rangeChunkSize: this._rangeChunkSize,
              disableRange: this._disableRange
            })
            i && (this._isRangeSupported = !0)
            this._contentLength = n || this._contentLength
            this._filename = (0, s.extractFilenameFromHeader)(getResponseHeader)
            this._isRangeSupported && this._manager.abortRequest(e)
            this._headersReceivedCapability.resolve()
          }

          _onDone(e) {
            if (e)
              if (this._requests.length > 0) {
                this._requests.shift().resolve({ value: e.chunk, done: !1 })
              } else this._cachedChunks.push(e.chunk)
            this._done = !0
            if (!(this._cachedChunks.length > 0)) {
              for (const e of this._requests) e.resolve({ value: void 0, done: !0 })
              this._requests.length = 0
            }
          }

          _onError(e) {
            this._storedError = (0, s.createResponseStatusError)(e, this._url)
            this._headersReceivedCapability.reject(this._storedError)
            for (const e of this._requests) e.reject(this._storedError)
            this._requests.length = 0
            this._cachedChunks.length = 0
          }

          _onProgress(e) {
            let t
            ;(t = this.onProgress) === null ||
              void 0 === t ||
              t.call(this, {
                loaded: e.loaded,
                total: e.lengthComputable ? e.total : this._contentLength
              })
          }

          get filename() {
            return this._filename
          }

          get isRangeSupported() {
            return this._isRangeSupported
          }

          get isStreamingSupported() {
            return this._isStreamingSupported
          }

          get contentLength() {
            return this._contentLength
          }

          get headersReady() {
            return this._headersReceivedCapability.promise
          }

          async read() {
            if (this._storedError) throw this._storedError
            if (this._cachedChunks.length > 0) {
              return { value: this._cachedChunks.shift(), done: !1 }
            }
            if (this._done) return { value: void 0, done: !0 }
            const e = (0, n.createPromiseCapability)()
            this._requests.push(e)
            return e.promise
          }

          cancel(e) {
            this._done = !0
            this._headersReceivedCapability.reject(e)
            for (const e of this._requests) e.resolve({ value: void 0, done: !0 })
            this._requests.length = 0
            this._manager.isPendingRequest(this._fullRequestId) &&
              this._manager.abortRequest(this._fullRequestId)
            this._fullRequestReader = null
          }
        }
        class PDFNetworkStreamRangeRequestReader {
          constructor(e, t, i) {
            this._manager = e
            const n = {
              onDone: this._onDone.bind(this),
              onError: this._onError.bind(this),
              onProgress: this._onProgress.bind(this)
            }
            this._url = e.url
            this._requestId = e.requestRange(t, i, n)
            this._requests = []
            this._queuedChunk = null
            this._done = !1
            this._storedError = void 0
            this.onProgress = null
            this.onClosed = null
          }

          _close() {
            let e
            ;(e = this.onClosed) === null || void 0 === e || e.call(this, this)
          }

          _onDone(e) {
            const t = e.chunk
            if (this._requests.length > 0) {
              this._requests.shift().resolve({ value: t, done: !1 })
            } else this._queuedChunk = t
            this._done = !0
            for (const e of this._requests) e.resolve({ value: void 0, done: !0 })
            this._requests.length = 0
            this._close()
          }

          _onError(e) {
            this._storedError = (0, s.createResponseStatusError)(e, this._url)
            for (const e of this._requests) e.reject(this._storedError)
            this._requests.length = 0
            this._queuedChunk = null
          }

          _onProgress(e) {
            if (!this.isStreamingSupported) {
              let t
              ;(t = this.onProgress) === null || void 0 === t || t.call(this, { loaded: e.loaded })
            }
          }

          get isStreamingSupported() {
            return !1
          }

          async read() {
            if (this._storedError) throw this._storedError
            if (this._queuedChunk !== null) {
              const e = this._queuedChunk
              this._queuedChunk = null
              return { value: e, done: !1 }
            }
            if (this._done) return { value: void 0, done: !0 }
            const e = (0, n.createPromiseCapability)()
            this._requests.push(e)
            return e.promise
          }

          cancel(e) {
            this._done = !0
            for (const e of this._requests) e.resolve({ value: void 0, done: !0 })
            this._requests.length = 0
            this._manager.isPendingRequest(this._requestId) &&
              this._manager.abortRequest(this._requestId)
            this._close()
          }
        }
      },
      (e, t, i) => {
        Object.defineProperty(t, '__esModule', { value: !0 })
        t.PDFFetchStream = void 0
        const n = i(1)
        const s = i(160)
        function createFetchOptions(e, t, i) {
          return {
            method: 'GET',
            headers: e,
            signal: i.signal,
            mode: 'cors',
            credentials: t ? 'include' : 'same-origin',
            redirect: 'follow'
          }
        }
        function createHeaders(e) {
          const t = new Headers()
          for (const i in e) {
            const n = e[i]
            void 0 !== n && t.append(i, n)
          }
          return t
        }
        t.PDFFetchStream = class PDFFetchStream {
          constructor(e) {
            this.source = e
            this.isHttp = /^https?:/i.test(e.url)
            this.httpHeaders = (this.isHttp && e.httpHeaders) || {}
            this._fullRequestReader = null
            this._rangeRequestReaders = []
          }

          get _progressiveDataLength() {
            let e
            let t
            return (e =
              (t = this._fullRequestReader) === null || void 0 === t ? void 0 : t._loaded) !==
              null && void 0 !== e
              ? e
              : 0
          }

          getFullReader() {
            ;(0, n.assert)(
              !this._fullRequestReader,
              'PDFFetchStream.getFullReader can only be called once.'
            )
            this._fullRequestReader = new PDFFetchStreamReader(this)
            return this._fullRequestReader
          }

          getRangeReader(e, t) {
            if (t <= this._progressiveDataLength) return null
            const i = new PDFFetchStreamRangeReader(this, e, t)
            this._rangeRequestReaders.push(i)
            return i
          }

          cancelAllRequests(e) {
            this._fullRequestReader && this._fullRequestReader.cancel(e)
            for (const t of this._rangeRequestReaders.slice(0)) t.cancel(e)
          }
        }
        class PDFFetchStreamReader {
          constructor(e) {
            this._stream = e
            this._reader = null
            this._loaded = 0
            this._filename = null
            const t = e.source
            this._withCredentials = t.withCredentials || !1
            this._contentLength = t.length
            this._headersCapability = (0, n.createPromiseCapability)()
            this._disableRange = t.disableRange || !1
            this._rangeChunkSize = t.rangeChunkSize
            this._rangeChunkSize || this._disableRange || (this._disableRange = !0)
            this._abortController = new AbortController()
            this._isStreamingSupported = !t.disableStream
            this._isRangeSupported = !t.disableRange
            this._headers = createHeaders(this._stream.httpHeaders)
            const i = t.url
            fetch(
              i,
              createFetchOptions(this._headers, this._withCredentials, this._abortController)
            )
              .then((e) => {
                if (!(0, s.validateResponseStatus)(e.status))
                  throw (0, s.createResponseStatusError)(e.status, i)
                this._reader = e.body.getReader()
                this._headersCapability.resolve()
                const getResponseHeader = (t) => e.headers.get(t)
                const { allowRangeRequests: t, suggestedLength: a } = (0,
                s.validateRangeRequestCapabilities)({
                  getResponseHeader,
                  isHttp: this._stream.isHttp,
                  rangeChunkSize: this._rangeChunkSize,
                  disableRange: this._disableRange
                })
                this._isRangeSupported = t
                this._contentLength = a || this._contentLength
                this._filename = (0, s.extractFilenameFromHeader)(getResponseHeader)
                !this._isStreamingSupported &&
                  this._isRangeSupported &&
                  this.cancel(new n.AbortException('Streaming is disabled.'))
              })
              .catch(this._headersCapability.reject)
            this.onProgress = null
          }

          get headersReady() {
            return this._headersCapability.promise
          }

          get filename() {
            return this._filename
          }

          get contentLength() {
            return this._contentLength
          }

          get isRangeSupported() {
            return this._isRangeSupported
          }

          get isStreamingSupported() {
            return this._isStreamingSupported
          }

          async read() {
            await this._headersCapability.promise
            const { value: e, done: t } = await this._reader.read()
            if (t) return { value: e, done: t }
            this._loaded += e.byteLength
            this.onProgress && this.onProgress({ loaded: this._loaded, total: this._contentLength })
            return { value: new Uint8Array(e).buffer, done: !1 }
          }

          cancel(e) {
            this._reader && this._reader.cancel(e)
            this._abortController.abort()
          }
        }
        class PDFFetchStreamRangeReader {
          constructor(e, t, i) {
            this._stream = e
            this._reader = null
            this._loaded = 0
            const a = e.source
            this._withCredentials = a.withCredentials || !1
            this._readCapability = (0, n.createPromiseCapability)()
            this._isStreamingSupported = !a.disableStream
            this._abortController = new AbortController()
            this._headers = createHeaders(this._stream.httpHeaders)
            this._headers.append('Range', `bytes=${t}-${i - 1}`)
            const r = a.url
            fetch(
              r,
              createFetchOptions(this._headers, this._withCredentials, this._abortController)
            )
              .then((e) => {
                if (!(0, s.validateResponseStatus)(e.status))
                  throw (0, s.createResponseStatusError)(e.status, r)
                this._readCapability.resolve()
                this._reader = e.body.getReader()
              })
              .catch(this._readCapability.reject)
            this.onProgress = null
          }

          get isStreamingSupported() {
            return this._isStreamingSupported
          }

          async read() {
            await this._readCapability.promise
            const { value: e, done: t } = await this._reader.read()
            if (t) return { value: e, done: t }
            this._loaded += e.byteLength
            this.onProgress && this.onProgress({ loaded: this._loaded })
            return { value: new Uint8Array(e).buffer, done: !1 }
          }

          cancel(e) {
            this._reader && this._reader.cancel(e)
            this._abortController.abort()
          }
        }
      }
    ]
    const __webpack_module_cache__ = {}
    function __w_pdfjs_require__(e) {
      const t = __webpack_module_cache__[e]
      if (void 0 !== t) return t.exports
      const i = (__webpack_module_cache__[e] = { exports: {} })
      __webpack_modules__[e](i, i.exports, __w_pdfjs_require__)
      return i.exports
    }
    const __webpack_exports__ = {}
    ;(() => {
      const e = __webpack_exports__
      Object.defineProperty(e, '__esModule', { value: !0 })
      Object.defineProperty(e, 'AnnotationEditorLayer', {
        enumerable: !0,
        get() {
          return s.AnnotationEditorLayer
        }
      })
      Object.defineProperty(e, 'AnnotationEditorParamsType', {
        enumerable: !0,
        get() {
          return t.AnnotationEditorParamsType
        }
      })
      Object.defineProperty(e, 'AnnotationEditorType', {
        enumerable: !0,
        get() {
          return t.AnnotationEditorType
        }
      })
      Object.defineProperty(e, 'AnnotationEditorUIManager', {
        enumerable: !0,
        get() {
          return a.AnnotationEditorUIManager
        }
      })
      Object.defineProperty(e, 'AnnotationLayer', {
        enumerable: !0,
        get() {
          return r.AnnotationLayer
        }
      })
      Object.defineProperty(e, 'AnnotationMode', {
        enumerable: !0,
        get() {
          return t.AnnotationMode
        }
      })
      Object.defineProperty(e, 'CMapCompressionType', {
        enumerable: !0,
        get() {
          return t.CMapCompressionType
        }
      })
      Object.defineProperty(e, 'GlobalSensWords', {
        enumerable: !0,
        get() {
          return u.GlobalSensWords
        }
      })
      Object.defineProperty(e, 'GlobalWorkerOptions', {
        enumerable: !0,
        get() {
          return o.GlobalWorkerOptions
        }
      })
      Object.defineProperty(e, 'InvalidPDFException', {
        enumerable: !0,
        get() {
          return t.InvalidPDFException
        }
      })
      Object.defineProperty(e, 'LoopbackPort', {
        enumerable: !0,
        get() {
          return i.LoopbackPort
        }
      })
      Object.defineProperty(e, 'MissingPDFException', {
        enumerable: !0,
        get() {
          return t.MissingPDFException
        }
      })
      Object.defineProperty(e, 'OPS', {
        enumerable: !0,
        get() {
          return t.OPS
        }
      })
      Object.defineProperty(e, 'PDFDataRangeTransport', {
        enumerable: !0,
        get() {
          return i.PDFDataRangeTransport
        }
      })
      Object.defineProperty(e, 'PDFDateString', {
        enumerable: !0,
        get() {
          return n.PDFDateString
        }
      })
      Object.defineProperty(e, 'PDFWorker', {
        enumerable: !0,
        get() {
          return i.PDFWorker
        }
      })
      Object.defineProperty(e, 'PasswordResponses', {
        enumerable: !0,
        get() {
          return t.PasswordResponses
        }
      })
      Object.defineProperty(e, 'PermissionFlag', {
        enumerable: !0,
        get() {
          return t.PermissionFlag
        }
      })
      Object.defineProperty(e, 'PixelsPerInch', {
        enumerable: !0,
        get() {
          return n.PixelsPerInch
        }
      })
      Object.defineProperty(e, 'RenderingCancelledException', {
        enumerable: !0,
        get() {
          return n.RenderingCancelledException
        }
      })
      Object.defineProperty(e, 'SVGGraphics', {
        enumerable: !0,
        get() {
          return d.SVGGraphics
        }
      })
      Object.defineProperty(e, 'UNSUPPORTED_FEATURES', {
        enumerable: !0,
        get() {
          return t.UNSUPPORTED_FEATURES
        }
      })
      Object.defineProperty(e, 'UnexpectedResponseException', {
        enumerable: !0,
        get() {
          return t.UnexpectedResponseException
        }
      })
      Object.defineProperty(e, 'Util', {
        enumerable: !0,
        get() {
          return t.Util
        }
      })
      Object.defineProperty(e, 'VerbosityLevel', {
        enumerable: !0,
        get() {
          return t.VerbosityLevel
        }
      })
      Object.defineProperty(e, 'XfaLayer', {
        enumerable: !0,
        get() {
          return h.XfaLayer
        }
      })
      Object.defineProperty(e, 'build', {
        enumerable: !0,
        get() {
          return i.build
        }
      })
      Object.defineProperty(e, 'createPromiseCapability', {
        enumerable: !0,
        get() {
          return t.createPromiseCapability
        }
      })
      Object.defineProperty(e, 'createValidAbsoluteUrl', {
        enumerable: !0,
        get() {
          return t.createValidAbsoluteUrl
        }
      })
      Object.defineProperty(e, 'getDocument', {
        enumerable: !0,
        get() {
          return i.getDocument
        }
      })
      Object.defineProperty(e, 'getFilenameFromUrl', {
        enumerable: !0,
        get() {
          return n.getFilenameFromUrl
        }
      })
      Object.defineProperty(e, 'getPdfFilenameFromUrl', {
        enumerable: !0,
        get() {
          return n.getPdfFilenameFromUrl
        }
      })
      Object.defineProperty(e, 'getXfaPageViewport', {
        enumerable: !0,
        get() {
          return n.getXfaPageViewport
        }
      })
      Object.defineProperty(e, 'isPdfFile', {
        enumerable: !0,
        get() {
          return n.isPdfFile
        }
      })
      Object.defineProperty(e, 'loadScript', {
        enumerable: !0,
        get() {
          return n.loadScript
        }
      })
      Object.defineProperty(e, 'renderTextLayer', {
        enumerable: !0,
        get() {
          return c.renderTextLayer
        }
      })
      Object.defineProperty(e, 'shadow', {
        enumerable: !0,
        get() {
          return t.shadow
        }
      })
      Object.defineProperty(e, 'version', {
        enumerable: !0,
        get() {
          return i.version
        }
      })
      var t = __w_pdfjs_require__(1)
      var i = __w_pdfjs_require__(129)
      var n = __w_pdfjs_require__(133)
      var s = __w_pdfjs_require__(149)
      var a = __w_pdfjs_require__(132)
      var r = __w_pdfjs_require__(154)
      var o = __w_pdfjs_require__(142)
      const l = __w_pdfjs_require__(3)
      var c = __w_pdfjs_require__(157)
      var d = __w_pdfjs_require__(158)
      var h = __w_pdfjs_require__(156)
      var u = __w_pdfjs_require__(141)
      if (l.isNodeJS) {
        const { PDFNodeStream: e } = __w_pdfjs_require__(159)
        ;(0, i.setPDFNetworkStreamFactory)((t) => new e(t))
      } else {
        const { PDFNetworkStream: e } = __w_pdfjs_require__(162)
        const { PDFFetchStream: t } = __w_pdfjs_require__(163)
        ;(0, i.setPDFNetworkStreamFactory)((i) =>
          (0, n.isValidFetchUrl)(i.url) ? new t(i) : new e(i)
        )
      }
    })()
    return __webpack_exports__
  })()
)
/**
 * @licstart The following is the entire license notice for the
 * JavaScript code in this page
 *
 * Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * JavaScript code in this page
 */
;(() => {
  const e = [
    ,
    (e, t) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.animationStarted =
        t.VERTICAL_PADDING =
        t.UNKNOWN_SCALE =
        t.TextLayerMode =
        t.SpreadMode =
        t.SidebarView =
        t.ScrollMode =
        t.SCROLLBAR_PADDING =
        t.RenderingStates =
        t.RendererType =
        t.ProgressBar =
        t.PresentationModeState =
        t.OutputScale =
        t.MIN_SCALE =
        t.MAX_SCALE =
        t.MAX_AUTO_SCALE =
        t.DEFAULT_SCALE_VALUE =
        t.DEFAULT_SCALE_DELTA =
        t.DEFAULT_SCALE =
        t.AutoPrintRegExp =
          void 0
      t.apiPageLayoutToViewerModes = function apiPageLayoutToViewerModes(e) {
        let t = n.VERTICAL
        let i = s.NONE
        switch (e) {
          case 'SinglePage':
            t = n.PAGE
            break
          case 'OneColumn':
            break
          case 'TwoPageLeft':
            t = n.PAGE
          case 'TwoColumnLeft':
            i = s.ODD
            break
          case 'TwoPageRight':
            t = n.PAGE
          case 'TwoColumnRight':
            i = s.EVEN
        }
        return { scrollMode: t, spreadMode: i }
      }
      t.apiPageModeToSidebarView = function apiPageModeToSidebarView(e) {
        switch (e) {
          case 'UseNone':
            return i.NONE
          case 'UseThumbs':
            return i.THUMBS
          case 'UseOutlines':
            return i.OUTLINE
          case 'UseAttachments':
            return i.ATTACHMENTS
          case 'UseOC':
            return i.LAYERS
        }
        return i.NONE
      }
      t.approximateFraction = function approximateFraction(e) {
        if (Math.floor(e) === e) return [e, 1]
        const t = 1 / e
        if (t > 8) return [1, 8]
        if (Math.floor(t) === t) return [1, t]
        const i = e > 1 ? t : e
        let n
        let s = 0
        let a = 1
        let r = 1
        let o = 1
        for (;;) {
          const e = s + r
          const t = a + o
          if (t > 8) break
          if (i <= e / t) {
            r = e
            o = t
          } else {
            s = e
            a = t
          }
        }
        n = i - s / a < r / o - i ? (i === e ? [s, a] : [a, s]) : i === e ? [r, o] : [o, r]
        return n
      }
      t.backtrackBeforeAllVisibleElements = backtrackBeforeAllVisibleElements
      t.binarySearchFirstItem = binarySearchFirstItem
      t.docStyle = void 0
      t.getActiveOrFocusedElement = function getActiveOrFocusedElement() {
        let e = document
        let t = e.activeElement || e.querySelector(':focus')
        for (; (i = t) !== null && void 0 !== i && i.shadowRoot; ) {
          var i
          e = t.shadowRoot
          t = e.activeElement || e.querySelector(':focus')
        }
        return t
      }
      t.getOutputScale = function getOutputScale(e) {
        const t = window.devicePixelRatio || 1
        const i =
          e.webkitBackingStorePixelRatio ||
          e.mozBackingStorePixelRatio ||
          e.msBackingStorePixelRatio ||
          e.oBackingStorePixelRatio ||
          e.backingStorePixelRatio ||
          1
        const n = t / i
        return { sx: n, sy: n, scaled: n !== 1 }
      }
      t.getPageSizeInches = function getPageSizeInches(e) {
        const { view: t, userUnit: i, rotate: n } = e
        const [s, a, r, o] = t
        const l = n % 180 != 0
        const c = ((r - s) / 72) * i
        const d = ((o - a) / 72) * i
        return { width: l ? d : c, height: l ? c : d }
      }
      t.getVisibleElements = function getVisibleElements(e) {
        const {
          scrollEl: t,
          views: i,
          sortByVisibility: n = !1,
          horizontal: s = !1,
          rtl: a = !1
        } = e
        const r = t.scrollTop
        const o = r + t.clientHeight
        const l = t.scrollLeft
        const c = l + t.clientWidth
        const d = []
        const h = new Set()
        const u = i.length
        let p = binarySearchFirstItem(
          i,
          s
            ? function isElementNextAfterViewHorizontally(e) {
                const t = e.div
                const i = t.offsetLeft + t.clientLeft
                const n = i + t.clientWidth
                return a ? i < c : n > l
              }
            : function isElementBottomAfterViewTop(e) {
                const t = e.div
                return t.offsetTop + t.clientTop + t.clientHeight > r
              }
        )
        p > 0 && p < u && !s && (p = backtrackBeforeAllVisibleElements(p, i, r))
        let g = s ? c : -1
        for (let e = p; e < u; e++) {
          const t = i[e]
          const n = t.div
          const a = n.offsetLeft + n.clientLeft
          const u = n.offsetTop + n.clientTop
          const p = n.clientWidth
          const f = n.clientHeight
          const m = a + p
          const v = u + f
          if (g === -1) v >= o && (g = v)
          else if ((s ? a : u) > g) break
          if (v <= r || u >= o || m <= l || a >= c) continue
          const _ = Math.max(0, r - u) + Math.max(0, v - o)
          const b = Math.max(0, l - a) + Math.max(0, m - c)
          const w = (p - b) / p
          const P = (((f - _) / f) * w * 100) | 0
          d.push({ id: t.id, x: a, y: u, view: t, percent: P, widthPercent: (100 * w) | 0 })
          h.add(t.id)
        }
        const f = d[0]
        const m = d.at(-1)
        n &&
          d.sort(function (e, t) {
            const i = e.percent - t.percent
            return Math.abs(i) > 0.001 ? -i : e.id - t.id
          })
        return { first: f, last: m, views: d, ids: h }
      }
      t.isPortraitOrientation = function isPortraitOrientation(e) {
        return e.width <= e.height
      }
      t.isValidRotation = function isValidRotation(e) {
        return Number.isInteger(e) && e % 90 == 0
      }
      t.isValidScrollMode = function isValidScrollMode(e) {
        return Number.isInteger(e) && Object.values(n).includes(e) && e !== n.UNKNOWN
      }
      t.isValidSpreadMode = function isValidSpreadMode(e) {
        return Number.isInteger(e) && Object.values(s).includes(e) && e !== s.UNKNOWN
      }
      t.noContextMenuHandler = function noContextMenuHandler(e) {
        e.preventDefault()
      }
      t.normalizeWheelEventDelta = function normalizeWheelEventDelta(e) {
        let t = normalizeWheelEventDirection(e)
        e.deltaMode === 0 ? (t /= 900) : e.deltaMode === 1 && (t /= 30)
        return t
      }
      t.normalizeWheelEventDirection = normalizeWheelEventDirection
      t.parseQueryString = function parseQueryString(e) {
        const t = new Map()
        for (const [i, n] of new URLSearchParams(e)) t.set(i.toLowerCase(), n)
        return t
      }
      t.removeNullCharacters = function removeNullCharacters(e) {
        const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
        if (typeof e !== 'string') {
          console.error('The argument must be a string.')
          return e
        }
        t && (e = e.replace(r, ' '))
        return e.replace(a, '')
      }
      t.roundToDivide = function roundToDivide(e, t) {
        const i = e % t
        return i === 0 ? e : Math.round(e - i + t)
      }
      t.scrollIntoView = function scrollIntoView(e, t) {
        const i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
        let n = e.offsetParent
        if (!n) {
          console.error('offsetParent is not set -- cannot scroll')
          return
        }
        let s = e.offsetTop + e.clientTop
        let a = e.offsetLeft + e.clientLeft
        for (
          ;
          (n.clientHeight === n.scrollHeight && n.clientWidth === n.scrollWidth) ||
          (i &&
            (n.classList.contains('markedContent') || getComputedStyle(n).overflow === 'hidden'));

        ) {
          s += n.offsetTop
          a += n.offsetLeft
          n = n.offsetParent
          if (!n) return
        }
        if (t) {
          void 0 !== t.top && (s += t.top)
          if (void 0 !== t.left) {
            a += t.left
            n.scrollLeft = a
          }
        }
        n.scrollTop = s
      }
      t.watchScroll = function watchScroll(e, t) {
        const debounceScroll = function (s) {
          n ||
            (n = window.requestAnimationFrame(function viewAreaElementScrolled() {
              n = null
              const s = e.scrollLeft
              const a = i.lastX
              s !== a && (i.right = s > a)
              i.lastX = s
              const r = e.scrollTop
              const o = i.lastY
              r !== o && (i.down = r > o)
              i.lastY = r
              t(i)
            }))
        }
        const i = {
          right: !0,
          down: !0,
          lastX: e.scrollLeft,
          lastY: e.scrollTop,
          _eventHandler: debounceScroll
        }
        let n = null
        e.addEventListener('scroll', debounceScroll, !0)
        return i
      }
      function _classPrivateFieldInitSpec(e, t, i) {
        !(function _checkPrivateRedeclaration(e, t) {
          if (t.has(e))
            throw new TypeError('Cannot initialize the same private elements twice on an object')
        })(e, t)
        t.set(e, i)
      }
      function _classPrivateFieldGet(e, t) {
        return (function _classApplyDescriptorGet(e, t) {
          if (t.get) return t.get.call(e)
          return t.value
        })(e, _classExtractFieldDescriptor(e, t, 'get'))
      }
      function _classPrivateFieldSet(e, t, i) {
        !(function _classApplyDescriptorSet(e, t, i) {
          if (t.set) t.set.call(e, i)
          else {
            if (!t.writable) throw new TypeError('attempted to set read only private field')
            t.value = i
          }
        })(e, _classExtractFieldDescriptor(e, t, 'set'), i)
        return i
      }
      function _classExtractFieldDescriptor(e, t, i) {
        if (!t.has(e)) throw new TypeError(`attempted to ${i} private field on non-instance`)
        return t.get(e)
      }
      t.DEFAULT_SCALE_VALUE = 'auto'
      t.DEFAULT_SCALE = 1
      t.DEFAULT_SCALE_DELTA = 1.1
      t.MIN_SCALE = 0.1
      t.MAX_SCALE = 10
      t.UNKNOWN_SCALE = 0
      t.MAX_AUTO_SCALE = 1.25
      t.SCROLLBAR_PADDING = 40
      t.VERTICAL_PADDING = 5
      t.RenderingStates = { INITIAL: 0, RUNNING: 1, PAUSED: 2, FINISHED: 3 }
      t.PresentationModeState = { UNKNOWN: 0, NORMAL: 1, CHANGING: 2, FULLSCREEN: 3 }
      const i = { UNKNOWN: -1, NONE: 0, THUMBS: 1, OUTLINE: 2, ATTACHMENTS: 3, LAYERS: 4 }
      t.SidebarView = i
      t.RendererType = { CANVAS: 'canvas', SVG: 'svg' }
      t.TextLayerMode = { DISABLE: 0, ENABLE: 1, ENABLE_ENHANCE: 2 }
      const n = { UNKNOWN: -1, VERTICAL: 0, HORIZONTAL: 1, WRAPPED: 2, PAGE: 3 }
      t.ScrollMode = n
      const s = { UNKNOWN: -1, NONE: 0, ODD: 1, EVEN: 2 }
      t.SpreadMode = s
      t.AutoPrintRegExp = /\bprint\s*\(/
      t.OutputScale = class OutputScale {
        constructor() {
          const e = window.devicePixelRatio || 1
          this.sx = e
          this.sy = e
        }

        get scaled() {
          return this.sx !== 1 || this.sy !== 1
        }
      }
      const a = /\x00/g
      const r = /[\x01-\x1F]/g
      function binarySearchFirstItem(e, t) {
        const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
        let n = i
        let s = e.length - 1
        if (s < 0 || !t(e[s])) return e.length
        if (t(e[n])) return n
        for (; n < s; ) {
          const i = (n + s) >> 1
          t(e[i]) ? (s = i) : (n = i + 1)
        }
        return n
      }
      function backtrackBeforeAllVisibleElements(e, t, i) {
        if (e < 2) return e
        let n = t[e].div
        let s = n.offsetTop + n.clientTop
        if (s >= i) {
          n = t[e - 1].div
          s = n.offsetTop + n.clientTop
        }
        for (let i = e - 2; i >= 0; --i) {
          n = t[i].div
          if (n.offsetTop + n.clientTop + n.clientHeight <= s) break
          e = i
        }
        return e
      }
      function normalizeWheelEventDirection(e) {
        let t = Math.hypot(e.deltaX, e.deltaY)
        const i = Math.atan2(e.deltaY, e.deltaX)
        ;-0.25 * Math.PI < i && i < 0.75 * Math.PI && (t = -t)
        return t
      }
      const o = new Promise(function (e) {
        window.requestAnimationFrame(e)
      })
      t.animationStarted = o
      const l = document.documentElement.style
      t.docStyle = l
      const c = new WeakMap()
      const d = new WeakMap()
      const h = new WeakMap()
      t.ProgressBar = class ProgressBar {
        constructor(e) {
          _classPrivateFieldInitSpec(this, c, { writable: !0, value: null })
          _classPrivateFieldInitSpec(this, d, { writable: !0, value: 0 })
          _classPrivateFieldInitSpec(this, h, { writable: !0, value: !0 })
          if (arguments.length > 1)
            throw new Error(
              'ProgressBar no longer accepts any additional options, please use CSS rules to modify its appearance instead.'
            )
          const t = document.getElementById(e)
          _classPrivateFieldSet(this, c, t.classList)
        }

        get percent() {
          return _classPrivateFieldGet(this, d)
        }

        set percent(e) {
          _classPrivateFieldSet(
            this,
            d,
            (function clamp(e, t, i) {
              return Math.min(Math.max(e, t), i)
            })(e, 0, 100)
          )
          if (isNaN(e)) _classPrivateFieldGet(this, c).add('indeterminate')
          else {
            _classPrivateFieldGet(this, c).remove('indeterminate')
            l.setProperty('--progressBar-percent', `${_classPrivateFieldGet(this, d)}%`)
          }
        }

        setWidth(e) {
          if (!e) return
          const t = e.parentNode.offsetWidth - e.offsetWidth
          t > 0 && l.setProperty('--progressBar-end-offset', `${t}px`)
        }

        hide() {
          if (_classPrivateFieldGet(this, h)) {
            _classPrivateFieldSet(this, h, !1)
            _classPrivateFieldGet(this, c).add('hidden')
          }
        }

        show() {
          if (!_classPrivateFieldGet(this, h)) {
            _classPrivateFieldSet(this, h, !0)
            _classPrivateFieldGet(this, c).remove('hidden')
          }
        }
      }
    },
    (e, t) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.compatibilityParams = t.OptionKind = t.AppOptions = void 0
      const i = Object.create(null)
      t.compatibilityParams = i
      {
        const e = navigator.userAgent || ''
        const t = navigator.platform || ''
        const n = navigator.maxTouchPoints || 1
        const s = /Android/.test(e)
        const a = /\b(iPad|iPhone|iPod)(?=;)/.test(e) || (t === 'MacIntel' && n > 1)
        !(function checkCanvasSizeLimitation() {
          ;(a || s) && (i.maxCanvasPixels = 5242880)
        })()
      }
      const n = { VIEWER: 2, API: 4, WORKER: 8, PREFERENCE: 128 }
      t.OptionKind = n
      const s = {
        annotationEditorMode: { value: -1, kind: n.VIEWER + n.PREFERENCE },
        annotationMode: { value: 2, kind: n.VIEWER + n.PREFERENCE },
        cursorToolOnLoad: { value: 0, kind: n.VIEWER + n.PREFERENCE },
        defaultZoomValue: { value: '100', kind: n.VIEWER + n.PREFERENCE },
        disableHistory: { value: !1, kind: n.VIEWER },
        disablePageLabels: { value: !1, kind: n.VIEWER + n.PREFERENCE },
        enablePermissions: { value: !1, kind: n.VIEWER + n.PREFERENCE },
        enablePrintAutoRotate: { value: !0, kind: n.VIEWER + n.PREFERENCE },
        enableScripting: { value: !0, kind: n.VIEWER + n.PREFERENCE },
        externalLinkRel: { value: 'noopener noreferrer nofollow', kind: n.VIEWER },
        externalLinkTarget: { value: 0, kind: n.VIEWER + n.PREFERENCE },
        historyUpdateUrl: { value: !1, kind: n.VIEWER + n.PREFERENCE },
        ignoreDestinationZoom: { value: !1, kind: n.VIEWER + n.PREFERENCE },
        imageResourcesPath: { value: './images/', kind: n.VIEWER },
        maxCanvasPixels: { value: 16777216, kind: n.VIEWER },
        forcePageColors: { value: !1, kind: n.VIEWER + n.PREFERENCE },
        pageColorsBackground: { value: 'Canvas', kind: n.VIEWER + n.PREFERENCE },
        pageColorsForeground: { value: 'CanvasText', kind: n.VIEWER + n.PREFERENCE },
        pdfBugEnabled: { value: !0, kind: n.VIEWER + n.PREFERENCE },
        printResolution: { value: 150, kind: n.VIEWER },
        sidebarViewOnLoad: { value: 1, kind: n.VIEWER + n.PREFERENCE },
        scrollModeOnLoad: { value: 0, kind: n.VIEWER + n.PREFERENCE },
        spreadModeOnLoad: { value: -1, kind: n.VIEWER + n.PREFERENCE },
        textLayerMode: { value: 1, kind: n.VIEWER + n.PREFERENCE },
        useOnlyCssZoom: { value: !1, kind: n.VIEWER + n.PREFERENCE },
        viewerCssTheme: { value: 0, kind: n.VIEWER + n.PREFERENCE },
        viewOnLoad: { value: 0, kind: n.VIEWER + n.PREFERENCE },
        cMapPacked: { value: !0, kind: n.API },
        cMapUrl: { value: '../web/cmaps/', kind: n.API },
        disableAutoFetch: { value: !1, kind: n.API + n.PREFERENCE },
        disableFontFace: { value: !1, kind: n.API + n.PREFERENCE },
        disableRange: { value: !1, kind: n.API + n.PREFERENCE },
        disableStream: { value: !1, kind: n.API + n.PREFERENCE },
        docBaseUrl: { value: '', kind: n.API },
        enableXfa: { value: !0, kind: n.API + n.PREFERENCE },
        fontExtraProperties: { value: !1, kind: n.API },
        isEvalSupported: { value: !0, kind: n.API },
        maxImageSize: { value: -1, kind: n.API },
        pdfBug: { value: !0, kind: n.API },
        standardFontDataUrl: { value: '../web/standard_fonts/', kind: n.API },
        verbosity: { value: 1, kind: n.API },
        workerPort: { value: null, kind: n.WORKER },
        workerSrc: { value: '../build/pdf.worker.js', kind: n.WORKER }
      }
      s.defaultUrl = { value: '', kind: n.VIEWER }
      s.disablePreferences = { value: !1, kind: n.VIEWER }
      s.locale = { value: navigator.language || 'en-US', kind: n.VIEWER }
      s.renderer = { value: 'canvas', kind: n.VIEWER + n.PREFERENCE }
      s.sandboxBundleSrc = { value: '../build/pdf.sandbox.js', kind: n.VIEWER }
      const a = Object.create(null)
      t.AppOptions = class AppOptions {
        constructor() {
          throw new Error('Cannot initialize AppOptions.')
        }

        static get(e) {
          const t = a[e]
          if (void 0 !== t) return t
          const n = s[e]
          if (void 0 !== n) {
            let r
            return (r = i[e]) !== null && void 0 !== r ? r : n.value
          }
        }

        static getAll() {
          const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
          const t = Object.create(null)
          for (const o in s) {
            var r
            const l = s[o]
            if (e) {
              if ((e & l.kind) == 0) continue
              if (e === n.PREFERENCE) {
                const e = l.value
                const i = typeof e
                if (i === 'boolean' || i === 'string' || (i === 'number' && Number.isInteger(e))) {
                  t[o] = e
                  continue
                }
                throw new Error(`Invalid type for preference: ${o}`)
              }
            }
            const c = a[o]
            t[o] = void 0 !== c ? c : (r = i[o]) !== null && void 0 !== r ? r : l.value
          }
          return t
        }

        static set(e, t) {
          a[e] = t
        }

        static setAll(e) {
          for (const t in e) a[t] = e[t]
        }

        static remove(e) {
          delete a[e]
        }

        static _hasUserOptions() {
          return Object.keys(a).length > 0
        }
      }
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.SimpleLinkService = t.PDFLinkService = t.LinkTarget = void 0
      const n = i(1)
      function _checkPrivateRedeclaration(e, t) {
        if (t.has(e))
          throw new TypeError('Cannot initialize the same private elements twice on an object')
      }
      function _classStaticPrivateMethodGet(e, t, i) {
        !(function _classCheckPrivateStaticAccess(e, t) {
          if (e !== t) throw new TypeError('Private static access of wrong provenance')
        })(e, t)
        return i
      }
      function _classPrivateMethodGet(e, t, i) {
        if (!t.has(e)) throw new TypeError('attempted to get private field on non-instance')
        return i
      }
      function _classPrivateFieldGet(e, t) {
        const i = (function _classExtractFieldDescriptor(e, t, i) {
          if (!t.has(e)) throw new TypeError(`attempted to ${i} private field on non-instance`)
          return t.get(e)
        })(e, t, 'get')
        return (function _classApplyDescriptorGet(e, t) {
          if (t.get) return t.get.call(e)
          return t.value
        })(e, i)
      }
      const s = 'noopener noreferrer nofollow'
      const a = { NONE: 0, SELF: 1, BLANK: 2, PARENT: 3, TOP: 4 }
      t.LinkTarget = a
      function addLinkAttributes(e) {
        const {
          url: t,
          target: i,
          rel: r,
          enabled: o = !0
        } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
        if (!t || typeof t !== 'string') throw new Error('A valid "url" parameter must provided.')
        const l = (0, n.removeNullCharacters)(t)
        if (o) e.href = e.title = l
        else {
          e.href = ''
          e.title = `Disabled: ${l}`
          e.onclick = () => !1
        }
        let c = ''
        switch (i) {
          case a.NONE:
            break
          case a.SELF:
            c = '_self'
            break
          case a.BLANK:
            c = '_blank'
            break
          case a.PARENT:
            c = '_parent'
            break
          case a.TOP:
            c = '_top'
        }
        e.target = c
        e.rel = typeof r === 'string' ? r : s
      }
      const r = new WeakMap()
      const o = new WeakSet()
      class PDFLinkService {
        constructor() {
          const {
            eventBus: e,
            externalLinkTarget: t = null,
            externalLinkRel: i = null,
            ignoreDestinationZoom: n = !1
          } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
          !(function _classPrivateMethodInitSpec(e, t) {
            _checkPrivateRedeclaration(e, t)
            t.add(e)
          })(this, o)
          !(function _classPrivateFieldInitSpec(e, t, i) {
            _checkPrivateRedeclaration(e, t)
            t.set(e, i)
          })(this, r, { writable: !0, value: new Map() })
          this.eventBus = e
          this.externalLinkTarget = t
          this.externalLinkRel = i
          this.externalLinkEnabled = !0
          this._ignoreDestinationZoom = n
          this.baseUrl = null
          this.pdfDocument = null
          this.pdfViewer = null
          this.pdfHistory = null
        }

        setDocument(e) {
          const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
          this.baseUrl = t
          this.pdfDocument = e
          _classPrivateFieldGet(this, r).clear()
        }

        setViewer(e) {
          this.pdfViewer = e
        }

        setHistory(e) {
          this.pdfHistory = e
        }

        get pagesCount() {
          return this.pdfDocument ? this.pdfDocument.numPages : 0
        }

        get page() {
          return this.pdfViewer.currentPageNumber
        }

        set page(e) {
          this.pdfViewer.currentPageNumber = e
        }

        get rotation() {
          return this.pdfViewer.pagesRotation
        }

        set rotation(e) {
          this.pdfViewer.pagesRotation = e
        }

        async goToDestination(e) {
          if (!this.pdfDocument) return
          let t
          let i
          if (typeof e === 'string') {
            t = e
            i = await this.pdfDocument.getDestination(e)
          } else {
            t = null
            i = await e
          }
          Array.isArray(i)
            ? _classPrivateMethodGet(this, o, _goToDestinationHelper2).call(this, e, t, i)
            : console.error(
                `PDFLinkService.goToDestination: "${i}" is not a valid destination array, for dest="${e}".`
              )
        }

        goToPage(e) {
          if (!this.pdfDocument) return
          const t = (typeof e === 'string' && this.pdfViewer.pageLabelToPageNumber(e)) || 0 | e
          if (Number.isInteger(t) && t > 0 && t <= this.pagesCount) {
            if (this.pdfHistory) {
              this.pdfHistory.pushCurrentPosition()
              this.pdfHistory.pushPage(t)
            }
            this.pdfViewer.scrollPageIntoView({ pageNumber: t })
          } else console.error(`PDFLinkService.goToPage: "${e}" is not a valid page.`)
        }

        addLinkAttributes(e, t) {
          addLinkAttributes(e, {
            url: t,
            target:
              arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
                ? a.BLANK
                : this.externalLinkTarget,
            rel: this.externalLinkRel,
            enabled: this.externalLinkEnabled
          })
        }

        getDestinationHash(e) {
          if (typeof e === 'string') {
            if (e.length > 0) return this.getAnchorUrl(`#${escape(e)}`)
          } else if (Array.isArray(e)) {
            const t = JSON.stringify(e)
            if (t.length > 0) return this.getAnchorUrl(`#${escape(t)}`)
          }
          return this.getAnchorUrl('')
        }

        getAnchorUrl(e) {
          return (this.baseUrl || '') + e
        }

        setHash(e) {
          if (!this.pdfDocument) return
          let t
          let i
          if (e.includes('=')) {
            const s = (0, n.parseQueryString)(e)
            s.has('search') &&
              this.eventBus.dispatch('findfromurlhash', {
                source: this,
                query: s.get('search').replace(/"/g, ''),
                phraseSearch: s.get('phrase') === 'true'
              })
            s.has('page') && (t = 0 | s.get('page') || 1)
            if (s.has('zoom')) {
              const e = s.get('zoom').split(',')
              const t = e[0]
              const n = parseFloat(t)
              t.includes('Fit')
                ? t === 'Fit' || t === 'FitB'
                  ? (i = [null, { name: t }])
                  : t === 'FitH' || t === 'FitBH' || t === 'FitV' || t === 'FitBV'
                  ? (i = [null, { name: t }, e.length > 1 ? 0 | e[1] : null])
                  : t === 'FitR'
                  ? e.length !== 5
                    ? console.error('PDFLinkService.setHash: Not enough parameters for "FitR".')
                    : (i = [null, { name: t }, 0 | e[1], 0 | e[2], 0 | e[3], 0 | e[4]])
                  : console.error(`PDFLinkService.setHash: "${t}" is not a valid zoom value.`)
                : (i = [
                    null,
                    { name: 'XYZ' },
                    e.length > 1 ? 0 | e[1] : null,
                    e.length > 2 ? 0 | e[2] : null,
                    n ? n / 100 : t
                  ])
            }
            i
              ? this.pdfViewer.scrollPageIntoView({
                  pageNumber: t || this.page,
                  destArray: i,
                  allowNegativeOffset: !0
                })
              : t && (this.page = t)
            s.has('pagemode') &&
              this.eventBus.dispatch('pagemode', { source: this, mode: s.get('pagemode') })
            s.has('nameddest') && this.goToDestination(s.get('nameddest'))
          } else {
            i = unescape(e)
            try {
              i = JSON.parse(i)
              Array.isArray(i) || (i = i.toString())
            } catch (e) {}
            if (
              typeof i === 'string' ||
              _classStaticPrivateMethodGet(
                PDFLinkService,
                PDFLinkService,
                _isValidExplicitDestination
              ).call(PDFLinkService, i)
            ) {
              this.goToDestination(i)
              return
            }
            console.error(`PDFLinkService.setHash: "${unescape(e)}" is not a valid destination.`)
          }
        }

        executeNamedAction(e) {
          let t
          let i
          switch (e) {
            case 'GoBack':
              ;(t = this.pdfHistory) === null || void 0 === t || t.back()
              break
            case 'GoForward':
              ;(i = this.pdfHistory) === null || void 0 === i || i.forward()
              break
            case 'NextPage':
              this.pdfViewer.nextPage()
              break
            case 'PrevPage':
              this.pdfViewer.previousPage()
              break
            case 'LastPage':
              this.page = this.pagesCount
              break
            case 'FirstPage':
              this.page = 1
          }
          this.eventBus.dispatch('namedaction', { source: this, action: e })
        }

        cachePageRef(e, t) {
          if (!t) return
          const i = t.gen === 0 ? `${t.num}R` : `${t.num}R${t.gen}`
          _classPrivateFieldGet(this, r).set(i, e)
        }

        _cachedPageNumber(e) {
          if (!e) return null
          const t = e.gen === 0 ? `${e.num}R` : `${e.num}R${e.gen}`
          return _classPrivateFieldGet(this, r).get(t) || null
        }

        isPageVisible(e) {
          return this.pdfViewer.isPageVisible(e)
        }

        isPageCached(e) {
          return this.pdfViewer.isPageCached(e)
        }
      }
      t.PDFLinkService = PDFLinkService
      function _goToDestinationHelper2(e) {
        const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
        const i = arguments.length > 2 ? arguments[2] : void 0
        const n = i[0]
        let s
        if (typeof n === 'object' && n !== null) {
          s = this._cachedPageNumber(n)
          if (!s) {
            this.pdfDocument
              .getPageIndex(n)
              .then((s) => {
                this.cachePageRef(s + 1, n)
                _classPrivateMethodGet(this, o, _goToDestinationHelper2).call(this, e, t, i)
              })
              .catch(() => {
                console.error(
                  `PDFLinkService.#goToDestinationHelper: "${n}" is not a valid page reference, for dest="${e}".`
                )
              })
            return
          }
        } else {
          if (!Number.isInteger(n)) {
            console.error(
              `PDFLinkService.#goToDestinationHelper: "${n}" is not a valid destination reference, for dest="${e}".`
            )
            return
          }
          s = n + 1
        }
        if (!s || s < 1 || s > this.pagesCount)
          console.error(
            `PDFLinkService.#goToDestinationHelper: "${s}" is not a valid page number, for dest="${e}".`
          )
        else {
          if (this.pdfHistory) {
            this.pdfHistory.pushCurrentPosition()
            this.pdfHistory.push({ namedDest: t, explicitDest: i, pageNumber: s })
          }
          this.pdfViewer.scrollPageIntoView({
            pageNumber: s,
            destArray: i,
            ignoreDestinationZoom: this._ignoreDestinationZoom
          })
        }
      }
      function _isValidExplicitDestination(e) {
        if (!Array.isArray(e)) return !1
        const t = e.length
        if (t < 2) return !1
        const i = e[0]
        if (
          !(
            (typeof i === 'object' && Number.isInteger(i.num) && Number.isInteger(i.gen)) ||
            (Number.isInteger(i) && i >= 0)
          )
        )
          return !1
        const n = e[1]
        if (typeof n !== 'object' || typeof n.name !== 'string') return !1
        let s = !0
        switch (n.name) {
          case 'XYZ':
            if (t !== 5) return !1
            break
          case 'Fit':
          case 'FitB':
            return t === 2
          case 'FitH':
          case 'FitBH':
          case 'FitV':
          case 'FitBV':
            if (t !== 3) return !1
            break
          case 'FitR':
            if (t !== 6) return !1
            s = !1
            break
          default:
            return !1
        }
        for (let i = 2; i < t; i++) {
          const t = e[i]
          if (!(typeof t === 'number' || (s && t === null))) return !1
        }
        return !0
      }
      t.SimpleLinkService = class SimpleLinkService {
        constructor() {
          this.externalLinkEnabled = !0
        }

        get pagesCount() {
          return 0
        }

        get page() {
          return 0
        }

        set page(e) {}

        get rotation() {
          return 0
        }

        set rotation(e) {}

        async goToDestination(e) {}

        goToPage(e) {}

        addLinkAttributes(e, t) {
          addLinkAttributes(e, { url: t, enabled: this.externalLinkEnabled })
        }

        getDestinationHash(e) {
          return '#'
        }

        getAnchorUrl(e) {
          return '#'
        }

        setHash(e) {}

        executeNamedAction(e) {}

        cachePageRef(e, t) {}

        isPageVisible(e) {
          return !0
        }

        isPageCached(e) {
          return !0
        }
      }
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.PDFViewerApplication = t.PDFPrintServiceFactory = t.DefaultExternalServices = void 0
      const n = i(1)
      const s = i(5)
      const a = i(2)
      const r = i(6)
      const o = i(7)
      const l = i(3)
      const c = i(9)
      const d = i(10)
      const h = i(12)
      const u = i(13)
      const p = i(15)
      const g = i(16)
      const f = i(17)
      const m = i(19)
      const v = i(20)
      const _ = i(21)
      const b = i(22)
      const w = i(23)
      const P = i(24)
      const y = i(25)
      const S = i(26)
      const A = i(27)
      const E = i(29)
      const x = i(42)
      const C = i(43)
      const M = i(44)
      const T = i(45)
      const k = i(47)
      const I = i(36)
      const D = i(37)
      const L = i(48)
      const R = -1
      const O = 1
      const N = { AUTOMATIC: 0, LIGHT: 1, DARK: 2 }
      const B = [
        '1.0',
        '1.1',
        '1.2',
        '1.3',
        '1.4',
        '1.5',
        '1.6',
        '1.7',
        '1.8',
        '1.9',
        '2.0',
        '2.1',
        '2.2',
        '2.3'
      ]
      const G = [
        'acrobat distiller',
        'acrobat pdfwriter',
        'adobe livecycle',
        'adobe pdf library',
        'adobe photoshop',
        'ghostscript',
        'tcpdf',
        'cairo',
        'dvipdfm',
        'dvips',
        'pdftex',
        'pdfkit',
        'itext',
        'prince',
        'quarkxpress',
        'mac os x',
        'microsoft',
        'openoffice',
        'oracle',
        'luradocument',
        'pdf-xchange',
        'antenna house',
        'aspose.cells',
        'fpdf'
      ]
      class DefaultExternalServices {
        constructor() {
          throw new Error('Cannot initialize DefaultExternalServices.')
        }

        static updateFindControlState(e) {}

        static updateFindMatchesCount(e) {}

        static initPassiveLoading(e) {}

        static reportTelemetry(e) {}

        static createDownloadManager(e) {
          throw new Error('Not implemented: createDownloadManager')
        }

        static createPreferences() {
          throw new Error('Not implemented: createPreferences')
        }

        static createL10n(e) {
          throw new Error('Not implemented: createL10n')
        }

        static createScripting(e) {
          throw new Error('Not implemented: createScripting')
        }

        static get supportsIntegratedFind() {
          return (0, s.shadow)(this, 'supportsIntegratedFind', !1)
        }

        static get supportsDocumentFonts() {
          return (0, s.shadow)(this, 'supportsDocumentFonts', !0)
        }

        static get supportedMouseWheelZoomModifierKeys() {
          return (0, s.shadow)(this, 'supportedMouseWheelZoomModifierKeys', {
            ctrlKey: !0,
            metaKey: !0
          })
        }

        static get isInAutomation() {
          return (0, s.shadow)(this, 'isInAutomation', !1)
        }

        static updateEditorStates(e) {
          throw new Error('Not implemented: updateEditorStates')
        }
      }
      t.DefaultExternalServices = DefaultExternalServices
      const V = {
        initialBookmark: document.location.hash.substring(1),
        _initializedCapability: (0, s.createPromiseCapability)(),
        appConfig: null,
        pdfDocument: null,
        pdfLoadingTask: null,
        printService: null,
        pdfViewer: null,
        pdfThumbnailViewer: null,
        pdfRenderingQueue: null,
        pdfPresentationMode: null,
        pdfDocumentProperties: null,
        pdfLinkService: null,
        pdfHistory: null,
        pdfSidebar: null,
        pdfSidebarResizer: null,
        pdfOutlineViewer: null,
        pdfAttachmentViewer: null,
        pdfLayerViewer: null,
        pdfCursorTools: null,
        pdfScriptingManager: null,
        store: null,
        downloadManager: null,
        overlayManager: null,
        preferences: null,
        toolbar: null,
        secondaryToolbar: null,
        eventBus: null,
        l10n: null,
        annotationEditorParams: null,
        isInitialViewSet: !1,
        downloadComplete: !1,
        isViewerEmbedded: window.parent !== window,
        url: '',
        baseUrl: '',
        _downloadUrl: '',
        externalServices: DefaultExternalServices,
        _boundEvents: Object.create(null),
        documentInfo: null,
        metadata: null,
        _contentDispositionFilename: null,
        _contentLength: null,
        _saveInProgress: !1,
        _docStats: null,
        _wheelUnusedTicks: 0,
        _idleCallbacks: new Set(),
        _PDFBug: null,
        _hasAnnotationEditors: !1,
        _title: document.title,
        _printAnnotationStoragePromise: null,
        async initialize(e) {
          console.info(`git version = ${L.git_version}`)
          console.info(`compile time = ${L.compile_time}`)
          ;(0, I.log_info)('webviewer will be initialized.....')
          this.preferences = this.externalServices.createPreferences()
          ;(0, I.log_debug)('finish preference obj creating......')
          this.appConfig = e
          await this._readPreferences()
          await this._parseHashParameters()
          this._forceCssTheme()
          await this._initializeL10n()
          this.isViewerEmbedded &&
            a.AppOptions.get('externalLinkTarget') === l.LinkTarget.NONE &&
            a.AppOptions.set('externalLinkTarget', l.LinkTarget.TOP)
          await this._initializeViewerComponents()
          this.bindEvents()
          this.bindWindowEvents()
          const t = e.appContainer || document.documentElement
          this.l10n.translate(t).then(() => {
            this.eventBus.dispatch('localized', { source: this })
          })
          this._initializedCapability.resolve()
        },
        async _readPreferences() {
          ;(0, I.log_debug)('webviewer will _readPreferences.....')
          if (a.AppOptions.get('disablePreferences'))
            (0, I.log_info)('disablePreferences is true, will use app_option')
          else {
            a.AppOptions._hasUserOptions() &&
              console.warn(
                '_readPreferences: The Preferences may override manually set AppOptions; please use the "disablePreferences"-option in order to prevent that.'
              )
            try {
              a.AppOptions.setAll(await this.preferences.getAll())
            } catch (e) {
              console.error(`_readPreferences: "${e == null ? void 0 : e.message}".`)
            }
          }
        },
        async _parseHashParameters() {
          ;(0, I.log_debug)('begin to parse url params')
          if (!a.AppOptions.get('pdfBugEnabled')) return
          const e = document.location.hash.substring(1)
          if (!e) return
          const { mainContainer: t, viewerContainer: i } = this.appConfig
          const r = (0, n.parseQueryString)(e)
          if (r.get('disableworker') === 'true')
            try {
              await (async function loadFakeWorker() {
                s.GlobalWorkerOptions.workerSrc ||
                  (s.GlobalWorkerOptions.workerSrc = a.AppOptions.get('workerSrc'))
                await (0, s.loadScript)(s.PDFWorker.workerSrc)
              })()
            } catch (e) {
              console.error(`_parseHashParameters: "${e.message}".`)
            }
          r.has('disablerange') &&
            a.AppOptions.set('disableRange', r.get('disablerange') === 'true')
          r.has('disablestream') &&
            a.AppOptions.set('disableStream', r.get('disablestream') === 'true')
          r.has('disableautofetch') &&
            a.AppOptions.set('disableAutoFetch', r.get('disableautofetch') === 'true')
          r.has('disablefontface') &&
            a.AppOptions.set('disableFontFace', r.get('disablefontface') === 'true')
          r.has('disablehistory') &&
            a.AppOptions.set('disableHistory', r.get('disablehistory') === 'true')
          r.has('verbosity') && a.AppOptions.set('verbosity', 0 | r.get('verbosity'))
          if (r.has('textlayer'))
            switch (r.get('textlayer')) {
              case 'off':
                a.AppOptions.set('textLayerMode', n.TextLayerMode.DISABLE)
                break
              case 'visible':
              case 'shadow':
              case 'hover':
                i.classList.add(`textLayer-${r.get('textlayer')}`)
                try {
                  await loadPDFBug(this)
                  this._PDFBug.loadCSS()
                } catch (e) {
                  console.error(`_parseHashParameters: "${e.message}".`)
                }
            }
          if (r.has('pdfbug')) {
            a.AppOptions.set('pdfBug', !0)
            a.AppOptions.set('fontExtraProperties', !0)
            const e = r.get('pdfbug').split(',')
            try {
              await loadPDFBug(this)
              this._PDFBug.init({ OPS: s.OPS }, t, e)
            } catch (e) {
              console.error(`_parseHashParameters: "${e.message}".`)
            }
          }
          r.has('locale') && a.AppOptions.set('locale', r.get('locale'))
        },
        async _initializeL10n() {
          this.l10n = this.externalServices.createL10n({ locale: a.AppOptions.get('locale') })
          const e = await this.l10n.getDirection()
          document.getElementsByTagName('html')[0].dir = e
        },
        _forceCssTheme() {
          const e = a.AppOptions.get('viewerCssTheme')
          if (e !== N.AUTOMATIC && Object.values(N).includes(e))
            try {
              const i = document.styleSheets[0]
              const n = (i == null ? void 0 : i.cssRules) || []
              for (let s = 0, a = n.length; s < a; s++) {
                var t
                const a = n[s]
                if (
                  a instanceof CSSMediaRule &&
                  ((t = a.media) === null || void 0 === t ? void 0 : t[0]) ===
                    '(prefers-color-scheme: dark)'
                ) {
                  if (e === N.LIGHT) {
                    i.deleteRule(s)
                    return
                  }
                  const t =
                    /^@media \(prefers-color-scheme: dark\) {\n\s*([\w\s-.,:;/\\{}()]+)\n}$/.exec(
                      a.cssText
                    )
                  if (t != null && t[1]) {
                    i.deleteRule(s)
                    i.insertRule(t[1], s)
                  }
                  return
                }
              }
            } catch (e) {
              console.error(`_forceCssTheme: "${e == null ? void 0 : e.message}".`)
            }
        },
        async _initializeViewerComponents() {
          ;(0, I.log_debug)('begin to intialize webviewer components')
          const { appConfig: e, externalServices: t } = this
          const i = t.isInAutomation ? new r.AutomationEventBus() : new r.EventBus()
          this.eventBus = i
          this.overlayManager = new d.OverlayManager()
          const n = new w.PDFRenderingQueue()
          n.onIdle = this._cleanup.bind(this)
          this.pdfRenderingQueue = n
          const M = new l.PDFLinkService({
            eventBus: i,
            externalLinkTarget: a.AppOptions.get('externalLinkTarget'),
            externalLinkRel: a.AppOptions.get('externalLinkRel'),
            ignoreDestinationZoom: a.AppOptions.get('ignoreDestinationZoom')
          })
          this.pdfLinkService = M
          const T = t.createDownloadManager()
          this.downloadManager = T
          const k = new f.PDFFindController({ linkService: M, eventBus: i })
          this.findController = k
          const D = new P.PDFScriptingManager({
            eventBus: i,
            sandboxBundleSrc: a.AppOptions.get('sandboxBundleSrc'),
            scriptingFactory: t,
            docPropertiesLookup: this._scriptingDocProperties.bind(this)
          })
          this.pdfScriptingManager = D
          const L = e.mainContainer
          const R = e.viewerContainer
          const O = a.AppOptions.get('annotationEditorMode')
          const N =
            a.AppOptions.get('forcePageColors') ||
            window.matchMedia('(forced-colors: active)').matches
              ? {
                  background: a.AppOptions.get('pageColorsBackground'),
                  foreground: a.AppOptions.get('pageColorsForeground')
                }
              : null
          this.pdfViewer = new E.PDFViewer({
            container: L,
            viewer: R,
            eventBus: i,
            renderingQueue: n,
            linkService: M,
            downloadManager: T,
            findController: k,
            scriptingManager: a.AppOptions.get('enableScripting') && D,
            renderer: a.AppOptions.get('renderer'),
            l10n: this.l10n,
            textLayerMode: a.AppOptions.get('textLayerMode'),
            annotationMode: a.AppOptions.get('annotationMode'),
            annotationEditorMode: O,
            imageResourcesPath: a.AppOptions.get('imageResourcesPath'),
            enablePrintAutoRotate: a.AppOptions.get('enablePrintAutoRotate'),
            useOnlyCssZoom: a.AppOptions.get('useOnlyCssZoom'),
            maxCanvasPixels: a.AppOptions.get('maxCanvasPixels'),
            enablePermissions: a.AppOptions.get('enablePermissions'),
            pageColors: N
          })
          n.setViewer(this.pdfViewer)
          M.setViewer(this.pdfViewer)
          D.setViewer(this.pdfViewer)
          this.pdfThumbnailViewer = new A.PDFThumbnailViewer({
            container: e.sidebar.thumbnailView,
            eventBus: i,
            renderingQueue: n,
            linkService: M,
            l10n: this.l10n,
            pageColors: N
          })
          n.setThumbnailViewer(this.pdfThumbnailViewer)
          if (!this.isViewerEmbedded && !a.AppOptions.get('disableHistory')) {
            this.pdfHistory = new m.PDFHistory({ linkService: M, eventBus: i })
            M.setHistory(this.pdfHistory)
          }
          this.supportsIntegratedFind || (this.findBar = new g.PDFFindBar(e.findBar, i, this.l10n))
          if (O !== s.AnnotationEditorType.DISABLE) {
            this.annotationEditorParams = new c.AnnotationEditorParams(e.annotationEditorParams, i)
            for (const e of [
              document.getElementById('editorModeButtons'),
              document.getElementById('editorModeSeparator')
            ])
              e.classList.remove('hidden')
          }
          this.pdfDocumentProperties = new p.PDFDocumentProperties(
            e.documentProperties,
            this.overlayManager,
            i,
            this.l10n,
            () => this._docFilename
          )
          this.pdfCursorTools = new o.PDFCursorTools({
            container: L,
            eventBus: i,
            cursorToolOnLoad: a.AppOptions.get('cursorToolOnLoad')
          })
          this.toolbar = new C.Toolbar(e.toolbar, i, this.l10n)
          this.secondaryToolbar = new x.SecondaryToolbar(e.secondaryToolbar, i)
          this.supportsFullscreen &&
            (this.pdfPresentationMode = new b.PDFPresentationMode({
              container: L,
              pdfViewer: this.pdfViewer,
              eventBus: i
            }))
          this.passwordPrompt = new h.PasswordPrompt(
            e.passwordOverlay,
            this.overlayManager,
            this.l10n,
            this.isViewerEmbedded
          )
          this.pdfOutlineViewer = new _.PDFOutlineViewer({
            container: e.sidebar.outlineView,
            eventBus: i,
            linkService: M
          })
          this.pdfAttachmentViewer = new u.PDFAttachmentViewer({
            container: e.sidebar.attachmentsView,
            eventBus: i,
            downloadManager: T
          })
          this.pdfLayerViewer = new v.PDFLayerViewer({
            container: e.sidebar.layersView,
            eventBus: i,
            l10n: this.l10n
          })
          this.pdfSidebar = new y.PDFSidebar({
            elements: e.sidebar,
            pdfViewer: this.pdfViewer,
            pdfThumbnailViewer: this.pdfThumbnailViewer,
            eventBus: i,
            l10n: this.l10n
          })
          this.pdfSidebar.onToggled = this.forceRendering.bind(this)
          this.pdfSidebarResizer = new S.PDFSidebarResizer(e.sidebarResizer, i, this.l10n)
        },
        run(e) {
          this.initialize(e).then(webViewerInitialized)
        },
        get initialized() {
          return this._initializedCapability.settled
        },
        get initializedPromise() {
          return this._initializedCapability.promise
        },
        zoomIn(e) {
          this.pdfViewer.isInPresentationMode || this.pdfViewer.increaseScale(e)
        },
        zoomOut(e) {
          this.pdfViewer.isInPresentationMode || this.pdfViewer.decreaseScale(e)
        },
        zoomReset() {
          this.pdfViewer.isInPresentationMode ||
            (this.pdfViewer.currentScaleValue = n.DEFAULT_SCALE_VALUE)
        },
        get pagesCount() {
          return this.pdfDocument ? this.pdfDocument.numPages : 0
        },
        get page() {
          return this.pdfViewer.currentPageNumber
        },
        set page(e) {
          this.pdfViewer.currentPageNumber = e
        },
        get supportsPrinting() {
          return U.instance.supportsPrinting
        },
        get supportsFullscreen() {
          return (0, s.shadow)(this, 'supportsFullscreen', document.fullscreenEnabled)
        },
        get supportsIntegratedFind() {
          return this.externalServices.supportsIntegratedFind
        },
        get supportsDocumentFonts() {
          return this.externalServices.supportsDocumentFonts
        },
        get loadingBar() {
          const e = new n.ProgressBar('loadingBar')
          return (0, s.shadow)(this, 'loadingBar', e)
        },
        get supportedMouseWheelZoomModifierKeys() {
          return this.externalServices.supportedMouseWheelZoomModifierKeys
        },
        initPassiveLoading() {
          throw new Error('Not implemented: initPassiveLoading')
        },
        setTitleUsingUrl() {
          const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ''
          const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
          this.url = e
          this.baseUrl = e.split('#')[0]
          t && (this._downloadUrl = t === e ? this.baseUrl : t.split('#')[0])
          let i = (0, s.getPdfFilenameFromUrl)(e, '')
          if (!i)
            try {
              i = decodeURIComponent((0, s.getFilenameFromUrl)(e)) || e
            } catch (t) {
              i = e
            }
          this.setTitle(i)
        },
        setTitle() {
          const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._title
          this._title = e
          this.isViewerEmbedded ||
            (document.title = `${this._hasAnnotationEditors ? '* ' : ''}${e}`)
        },
        get _docFilename() {
          return this._contentDispositionFilename || (0, s.getPdfFilenameFromUrl)(this.url)
        },
        _hideViewBookmark() {
          const { toolbar: e, secondaryToolbar: t } = this.appConfig
          e.viewBookmark.hidden = !0
          t.viewBookmarkButton.hidden = !0
        },
        _cancelIdleCallbacks() {
          if (this._idleCallbacks.size) {
            for (const e of this._idleCallbacks) window.cancelIdleCallback(e)
            this._idleCallbacks.clear()
          }
        },
        async close() {
          let e
          let t
          let i
          let n
          this._unblockDocumentLoadEvent()
          this._hideViewBookmark()
          const { container: s } = this.appConfig.errorWrapper
          s.hidden = !0
          if (!this.pdfLoadingTask) return
          document.focusAn != null && document.focusAn !== null && (document.focusAn = null)
          document.curDrawAnnot != null &&
            document.curDrawAnnot !== null &&
            (document.curDrawAnnot = null)
          ;(0, T.stopListenDragEvent)()
          document.getElementById('viewerContainer').style.cursor = 'default'
          if (
            ((e = this.pdfDocument) === null || void 0 === e ? void 0 : e.annotationStorage.size) >
              0 &&
            this._annotationStorageModified
          )
            try {
              await this.save()
            } catch (e) {}
          const a = []
          a.push(this.pdfLoadingTask.destroy())
          this.pdfLoadingTask = null
          if (this.pdfDocument) {
            this.pdfDocument = null
            this.pdfThumbnailViewer.setDocument(null)
            this.pdfViewer.setDocument(null)
            this.pdfLinkService.setDocument(null)
            this.pdfDocumentProperties.setDocument(null)
          }
          this.pdfLinkService.externalLinkEnabled = !0
          this.store = null
          this.isInitialViewSet = !1
          this.downloadComplete = !1
          this.url = ''
          this.baseUrl = ''
          this._downloadUrl = ''
          this.documentInfo = null
          this.metadata = null
          this._contentDispositionFilename = null
          this._contentLength = null
          this._saveInProgress = !1
          this._docStats = null
          this._hasAnnotationEditors = !1
          this._cancelIdleCallbacks()
          a.push(this.pdfScriptingManager.destroyPromise)
          this.setTitle()
          this.pdfSidebar.reset()
          this.pdfOutlineViewer.reset()
          this.pdfAttachmentViewer.reset()
          this.pdfLayerViewer.reset()((t = this.pdfHistory)) === null ||
            void 0 === t ||
            t.reset()((i = this.findBar)) === null ||
            void 0 === i ||
            i.reset()
          this.toolbar.reset()
          this.secondaryToolbar.reset()((n = this._PDFBug)) === null || void 0 === n || n.cleanup()
          await Promise.all(a)
        },
        async open(e, t) {
          ;(0, I.log_info)('begin to open file.....')
          this.pdfLoadingTask && (await this.close())
          const i = a.AppOptions.getAll(a.OptionKind.WORKER)
          for (const e in i) s.GlobalWorkerOptions[e] = i[e]
          const n = a.AppOptions.get('sensWords')
          for (const e in n) s.GlobalSensWords[e] = n[e]
          const r = Object.create(null)
          if (typeof e === 'string') {
            this.setTitleUsingUrl(e, e)
            r.url = e
          } else if (e && 'byteLength' in e) r.data = e
          else if (e.url && e.originalUrl) {
            this.setTitleUsingUrl(e.originalUrl, e.url)
            r.url = e.url
          }
          const o = a.AppOptions.getAll(a.OptionKind.API)
          for (const e in o) {
            const t = o[e]
            r[e] = t
          }
          if (t) for (const e in t) r[e] = t[e]
          const l = (0, s.getDocument)(r)
          this.pdfLoadingTask = l
          l.onPassword = (e, t) => {
            this.pdfLinkService.externalLinkEnabled = !1
            this.passwordPrompt.setUpdateCallback(e, t)
            this.passwordPrompt.open()
          }
          l.onProgress = (e) => {
            const { loaded: t, total: i } = e
            this.progress(t / i)
          }
          l.onUnsupportedFeature = this.fallback.bind(this)
          return l.promise.then(
            (e) => {
              this.load(e)
              console.info('open pdf file.....')
              ;(0, D.dispatchCustomEvent)('docOpened', {}, parent.document)
            },
            (e) => {
              if (l !== this.pdfLoadingTask) return
              let t = 'loading_error'
              e instanceof s.InvalidPDFException
                ? (t = 'invalid_file_error')
                : e instanceof s.MissingPDFException
                ? (t = 'missing_file_error')
                : e instanceof s.UnexpectedResponseException && (t = 'unexpected_response_error')
              return this.l10n.get(t).then((t) => {
                this._documentError(t, { message: e == null ? void 0 : e.message })
                throw e
              })
            }
          )
        },
        _ensureDownloadComplete() {
          if (!this.pdfDocument || !this.downloadComplete)
            throw new Error('PDF document not downloaded.')
        },
        async download() {
          const e = this._downloadUrl
          const t = this._docFilename
          try {
            this._ensureDownloadComplete()
            const i = await this.pdfDocument.getData()
            const n = new Blob([i], { type: 'application/pdf' })
            await this.downloadManager.download(n, e, t)
          } catch (i) {
            await this.downloadManager.downloadUrl(e, t)
          }
        },
        async save() {
          if (this._saveInProgress) return
          this._saveInProgress = !0
          await this.pdfScriptingManager.dispatchWillSave()
          const e = this._downloadUrl
          const t = this._docFilename
          try {
            this._ensureDownloadComplete()
            const i = await this.pdfDocument.saveDocument()
            const n = new Blob([i], { type: 'application/pdf' })
            await this.downloadManager.download(n, e, t)
          } catch (e) {
            console.error(`Error when saving the document: ${e.message}`)
            await this.download()
          } finally {
            await this.pdfScriptingManager.dispatchDidSave()
            this._saveInProgress = !1
          }
          this._hasAnnotationEditors &&
            this.externalServices.reportTelemetry({ type: 'editing', data: { type: 'save' } })
        },
        downloadOrSave() {
          let e
          ;((e = this.pdfDocument) === null || void 0 === e ? void 0 : e.annotationStorage.size) > 0
            ? this.save()
            : this.download()
        },
        fallback(e) {
          this.externalServices.reportTelemetry({ type: 'unsupportedFeature', featureId: e })
        },
        _documentError(e) {
          let t
          const i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
          this._unblockDocumentLoadEvent()
          this._otherError(e, i)
          this.eventBus.dispatch('documenterror', {
            source: this,
            message: e,
            reason: (t = i == null ? void 0 : i.message) !== null && void 0 !== t ? t : null
          })
        },
        _otherError(e) {
          const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
          const i = [
            this.l10n.get('error_version_info', {
              version: s.version || '?',
              build: s.build || '?'
            })
          ]
          if (t) {
            i.push(this.l10n.get('error_message', { message: t.message }))
            if (t.stack) i.push(this.l10n.get('error_stack', { stack: t.stack }))
            else {
              t.filename && i.push(this.l10n.get('error_file', { file: t.filename }))
              t.lineNumber && i.push(this.l10n.get('error_line', { line: t.lineNumber }))
            }
          }
          const a = this.appConfig.errorWrapper
          const r = a.container
          r.hidden = !1
          a.errorMessage.textContent = e
          const o = a.closeButton
          o.onclick = function () {
            r.hidden = !0
          }
          const l = a.errorMoreInfo
          const c = a.moreInfoButton
          const d = a.lessInfoButton
          c.onclick = function () {
            l.hidden = !1
            c.hidden = !0
            d.hidden = !1
            l.style.height = `${l.scrollHeight}px`
          }
          d.onclick = function () {
            l.hidden = !0
            c.hidden = !1
            d.hidden = !0
          }
          c.oncontextmenu = n.noContextMenuHandler
          d.oncontextmenu = n.noContextMenuHandler
          o.oncontextmenu = n.noContextMenuHandler
          c.hidden = !1
          d.hidden = !0
          Promise.all(i).then((e) => {
            l.value = e.join('\n')
          })
        },
        progress(e) {
          let t
          let i
          if (this.downloadComplete) return
          const n = Math.round(100 * e)
          if (n <= this.loadingBar.percent) return
          this.loadingBar.percent = n
          if (
            ((t =
              (i = this.pdfDocument) === null || void 0 === i
                ? void 0
                : i.loadingParams.disableAutoFetch) !== null && void 0 !== t
              ? t
              : a.AppOptions.get('disableAutoFetch')) &&
            !isNaN(n)
          ) {
            if (this.disableAutoFetchLoadingBarTimeout) {
              clearTimeout(this.disableAutoFetchLoadingBarTimeout)
              this.disableAutoFetchLoadingBarTimeout = null
            }
            this.loadingBar.show()
            this.disableAutoFetchLoadingBarTimeout = setTimeout(() => {
              this.loadingBar.hide()
              this.disableAutoFetchLoadingBarTimeout = null
            }, 5e3)
          }
        },
        load(e) {
          ;(0, I.log_info)('begin to load document....')
          console.time('begin to load document....')
          this.pdfDocument = e
          e.getDownloadInfo().then((e) => {
            const { length: t } = e
            this._contentLength = t
            this.downloadComplete = !0
            this.loadingBar.hide()
            l.then(() => {
              this.eventBus.dispatch('documentloaded', { source: this })
            })
          })
          const t = e.getPageLayout().catch(function () {})
          const i = e.getPageMode().catch(function () {})
          const s = e.getOpenAction().catch(function () {})
          this.toolbar.setPagesCount(e.numPages, !1)
          this.secondaryToolbar.setPagesCount(e.numPages)
          let r
          r = null
          this.pdfLinkService.setDocument(e, null)
          this.pdfDocumentProperties.setDocument(e)
          const o = this.pdfViewer
          o.setDocument(e)
          const { firstPagePromise: l, onePageRendered: c, pagesPromise: d } = o
          this.pdfThumbnailViewer.setDocument(e)
          const h = (this.store = new M.ViewHistory(e.fingerprints[0]))
            .getMultiple({
              page: null,
              zoom: n.DEFAULT_SCALE_VALUE,
              scrollLeft: '0',
              scrollTop: '0',
              rotation: null,
              sidebarView: n.SidebarView.UNKNOWN,
              scrollMode: n.ScrollMode.UNKNOWN,
              spreadMode: n.SpreadMode.UNKNOWN
            })
            .catch(() => Object.create(null))
          l.then((r) => {
            this.loadingBar.setWidth(this.appConfig.viewerContainer)
            this._initializeAnnotationStorageCallbacks(e)
            Promise.all([n.animationStarted, h, t, i, s])
              .then(async (t) => {
                const [i, s, r, l, c] = t
                const h = a.AppOptions.get('viewOnLoad')
                this._initializePdfHistory({
                  fingerprint: e.fingerprints[0],
                  viewOnLoad: h,
                  initialDest: c == null ? void 0 : c.dest
                })
                const u = this.initialBookmark
                const p = a.AppOptions.get('defaultZoomValue')
                let g = p ? `zoom=${p}` : null
                let f = null
                let m = a.AppOptions.get('sidebarViewOnLoad')
                let v = a.AppOptions.get('scrollModeOnLoad')
                let _ = a.AppOptions.get('spreadModeOnLoad')
                if (s.page && h !== O) {
                  g = `page=${s.page}&zoom=${p || s.zoom},${s.scrollLeft},${s.scrollTop}`
                  f = parseInt(s.rotation, 10)
                  m === n.SidebarView.UNKNOWN && (m = 0 | s.sidebarView)
                  v === n.ScrollMode.UNKNOWN && (v = 0 | s.scrollMode)
                  _ === n.SpreadMode.UNKNOWN && (_ = 0 | s.spreadMode)
                }
                l && m === n.SidebarView.UNKNOWN && (m = (0, n.apiPageModeToSidebarView)(l))
                if (r && v === n.ScrollMode.UNKNOWN && _ === n.SpreadMode.UNKNOWN) {
                  _ = (0, n.apiPageLayoutToViewerModes)(r).spreadMode
                }
                this.setInitialView(g, {
                  rotation: f,
                  sidebarView: m,
                  scrollMode: v,
                  spreadMode: _
                })
                this.eventBus.dispatch('documentinit', { source: this })
                this.isViewerEmbedded || o.focus()
                await Promise.race([
                  d,
                  new Promise((e) => {
                    setTimeout(e, 1e4)
                  })
                ])
                if ((u || g) && !o.hasEqualPageSizes) {
                  this.initialBookmark = u
                  o.currentScaleValue = o.currentScaleValue
                  this.setInitialView(g)
                }
              })
              .catch(() => {
                this.setInitialView()
              })
              .then(function () {
                o.update()
              })
          })
          d.then(
            () => {
              this._unblockDocumentLoadEvent()
              this._initializeAutoPrint(e, s)
            },
            (e) => {
              this.l10n.get('loading_error').then((t) => {
                this._documentError(t, { message: e == null ? void 0 : e.message })
              })
            }
          )
          c.then((t) => {
            this.externalServices.reportTelemetry({ type: 'pageInfo', timestamp: t.timestamp })
            e.getOutline().then((t) => {
              e === this.pdfDocument && this.pdfOutlineViewer.render({ outline: t, pdfDocument: e })
            })
            e.getAttachments().then((t) => {
              e === this.pdfDocument && this.pdfAttachmentViewer.render({ attachments: t })
            })
            o.optionalContentConfigPromise.then((t) => {
              e === this.pdfDocument &&
                this.pdfLayerViewer.render({ optionalContentConfig: t, pdfDocument: e })
            })
            if ('requestIdleCallback' in window) {
              const t = window.requestIdleCallback(
                () => {
                  this._collectTelemetry(e)
                  this._idleCallbacks.delete(t)
                },
                { timeout: 1e3 }
              )
              this._idleCallbacks.add(t)
            }
          })
          this._initializePageLabels(e)
          this._initializeMetadata(e)
          ;(0, D.dispatchCustomEvent)('DocRendered', {}, parent.document)
          console.timeEnd('begin to load document....')
        },
        async _scriptingDocProperties(e) {
          let t
          let i
          if (!this.documentInfo) {
            await new Promise((e) => {
              this.eventBus._on('metadataloaded', e, { once: !0 })
            })
            if (e !== this.pdfDocument) return null
          }
          if (!this._contentLength) {
            await new Promise((e) => {
              this.eventBus._on('documentloaded', e, { once: !0 })
            })
            if (e !== this.pdfDocument) return null
          }
          return {
            ...this.documentInfo,
            baseURL: this.baseUrl,
            filesize: this._contentLength,
            filename: this._docFilename,
            metadata: (t = this.metadata) === null || void 0 === t ? void 0 : t.getRaw(),
            authors: (i = this.metadata) === null || void 0 === i ? void 0 : i.get('dc:creator'),
            numPages: this.pagesCount,
            URL: this.url
          }
        },
        async _collectTelemetry(e) {
          const t = await this.pdfDocument.getMarkInfo()
          if (e !== this.pdfDocument) return
          const i = (t == null ? void 0 : t.Marked) || !1
          this.externalServices.reportTelemetry({ type: 'tagged', tagged: i })
        },
        async _initializeAutoPrint(e, t) {
          const [i, a] = await Promise.all([
            t,
            this.pdfViewer.enableScripting ? null : e.getJavaScript()
          ])
          if (e !== this.pdfDocument) return
          let r = !1(i == null ? void 0 : i.action) === 'Print' && (r = !0)
          if (a) {
            a.some((e) => {
              if (!e) return !1
              console.warn('Warning: JavaScript support is not enabled')
              this.fallback(s.UNSUPPORTED_FEATURES.javaScript)
              return !0
            })
            if (!r)
              for (const e of a)
                if (e && n.AutoPrintRegExp.test(e)) {
                  r = !0
                  break
                }
          }
          r && this.triggerPrinting()
        },
        async _initializeMetadata(e) {
          let t
          let i
          const {
            info: n,
            metadata: a,
            contentDispositionFilename: r,
            contentLength: o
          } = await e.getMetadata()
          if (e !== this.pdfDocument) return
          this.documentInfo = n
          this.metadata = a
          ;((t = this._contentDispositionFilename) !== null && void 0 !== t) ||
            (this._contentDispositionFilename = r)
          ;((i = this._contentLength) !== null && void 0 !== i) || (this._contentLength = o)
          console.log(
            `PDF ${e.fingerprints[0]} [${n.PDFFormatVersion} ${(n.Producer || '-').trim()} / ${(
              n.Creator || '-'
            ).trim()}] (PDF.js: ${s.version || '-'})`
          )
          let l = n.Title
          const c = a == null ? void 0 : a.get('dc:title')
          c && (c === 'Untitled' || /[\uFFF0-\uFFFF]/g.test(c) || (l = c))
          l
            ? this.setTitle(`${l} - ${this._contentDispositionFilename || this._title}`)
            : this._contentDispositionFilename && this.setTitle(this._contentDispositionFilename)
          if (!n.IsXFAPresent || n.IsAcroFormPresent || e.isPureXfa) {
            if ((n.IsAcroFormPresent || n.IsXFAPresent) && !this.pdfViewer.renderForms) {
              console.warn('Warning: Interactive form support is not enabled')
              this.fallback(s.UNSUPPORTED_FEATURES.forms)
            }
          } else {
            e.loadingParams.enableXfa
              ? console.warn('Warning: XFA Foreground documents are not supported')
              : console.warn('Warning: XFA support is not enabled')
            this.fallback(s.UNSUPPORTED_FEATURES.forms)
          }
          if (n.IsSignaturesPresent) {
            console.warn('Warning: Digital signatures validation is not supported')
            this.fallback(s.UNSUPPORTED_FEATURES.signatures)
          }
          let d = 'other'
          B.includes(n.PDFFormatVersion) && (d = `v${n.PDFFormatVersion.replace('.', '_')}`)
          let h = 'other'
          if (n.Producer) {
            const e = n.Producer.toLowerCase()
            G.some(function (t) {
              if (!e.includes(t)) return !1
              h = t.replace(/[ .-]/g, '_')
              return !0
            })
          }
          let u = null
          n.IsXFAPresent ? (u = 'xfa') : n.IsAcroFormPresent && (u = 'acroform')
          this.externalServices.reportTelemetry({
            type: 'documentInfo',
            version: d,
            generator: h,
            formType: u
          })
          this.eventBus.dispatch('metadataloaded', { source: this })
        },
        async _initializePageLabels(e) {
          const t = await e.getPageLabels()
          if (e !== this.pdfDocument) return
          if (!t || a.AppOptions.get('disablePageLabels')) return
          const i = t.length
          let n = 0
          let s = 0
          for (let e = 0; e < i; e++) {
            const i = t[e]
            if (i === (e + 1).toString()) n++
            else {
              if (i !== '') break
              s++
            }
          }
          if (n >= i || s >= i) return
          const { pdfViewer: r, pdfThumbnailViewer: o, toolbar: l } = this
          r.setPageLabels(t)
          o.setPageLabels(t)
          l.setPagesCount(i, !0)
          l.setPageNumber(r.currentPageNumber, r.currentPageLabel)
        },
        _initializePdfHistory(e) {
          const { fingerprint: t, viewOnLoad: i, initialDest: n = null } = e
          if (this.pdfHistory) {
            this.pdfHistory.initialize({
              fingerprint: t,
              resetHistory: i === O,
              updateUrl: a.AppOptions.get('historyUpdateUrl')
            })
            if (this.pdfHistory.initialBookmark) {
              this.initialBookmark = this.pdfHistory.initialBookmark
              this.initialRotation = this.pdfHistory.initialRotation
            }
            if (n && !this.initialBookmark && i === R) {
              this.initialBookmark = JSON.stringify(n)
              this.pdfHistory.push({ explicitDest: n, pageNumber: null })
            }
          }
        },
        _initializeAnnotationStorageCallbacks(e) {
          if (e !== this.pdfDocument) return
          const { annotationStorage: t } = e
          t.onSetModified = () => {
            window.addEventListener('beforeunload', beforeUnload)
            this._annotationStorageModified = !0
          }
          t.onResetModified = () => {
            window.removeEventListener('beforeunload', beforeUnload)
            delete this._annotationStorageModified
          }
          t.onAnnotationEditor = (e) => {
            this._hasAnnotationEditors = !!e
            this.setTitle()
            e && this.externalServices.reportTelemetry({ type: 'editing', data: { type: e } })
          }
        },
        setInitialView(e) {
          const {
            rotation: t,
            sidebarView: i,
            scrollMode: s,
            spreadMode: a
          } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
          const setRotation = (e) => {
            ;(0, n.isValidRotation)(e) && (this.pdfViewer.pagesRotation = e)
          }
          this.isInitialViewSet = !0
          this.pdfSidebar.setInitialView(i)
          ;((e, t) => {
            ;(0, n.isValidScrollMode)(e) && (this.pdfViewer.scrollMode = e)
            ;(0, n.isValidSpreadMode)(t) && (this.pdfViewer.spreadMode = t)
          })(s, a)
          if (this.initialBookmark) {
            setRotation(this.initialRotation)
            delete this.initialRotation
            this.pdfLinkService.setHash(this.initialBookmark)
            this.initialBookmark = null
          } else if (e) {
            setRotation(t)
            this.pdfLinkService.setHash(e)
          }
          this.toolbar.setPageNumber(
            this.pdfViewer.currentPageNumber,
            this.pdfViewer.currentPageLabel
          )
          this.secondaryToolbar.setPageNumber(this.pdfViewer.currentPageNumber)
          this.pdfViewer.currentScaleValue ||
            (this.pdfViewer.currentScaleValue = n.DEFAULT_SCALE_VALUE)
        },
        _cleanup() {
          if (this.pdfDocument) {
            this.pdfViewer.cleanup()
            this.pdfThumbnailViewer.cleanup()
            this.pdfDocument.cleanup(this.pdfViewer.renderer === n.RendererType.SVG)
          }
        },
        forceRendering() {
          this.pdfRenderingQueue.printing = !!this.printService
          this.pdfRenderingQueue.isThumbnailViewEnabled =
            this.pdfSidebar.visibleView === n.SidebarView.THUMBS
          this.pdfRenderingQueue.renderHighestPriority()
        },
        beforePrint() {
          this._printAnnotationStoragePromise = this.pdfScriptingManager
            .dispatchWillPrint()
            .catch(() => {})
            .then(() => {
              let e
              return (e = this.pdfDocument) === null || void 0 === e
                ? void 0
                : e.annotationStorage.print
            })
          if (this.printService) return
          if (!this.supportsPrinting) {
            this.l10n.get('printing_not_supported').then((e) => {
              this._otherError(e)
            })
            return
          }
          if (!this.pdfViewer.pageViewsReady) {
            this.l10n.get('printing_not_ready').then((e) => {
              window.alert(e)
            })
            return
          }
          const e = this.pdfViewer.getPagesOverview()
          const t = this.appConfig.printContainer
          const i = a.AppOptions.get('printResolution')
          const n = this.pdfViewer.optionalContentConfigPromise
          const s = U.instance.createPrintService(
            this.pdfDocument,
            e,
            t,
            i,
            n,
            this._printAnnotationStoragePromise,
            this.l10n
          )
          this.printService = s
          this.forceRendering()
          s.layout()
          this.externalServices.reportTelemetry({ type: 'print' })
          this._hasAnnotationEditors &&
            this.externalServices.reportTelemetry({ type: 'editing', data: { type: 'print' } })
        },
        afterPrint() {
          if (this._printAnnotationStoragePromise) {
            this._printAnnotationStoragePromise.then(() => {
              this.pdfScriptingManager.dispatchDidPrint()
            })
            this._printAnnotationStoragePromise = null
          }
          if (this.printService) {
            let e
            this.printService.destroy()
            this.printService =
              null((e = this.pdfDocument)) === null ||
              void 0 === e ||
              e.annotationStorage.resetModified()
          }
          this.forceRendering()
        },
        rotatePages(e) {
          this.pdfViewer.pagesRotation += e
        },
        requestPresentationMode() {
          let e
          ;(e = this.pdfPresentationMode) === null || void 0 === e || e.request()
        },
        triggerPrinting() {
          this.supportsPrinting && window.print()
        },
        bindEvents() {
          const { eventBus: e, _boundEvents: t } = this
          t.beforePrint = this.beforePrint.bind(this)
          t.afterPrint = this.afterPrint.bind(this)
          e._on('resize', webViewerResize)
          e._on('hashchange', webViewerHashchange)
          e._on('beforeprint', t.beforePrint)
          e._on('afterprint', t.afterPrint)
          e._on('pagerendered', webViewerPageRendered)
          e._on('updateviewarea', webViewerUpdateViewarea)
          e._on('pagechanging', webViewerPageChanging)
          e._on('scalechanging', webViewerScaleChanging)
          e._on('rotationchanging', webViewerRotationChanging)
          e._on('sidebarviewchanged', webViewerSidebarViewChanged)
          e._on('pagemode', webViewerPageMode)
          e._on('namedaction', webViewerNamedAction)
          e._on('presentationmodechanged', webViewerPresentationModeChanged)
          e._on('presentationmode', webViewerPresentationMode)
          e._on('switchannotationeditormode', webViewerSwitchAnnotationEditorMode)
          e._on('switchannotationeditorparams', webViewerSwitchAnnotationEditorParams)
          e._on('print', webViewerPrint)
          e._on('download', webViewerDownload)
          e._on('firstpage', webViewerFirstPage)
          e._on('lastpage', webViewerLastPage)
          e._on('nextpage', webViewerNextPage)
          e._on('previouspage', webViewerPreviousPage)
          e._on('zoomin', webViewerZoomIn)
          e._on('zoomout', webViewerZoomOut)
          e._on('zoomreset', webViewerZoomReset)
          e._on('pagenumberchanged', webViewerPageNumberChanged)
          e._on('scalechanged', webViewerScaleChanged)
          e._on('rotatecw', webViewerRotateCw)
          e._on('rotateccw', webViewerRotateCcw)
          e._on('optionalcontentconfig', webViewerOptionalContentConfig)
          e._on('switchscrollmode', webViewerSwitchScrollMode)
          e._on('scrollmodechanged', webViewerScrollModeChanged)
          e._on('switchspreadmode', webViewerSwitchSpreadMode)
          e._on('spreadmodechanged', webViewerSpreadModeChanged)
          e._on('documentproperties', webViewerDocumentProperties)
          e._on('findfromurlhash', webViewerFindFromUrlHash)
          e._on('updatefindmatchescount', webViewerUpdateFindMatchesCount)
          e._on('updatefindcontrolstate', webViewerUpdateFindControlState)
          if (a.AppOptions.get('pdfBug')) {
            t.reportPageStatsPDFBug = reportPageStatsPDFBug
            e._on('pagerendered', t.reportPageStatsPDFBug)
            e._on('pagechanging', t.reportPageStatsPDFBug)
          }
          e._on('fileinputchange', webViewerFileInputChange)
          e._on('openfile', webViewerOpenFile)
          e._on('lineannot', webViewerAddLineAnnot)
          e._on('selecttool', webViewerPressSelectTool)
        },
        bindWindowEvents() {
          const { eventBus: e, _boundEvents: t } = this
          !(function addWindowResolutionChange() {
            const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
            e && webViewerResolutionChange(e)
            const i = window.matchMedia(`(resolution: ${window.devicePixelRatio || 1}dppx)`)
            i.addEventListener('change', addWindowResolutionChange, { once: !0 })
            t.removeWindowResolutionChange ||
              (t.removeWindowResolutionChange = function () {
                i.removeEventListener('change', addWindowResolutionChange)
                t.removeWindowResolutionChange = null
              })
          })()
          t.windowResize = () => {
            e.dispatch('resize', { source: window })
          }
          t.windowHashChange = () => {
            e.dispatch('hashchange', {
              source: window,
              hash: document.location.hash.substring(1)
            })
          }
          t.windowBeforePrint = () => {
            e.dispatch('beforeprint', { source: window })
          }
          t.windowAfterPrint = () => {
            e.dispatch('afterprint', { source: window })
          }
          t.windowUpdateFromSandbox = (t) => {
            e.dispatch('updatefromsandbox', { source: window, detail: t.detail })
          }
          window.addEventListener('visibilitychange', webViewerVisibilityChange)
          window.addEventListener('wheel', webViewerWheel, { passive: !1 })
          window.addEventListener('touchstart', webViewerTouchStart, { passive: !1 })
          window.addEventListener('click', webViewerClick)
          window.addEventListener('keydown', webViewerKeyDown)
          window.addEventListener('resize', t.windowResize)
          window.addEventListener('hashchange', t.windowHashChange)
          window.addEventListener('beforeprint', t.windowBeforePrint)
          window.addEventListener('afterprint', t.windowAfterPrint)
          window.addEventListener('updatefromsandbox', t.windowUpdateFromSandbox)
        },
        unbindEvents() {
          const { eventBus: e, _boundEvents: t } = this
          e._off('resize', webViewerResize)
          e._off('hashchange', webViewerHashchange)
          e._off('beforeprint', t.beforePrint)
          e._off('afterprint', t.afterPrint)
          e._off('pagerendered', webViewerPageRendered)
          e._off('updateviewarea', webViewerUpdateViewarea)
          e._off('pagechanging', webViewerPageChanging)
          e._off('scalechanging', webViewerScaleChanging)
          e._off('rotationchanging', webViewerRotationChanging)
          e._off('sidebarviewchanged', webViewerSidebarViewChanged)
          e._off('pagemode', webViewerPageMode)
          e._off('namedaction', webViewerNamedAction)
          e._off('presentationmodechanged', webViewerPresentationModeChanged)
          e._off('presentationmode', webViewerPresentationMode)
          e._off('print', webViewerPrint)
          e._off('download', webViewerDownload)
          e._off('firstpage', webViewerFirstPage)
          e._off('lastpage', webViewerLastPage)
          e._off('nextpage', webViewerNextPage)
          e._off('previouspage', webViewerPreviousPage)
          e._off('zoomin', webViewerZoomIn)
          e._off('zoomout', webViewerZoomOut)
          e._off('zoomreset', webViewerZoomReset)
          e._off('pagenumberchanged', webViewerPageNumberChanged)
          e._off('scalechanged', webViewerScaleChanged)
          e._off('rotatecw', webViewerRotateCw)
          e._off('rotateccw', webViewerRotateCcw)
          e._off('optionalcontentconfig', webViewerOptionalContentConfig)
          e._off('switchscrollmode', webViewerSwitchScrollMode)
          e._off('scrollmodechanged', webViewerScrollModeChanged)
          e._off('switchspreadmode', webViewerSwitchSpreadMode)
          e._off('spreadmodechanged', webViewerSpreadModeChanged)
          e._off('documentproperties', webViewerDocumentProperties)
          e._off('findfromurlhash', webViewerFindFromUrlHash)
          e._off('updatefindmatchescount', webViewerUpdateFindMatchesCount)
          e._off('updatefindcontrolstate', webViewerUpdateFindControlState)
          if (t.reportPageStatsPDFBug) {
            e._off('pagerendered', t.reportPageStatsPDFBug)
            e._off('pagechanging', t.reportPageStatsPDFBug)
            t.reportPageStatsPDFBug = null
          }
          e._off('fileinputchange', webViewerFileInputChange)
          e._off('openfile', webViewerOpenFile)
          e._off('lineannot', webViewerAddLineAnnot)
          e._off('selecttool', webViewerPressSelectTool)
          t.beforePrint = null
          t.afterPrint = null
        },
        unbindWindowEvents() {
          let e
          const { _boundEvents: t } = this
          window.removeEventListener('visibilitychange', webViewerVisibilityChange)
          window.removeEventListener('wheel', webViewerWheel, { passive: !1 })
          window.removeEventListener('touchstart', webViewerTouchStart, { passive: !1 })
          window.removeEventListener('click', webViewerClick)
          window.removeEventListener('keydown', webViewerKeyDown)
          window.removeEventListener('resize', t.windowResize)
          window.removeEventListener('hashchange', t.windowHashChange)
          window.removeEventListener('beforeprint', t.windowBeforePrint)
          window.removeEventListener('afterprint', t.windowAfterPrint)
          window.removeEventListener(
            'updatefromsandbox',
            t.windowUpdateFromSandbox
          )((e = t.removeWindowResolutionChange)) === null ||
            void 0 === e ||
            e.call(t)
          t.windowResize = null
          t.windowHashChange = null
          t.windowBeforePrint = null
          t.windowAfterPrint = null
          t.windowUpdateFromSandbox = null
        },
        accumulateWheelTicks(e) {
          ;((this._wheelUnusedTicks > 0 && e < 0) || (this._wheelUnusedTicks < 0 && e > 0)) &&
            (this._wheelUnusedTicks = 0)
          this._wheelUnusedTicks += e
          const t = Math.sign(this._wheelUnusedTicks) * Math.floor(Math.abs(this._wheelUnusedTicks))
          this._wheelUnusedTicks -= t
          return t
        },
        _unblockDocumentLoadEvent() {
          let e
          let t
          ;(e = (t = document).blockUnblockOnload) === null || void 0 === e || e.call(t, !1)
          this._unblockDocumentLoadEvent = () => {}
        },
        _reportDocumentStatsTelemetry() {
          const { stats: e } = this.pdfDocument
          if (e !== this._docStats) {
            this._docStats = e
            this.externalServices.reportTelemetry({ type: 'documentStats', stats: e })
          }
        },
        get scriptingReady() {
          return this.pdfScriptingManager.ready
        }
      }
      t.PDFViewerApplication = V
      let W
      {
        const e = ['null', 'http://mozilla.github.io', 'https://mozilla.github.io']
        W = function (t) {
          if (t)
            try {
              const i = new URL(window.location.href).origin || 'null'
              if (e.includes(i)) return
              if (new URL(t, window.location.href).origin !== i)
                throw new Error("file origin does not match viewer's")
            } catch (e) {
              V.l10n.get('loading_error').then((t) => {
                V._documentError(t, { message: e == null ? void 0 : e.message })
              })
              throw e
            }
        }
      }
      async function loadPDFBug(e) {
        const { debuggerScriptPath: t } = e.appConfig
        const { PDFBug: i } = await import(t)
        e._PDFBug = i
      }
      function reportPageStatsPDFBug(e) {
        let t
        let i
        const { pageNumber: n } = e
        if ((t = globalThis.Stats) === null || void 0 === t || !t.enabled) return
        const s = V.pdfViewer.getPageView(n - 1)
        globalThis.Stats.add(
          n,
          s == null || (i = s.pdfPage) === null || void 0 === i ? void 0 : i.stats
        )
      }
      function webViewerInitialized() {
        let e
        console.time('init web viewer finished.....')
        const { appConfig: t, eventBus: i } = V
        let s
        const r = document.location.search.substring(1)
        s =
          (e = (0, n.parseQueryString)(r).get('file')) !== null && void 0 !== e
            ? e
            : a.AppOptions.get('defaultUrl')
        W(s)
        const o = t.openFileInput
        o.value = null
        o.addEventListener('change', function (e) {
          const { files: t } = e.target
          t &&
            t.length !== 0 &&
            i.dispatch('fileinputchange', { source: this, fileInput: e.target })
        })
        t.mainContainer.addEventListener('dragover', function (e) {
          e.preventDefault()
          e.dataTransfer.dropEffect = e.dataTransfer.effectAllowed === 'copy' ? 'copy' : 'move'
        })
        t.mainContainer.addEventListener('drop', function (e) {
          e.preventDefault()
          const { files: t } = e.dataTransfer
          t &&
            t.length !== 0 &&
            i.dispatch('fileinputchange', { source: this, fileInput: e.dataTransfer })
        })
        if (!V.supportsDocumentFonts) {
          a.AppOptions.set('disableFontFace', !0)
          V.l10n.get('web_fonts_disabled').then((e) => {
            console.warn(e)
          })
        }
        ;(0, D.dispatchCustomEvent)('webViewerInitialized', {}, parent.document)
        if (!V.supportsPrinting) {
          t.toolbar.print.classList.add('hidden')
          t.secondaryToolbar.printButton.classList.add('hidden')
        }
        if (!V.supportsFullscreen) {
          t.toolbar.presentationModeButton.classList.add('hidden')
          t.secondaryToolbar.presentationModeButton.classList.add('hidden')
        }
        V.supportsIntegratedFind && t.toolbar.viewFind.classList.add('hidden')
        t.mainContainer.addEventListener(
          'transitionend',
          function (e) {
            e.target === this && V.eventBus.dispatch('resize', { source: this })
          },
          !0
        )
        try {
          s ? V.open(s) : V._hideViewBookmark()
        } catch (e) {
          V.l10n.get('loading_error').then((t) => {
            V._documentError(t, e)
          })
        }
        ;(0, T.listenClickEvent)()
        console.timeEnd('init web viewer finished.....')
      }
      function webViewerPageRendered(e) {
        const { pageNumber: t, error: i } = e
        ;(0, I.log_debug)(`into webViewerPageRendered, page index = ${t}`)
        t === V.page && V.toolbar.updateLoadingIndicatorState(!1)
        const s = t - 1
        const r = V.pdfViewer.getPageView(s)
        if (V.pdfSidebar.visibleView === n.SidebarView.THUMBS) {
          const e = V.pdfThumbnailViewer.getThumbnail(t - 1)
          r && e && e.setImage(r)
        }
        i &&
          V.l10n.get('rendering_error').then((e) => {
            V._otherError(e, i)
          })
        V._reportDocumentStatsTelemetry()
        const o = a.AppOptions.get('annotArray')
        const l = a.AppOptions.get('waterMarkOption')
        let c = !1
        l != null && (c = (0, k.drawWaterMark)(r, l))
        r.saveInitPageSnapShot()
        c = r.redrawPageAnnot()
        r.redrawSignture()
        for (let d = 0; o != null && d < o.length; ++d)
          if (o[d] != null && o[d].page == t) {
            let h = null
            const u = r.lookupBjcaAnnot(o[d].id)
            if (u < 0) {
              h = new T.BjcaAnnotInfo(o[d])
              r.putBjcaAnnotInfo(h)
            } else h = r.getBjcaAnnotInfo(u)
            c = !0
            h.draw(r.canvas)
          }
        c && r.saveSnapShot()
        if (document.focusAn != null && document.focusAn !== null && document.focusAn.page == t) {
          r.saveSnapShot()
          document.focusAn.drawBorder(r.canvas)
        }
        ;(0, I.log_debug)(`finish webViewerPageRendered, page index = ${t}`)
      }
      function webViewerPageMode(e) {
        let t
        const { mode: i } = e
        switch (i) {
          case 'thumbs':
            t = n.SidebarView.THUMBS
            break
          case 'bookmarks':
          case 'outline':
            t = n.SidebarView.OUTLINE
            break
          case 'attachments':
            t = n.SidebarView.ATTACHMENTS
            break
          case 'layers':
            t = n.SidebarView.LAYERS
            break
          case 'none':
            t = n.SidebarView.NONE
            break
          default:
            console.error(`Invalid "pagemode" hash parameter: ${i}`)
            return
        }
        V.pdfSidebar.switchView(t, !0)
      }
      function webViewerNamedAction(e) {
        switch (e.action) {
          case 'GoToPage':
            V.appConfig.toolbar.pageNumber.select()
            break
          case 'Find':
            V.supportsIntegratedFind || V.findBar.toggle()
            break
          case 'Print':
            V.triggerPrinting()
            break
          case 'SaveAs':
            V.downloadOrSave()
        }
      }
      function webViewerPresentationModeChanged(e) {
        V.pdfViewer.presentationModeState = e.state
      }
      function webViewerSidebarViewChanged(e) {
        const { view: t } = e
        V.pdfRenderingQueue.isThumbnailViewEnabled = t === n.SidebarView.THUMBS
        if (V.isInitialViewSet) {
          let i
          ;(i = V.store) === null || void 0 === i || i.set('sidebarView', t).catch(() => {})
        }
      }
      function webViewerUpdateViewarea(e) {
        const { location: t } = e
        if (V.isInitialViewSet) {
          let i
          ;(i = V.store) === null ||
            void 0 === i ||
            i
              .setMultiple({
                page: t.pageNumber,
                zoom: t.scale,
                scrollLeft: t.left,
                scrollTop: t.top,
                rotation: t.rotation
              })
              .catch(() => {})
        }
        const s = V.pdfLinkService.getAnchorUrl(t.pdfOpenParams)
        V.appConfig.toolbar.viewBookmark.href = s
        V.appConfig.secondaryToolbar.viewBookmarkButton.href = s
        const a = V.pdfViewer.getPageView(V.page - 1)
        const r = (a == null ? void 0 : a.renderingState) !== n.RenderingStates.FINISHED
        V.toolbar.updateLoadingIndicatorState(r)
      }
      function webViewerScrollModeChanged(e) {
        if (V.isInitialViewSet) {
          let t
          ;(t = V.store) === null || void 0 === t || t.set('scrollMode', e.mode).catch(() => {})
        }
      }
      function webViewerSpreadModeChanged(e) {
        if (V.isInitialViewSet) {
          let t
          ;(t = V.store) === null || void 0 === t || t.set('spreadMode', e.mode).catch(() => {})
        }
      }
      function webViewerResize() {
        const { pdfDocument: e, pdfViewer: t, pdfRenderingQueue: i } = V
        if (i.printing && window.matchMedia('print').matches) return
        t.updateContainerHeightCss()
        if (!e) return
        const n = t.currentScaleValue
        ;(n !== 'auto' && n !== 'page-fit' && n !== 'page-width') || (t.currentScaleValue = n)
        t.update()
      }
      function webViewerHashchange(e) {
        let t
        const i = e.hash
        i &&
          (V.isInitialViewSet
            ? ((t = V.pdfHistory) !== null && void 0 !== t && t.popStateInProgress) ||
              V.pdfLinkService.setHash(i)
            : (V.initialBookmark = i))
      }
      var webViewerFileInputChange = function (e) {
        let t
        if ((t = V.pdfViewer) !== null && void 0 !== t && t.isInPresentationMode) return
        const i = e.fileInput.files[0]
        let n = URL.createObjectURL(i)
        i.name && (n = { url: n, originalUrl: i.name })
        V.open(n)
      }
      var webViewerOpenFile = function (e) {
        V.appConfig.openFileInput.click()
      }
      function webViewerPresentationMode() {
        V.requestPresentationMode()
      }
      function webViewerSwitchAnnotationEditorMode(e) {
        V.pdfViewer.annotationEditorMode = e.mode
      }
      function webViewerSwitchAnnotationEditorParams(e) {
        V.pdfViewer.annotationEditorParams = e
      }
      function webViewerPrint() {
        V.triggerPrinting()
      }
      function webViewerDownload() {
        V.downloadOrSave()
      }
      function webViewerFirstPage() {
        V.pdfDocument && (V.page = 1)
      }
      function webViewerLastPage() {
        V.pdfDocument && (V.page = V.pagesCount)
      }
      function webViewerNextPage() {
        V.pdfViewer.nextPage()
      }
      function webViewerPreviousPage() {
        V.pdfViewer.previousPage()
      }
      function webViewerZoomIn() {
        V.zoomIn()
      }
      function webViewerZoomOut() {
        V.zoomOut()
      }
      function webViewerZoomReset() {
        V.zoomReset()
      }
      function webViewerAddLineAnnot() {
        ;(0, I.log_info)('click add line annot button')
        ;(0, T.listenMouseDragEvent)()
        document.getElementById('viewerContainer').style.cursor =
          'url("images/cursor-cross-25.cur") 12 12, default'
      }
      function webViewerPressSelectTool() {
        ;(0, I.log_info)('click select tool button')
        ;(0, T.stopListenDragEvent)()
        document.getElementById('viewerContainer').style.cursor = 'default'
      }
      function webViewerPageNumberChanged(e) {
        const t = V.pdfViewer
        e.value !== '' && V.pdfLinkService.goToPage(e.value)
        e.value !== t.currentPageNumber.toString() &&
          e.value !== t.currentPageLabel &&
          V.toolbar.setPageNumber(t.currentPageNumber, t.currentPageLabel)
      }
      function webViewerScaleChanged(e) {
        V.pdfViewer.currentScaleValue = e.value
      }
      function webViewerRotateCw() {
        V.rotatePages(90)
      }
      function webViewerRotateCcw() {
        V.rotatePages(-90)
      }
      function webViewerOptionalContentConfig(e) {
        V.pdfViewer.optionalContentConfigPromise = e.promise
      }
      function webViewerSwitchScrollMode(e) {
        V.pdfViewer.scrollMode = e.mode
      }
      function webViewerSwitchSpreadMode(e) {
        V.pdfViewer.spreadMode = e.mode
      }
      function webViewerDocumentProperties() {
        V.pdfDocumentProperties.open()
      }
      function webViewerFindFromUrlHash(e) {
        V.eventBus.dispatch('find', {
          source: e.source,
          type: '',
          query: e.query,
          phraseSearch: e.phraseSearch,
          caseSensitive: !1,
          entireWord: !1,
          highlightAll: !0,
          findPrevious: !1,
          matchDiacritics: !0
        })
      }
      function webViewerUpdateFindMatchesCount(e) {
        const { matchesCount: t } = e
        V.supportsIntegratedFind
          ? V.externalServices.updateFindMatchesCount(t)
          : V.findBar.updateResultsCount(t)
      }
      function webViewerUpdateFindControlState(e) {
        const { state: t, previous: i, matchesCount: n, rawQuery: s } = e
        V.supportsIntegratedFind
          ? V.externalServices.updateFindControlState({
              result: t,
              findPrevious: i,
              matchesCount: n,
              rawQuery: s
            })
          : V.findBar.updateUIState(t, i, n)
      }
      function webViewerScaleChanging(e) {
        V.toolbar.setPageScale(e.presetValue, e.scale)
        V.pdfViewer.update()
      }
      function webViewerRotationChanging(e) {
        V.pdfThumbnailViewer.pagesRotation = e.pagesRotation
        V.forceRendering()
        V.pdfViewer.currentPageNumber = e.pageNumber
      }
      function webViewerPageChanging(e) {
        const { pageNumber: t, pageLabel: i } = e
        V.toolbar.setPageNumber(t, i)
        V.secondaryToolbar.setPageNumber(t)
        V.pdfSidebar.visibleView === n.SidebarView.THUMBS &&
          V.pdfThumbnailViewer.scrollThumbnailIntoView(t)
      }
      function webViewerResolutionChange(e) {
        V.pdfViewer.refresh()
      }
      function webViewerVisibilityChange(e) {
        document.visibilityState === 'visible' && setZoomDisabledTimeout()
      }
      let j = null
      function setZoomDisabledTimeout() {
        j && clearTimeout(j)
        j = setTimeout(function () {
          j = null
        }, 1e3)
      }
      function webViewerWheel(e) {
        const { pdfViewer: t, supportedMouseWheelZoomModifierKeys: i } = V
        if (!t.isInPresentationMode)
          if ((e.ctrlKey && i.ctrlKey) || (e.metaKey && i.metaKey)) {
            e.preventDefault()
            if (j || document.visibilityState === 'hidden') return
            const i = e.deltaMode
            const s = (0, n.normalizeWheelEventDirection)(e)
            const a = t.currentScale
            let r = 0
            if (i === WheelEvent.DOM_DELTA_LINE || i === WheelEvent.DOM_DELTA_PAGE)
              r = Math.abs(s) >= 1 ? Math.sign(s) : V.accumulateWheelTicks(s)
            else {
              const e = 30
              r = V.accumulateWheelTicks(s / e)
            }
            r < 0 ? V.zoomOut(-r) : r > 0 && V.zoomIn(r)
            const o = t.currentScale
            if (a !== o) {
              const i = o / a - 1
              const n = t.container.getBoundingClientRect()
              const s = e.clientX - n.left
              const r = e.clientY - n.top
              t.container.scrollLeft += s * i
              t.container.scrollTop += r * i
            }
          } else setZoomDisabledTimeout()
      }
      function webViewerTouchStart(e) {
        e.touches.length > 1 && e.preventDefault()
      }
      function webViewerClick(e) {
        if (!V.secondaryToolbar.isOpen) return
        const t = V.appConfig
        ;(V.pdfViewer.containsElement(e.target) ||
          (t.toolbar.container.contains(e.target) &&
            e.target !== t.secondaryToolbar.toggleButton)) &&
          V.secondaryToolbar.close()
      }
      function webViewerKeyDown(e) {
        if (V.overlayManager.active) return
        const { eventBus: t, pdfViewer: i } = V
        const s = i.isInPresentationMode
        let a = !1
        let r = !1
        const l =
          (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0)
        if (l === 1 || l === 8 || l === 5 || l === 12)
          switch (e.keyCode) {
            case 70:
              if (!V.supportsIntegratedFind && !e.shiftKey) {
                V.findBar.open()
                a = !0
              }
              break
            case 71:
              if (!V.supportsIntegratedFind) {
                const { state: e } = V.findController
                if (e) {
                  const i = Object.assign(Object.create(null), e, {
                    source: window,
                    type: 'again',
                    findPrevious: l === 5 || l === 12
                  })
                  t.dispatch('find', i)
                }
                a = !0
              }
              break
            case 61:
            case 107:
            case 187:
            case 171:
              s || V.zoomIn()
              a = !0
              break
            case 173:
            case 109:
            case 189:
              s || V.zoomOut()
              a = !0
              break
            case 48:
            case 96:
              if (!s) {
                setTimeout(function () {
                  V.zoomReset()
                })
                a = !1
              }
              break
            case 38:
              if (s || V.page > 1) {
                V.page = 1
                a = !0
                r = !0
              }
              break
            case 40:
              if (s || V.page < V.pagesCount) {
                V.page = V.pagesCount
                a = !0
                r = !0
              }
              break
            case 81:
              if (V.page >= 1) {
                ;(0, T.addHighlightAnnot)(e)
                a = !0
                r = !0
              }
            case 67:
              a = !0
          }
        if (l === 1 || l === 8)
          switch (e.keyCode) {
            case 83:
            case 79:
              a = !0
          }
        if (l === 3 || l === 10)
          switch (e.keyCode) {
            case 80:
              V.requestPresentationMode()
              a = !0
              break
            case 71:
              V.appConfig.toolbar.pageNumber.select()
              a = !0
          }
        if (a) {
          r && !s && i.focus()
          e.preventDefault()
          return
        }
        const c = (0, n.getActiveOrFocusedElement)()
        const d = c == null ? void 0 : c.tagName.toUpperCase()
        if (
          !(
            d === 'INPUT' ||
            d === 'TEXTAREA' ||
            d === 'SELECT' ||
            (c != null && c.isContentEditable)
          ) ||
          e.keyCode === 27
        ) {
          if (l === 0) {
            let t = 0
            let n = !1
            switch (e.keyCode) {
              case 38:
              case 33:
                i.isVerticalScrollbarEnabled && (n = !0)
                t = -1
                break
              case 8:
                s || (n = !0)
                t = -1
                break
              case 37:
                i.isHorizontalScrollbarEnabled && (n = !0)
              case 75:
              case 80:
                t = -1
                break
              case 27:
                if (V.secondaryToolbar.isOpen) {
                  V.secondaryToolbar.close()
                  a = !0
                }
                if (!V.supportsIntegratedFind && V.findBar.opened) {
                  V.findBar.close()
                  a = !0
                }
                break
              case 40:
              case 34:
                i.isVerticalScrollbarEnabled && (n = !0)
                t = 1
                break
              case 13:
              case 32:
                s || (n = !0)
                t = 1
                break
              case 39:
                i.isHorizontalScrollbarEnabled && (n = !0)
              case 74:
              case 78:
                t = 1
                break
              case 36:
                if (s || V.page > 1) {
                  V.page = 1
                  a = !0
                  r = !0
                }
                break
              case 35:
                if (s || V.page < V.pagesCount) {
                  V.page = V.pagesCount
                  a = !0
                  r = !0
                }
                break
              case 83:
                V.pdfCursorTools.switchTool(o.CursorTool.SELECT)
                break
              case 72:
                V.pdfCursorTools.switchTool(o.CursorTool.HAND)
                break
              case 82:
                V.rotatePages(90)
                break
              case 115:
                V.pdfSidebar.toggle()
            }
            if (t !== 0 && (!n || i.currentScaleValue === 'page-fit')) {
              t > 0 ? i.nextPage() : i.previousPage()
              a = !0
            }
          }
          if (l === 4)
            switch (e.keyCode) {
              case 13:
              case 32:
                if (!s && i.currentScaleValue !== 'page-fit') break
                i.previousPage()
                a = !0
                break
              case 82:
                V.rotatePages(-90)
            }
          a ||
            s ||
            (((e.keyCode >= 33 && e.keyCode <= 40) || (e.keyCode === 32 && d !== 'BUTTON')) &&
              (r = !0))
          r && !i.containsElement(c) && i.focus()
          a && e.preventDefault()
        }
      }
      function beforeUnload(e) {
        e.preventDefault()
        e.returnValue = ''
        return !1
      }
      const U = {
        instance: {
          supportsPrinting: !1,
          createPrintService() {
            throw new Error('Not implemented: createPrintService')
          }
        }
      }
      t.PDFPrintServiceFactory = U
    },
    (e) => {
      let t
      t =
        typeof window !== 'undefined' && window['pdfjs-dist/build/pdf']
          ? window['pdfjs-dist/build/pdf']
          : require('../build/pdf.js')
      e.exports = t
    },
    (e, t) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.WaitOnType = t.EventBus = t.AutomationEventBus = void 0
      t.waitOnEventOrTimeout = function waitOnEventOrTimeout(e) {
        const { target: t, name: n, delay: s = 0 } = e
        return new Promise(function (e, a) {
          if (
            typeof t !== 'object' ||
            !n ||
            typeof n !== 'string' ||
            !(Number.isInteger(s) && s >= 0)
          )
            throw new Error('waitOnEventOrTimeout - invalid parameters.')
          function handler(i) {
            t instanceof EventBus ? t._off(n, r) : t.removeEventListener(n, r)
            l && clearTimeout(l)
            e(i)
          }
          const r = handler.bind(null, i.EVENT)
          t instanceof EventBus ? t._on(n, r) : t.addEventListener(n, r)
          const o = handler.bind(null, i.TIMEOUT)
          const l = setTimeout(o, s)
        })
      }
      const i = { EVENT: 'event', TIMEOUT: 'timeout' }
      t.WaitOnType = i
      class EventBus {
        constructor() {
          this._listeners = Object.create(null)
        }

        on(e, t) {
          const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
          this._on(e, t, { external: !0, once: i == null ? void 0 : i.once })
        }

        off(e, t) {
          const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
          this._off(e, t, { external: !0, once: i == null ? void 0 : i.once })
        }

        dispatch(e, t) {
          const i = this._listeners[e]
          if (!i || i.length === 0) return
          let n
          for (const { listener: s, external: a, once: r } of i.slice(0)) {
            r && this._off(e, s)
            a ? (n || (n = [])).push(s) : s(t)
          }
          if (n) {
            for (const e of n) e(t)
            n = null
          }
        }

        _on(e, t) {
          let i
          const n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
          ;((i = this._listeners)[e] || (i[e] = [])).push({
            listener: t,
            external: !0 === (n == null ? void 0 : n.external),
            once: !0 === (n == null ? void 0 : n.once)
          })
        }

        _off(e, t) {
          const i = this._listeners[e]
          if (i)
            for (let e = 0, n = i.length; e < n; e++)
              if (i[e].listener === t) {
                i.splice(e, 1)
                return
              }
        }
      }
      t.EventBus = EventBus
      t.AutomationEventBus = class AutomationEventBus extends EventBus {
        dispatch(e, t) {
          throw new Error('Not implemented: AutomationEventBus.dispatch')
        }
      }
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.PDFCursorTools = t.CursorTool = void 0
      const n = i(8)
      const s = i(1)
      function _classPrivateMethodInitSpec(e, t) {
        !(function _checkPrivateRedeclaration(e, t) {
          if (t.has(e))
            throw new TypeError('Cannot initialize the same private elements twice on an object')
        })(e, t)
        t.add(e)
      }
      function _classPrivateMethodGet(e, t, i) {
        if (!t.has(e)) throw new TypeError('attempted to get private field on non-instance')
        return i
      }
      const a = { SELECT: 0, HAND: 1, ZOOM: 2 }
      t.CursorTool = a
      const r = new WeakSet()
      const o = new WeakSet()
      t.PDFCursorTools = class PDFCursorTools {
        constructor(e) {
          const { container: t, eventBus: i, cursorToolOnLoad: s = a.SELECT } = e
          _classPrivateMethodInitSpec(this, o)
          _classPrivateMethodInitSpec(this, r)
          this.container = t
          this.eventBus = i
          this.active = a.SELECT
          this.activeBeforePresentationMode = null
          this.handTool = new n.GrabToPan({ element: this.container })
          _classPrivateMethodGet(this, o, _addEventListeners2).call(this)
          Promise.resolve().then(() => {
            this.switchTool(s)
          })
        }

        get activeTool() {
          return this.active
        }

        switchTool(e) {
          if (this.activeBeforePresentationMode !== null) return
          if (e === this.active) return
          const disableActiveTool = () => {
            switch (this.active) {
              case a.SELECT:
                break
              case a.HAND:
                this.handTool.deactivate()
              case a.ZOOM:
            }
          }
          switch (e) {
            case a.SELECT:
              disableActiveTool()
              break
            case a.HAND:
              disableActiveTool()
              this.handTool.activate()
              break
            case a.ZOOM:
            default:
              console.error(`switchTool: "${e}" is an unsupported value.`)
              return
          }
          this.active = e
          _classPrivateMethodGet(this, r, _dispatchEvent2).call(this)
        }
      }
      function _dispatchEvent2() {
        this.eventBus.dispatch('cursortoolchanged', { source: this, tool: this.active })
      }
      function _addEventListeners2() {
        this.eventBus._on('switchcursortool', (e) => {
          this.switchTool(e.tool)
        })
        this.eventBus._on('presentationmodechanged', (e) => {
          switch (e.state) {
            case s.PresentationModeState.FULLSCREEN: {
              const e = this.active
              this.switchTool(a.SELECT)
              this.activeBeforePresentationMode = e
              break
            }
            case s.PresentationModeState.NORMAL: {
              const e = this.activeBeforePresentationMode
              this.activeBeforePresentationMode = null
              this.switchTool(e)
              break
            }
          }
        })
      }
    },
    (e, t) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.GrabToPan = void 0
      function _classPrivateMethodInitSpec(e, t) {
        !(function _checkPrivateRedeclaration(e, t) {
          if (t.has(e))
            throw new TypeError('Cannot initialize the same private elements twice on an object')
        })(e, t)
        t.add(e)
      }
      function _classPrivateMethodGet(e, t, i) {
        if (!t.has(e)) throw new TypeError('attempted to get private field on non-instance')
        return i
      }
      const i = 'grab-to-pan-grab'
      const n = new WeakSet()
      const s = new WeakSet()
      const a = new WeakSet()
      t.GrabToPan = class GrabToPan {
        constructor(e) {
          _classPrivateMethodInitSpec(this, a)
          _classPrivateMethodInitSpec(this, s)
          _classPrivateMethodInitSpec(this, n)
          this.element = e.element
          this.document = e.element.ownerDocument
          typeof e.ignoreTarget === 'function' && (this.ignoreTarget = e.ignoreTarget)
          this.onActiveChanged = e.onActiveChanged
          this.activate = this.activate.bind(this)
          this.deactivate = this.deactivate.bind(this)
          this.toggle = this.toggle.bind(this)
          this._onMouseDown = _classPrivateMethodGet(this, n, _onMouseDown2).bind(this)
          this._onMouseMove = _classPrivateMethodGet(this, s, _onMouseMove2).bind(this)
          this._endPan = _classPrivateMethodGet(this, a, _endPan2).bind(this)
          ;(this.overlay = document.createElement('div')).className = 'grab-to-pan-grabbing'
        }

        activate() {
          if (!this.active) {
            let e
            this.active = !0
            this.element.addEventListener('mousedown', this._onMouseDown, !0)
            this.element.classList.add(i)((e = this.onActiveChanged)) === null ||
              void 0 === e ||
              e.call(this, !0)
          }
        }

        deactivate() {
          if (this.active) {
            let e
            this.active = !1
            this.element.removeEventListener('mousedown', this._onMouseDown, !0)
            this._endPan()
            this.element.classList.remove(i)((e = this.onActiveChanged)) === null ||
              void 0 === e ||
              e.call(this, !1)
          }
        }

        toggle() {
          this.active ? this.deactivate() : this.activate()
        }

        ignoreTarget(e) {
          return e.matches('a[href], a[href] *, input, textarea, button, button *, select, option')
        }
      }
      function _onMouseDown2(e) {
        if (e.button !== 0 || this.ignoreTarget(e.target)) return
        if (e.originalTarget)
          try {
            e.originalTarget.tagName
          } catch (e) {
            return
          }
        this.scrollLeftStart = this.element.scrollLeft
        this.scrollTopStart = this.element.scrollTop
        this.clientXStart = e.clientX
        this.clientYStart = e.clientY
        this.document.addEventListener('mousemove', this._onMouseMove, !0)
        this.document.addEventListener('mouseup', this._endPan, !0)
        this.element.addEventListener('scroll', this._endPan, !0)
        e.preventDefault()
        e.stopPropagation()
        const t = document.activeElement
        t && !t.contains(e.target) && t.blur()
      }
      function _onMouseMove2(e) {
        this.element.removeEventListener('scroll', this._endPan, !0)
        if (!(1 & e.buttons)) {
          this._endPan()
          return
        }
        const t = e.clientX - this.clientXStart
        const i = e.clientY - this.clientYStart
        const n = this.scrollTopStart - i
        const s = this.scrollLeftStart - t
        if (this.element.scrollTo) this.element.scrollTo({ top: n, left: s, behavior: 'instant' })
        else {
          this.element.scrollTop = n
          this.element.scrollLeft = s
        }
        this.overlay.parentNode || document.body.append(this.overlay)
      }
      function _endPan2() {
        this.element.removeEventListener('scroll', this._endPan, !0)
        this.document.removeEventListener('mousemove', this._onMouseMove, !0)
        this.document.removeEventListener('mouseup', this._endPan, !0)
        this.overlay.remove()
      }
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.AnnotationEditorParams = void 0
      const n = i(5)
      function _classPrivateMethodInitSpec(e, t) {
        !(function _checkPrivateRedeclaration(e, t) {
          if (t.has(e))
            throw new TypeError('Cannot initialize the same private elements twice on an object')
        })(e, t)
        t.add(e)
      }
      const s = new WeakSet()
      t.AnnotationEditorParams = class AnnotationEditorParams {
        constructor(e, t) {
          _classPrivateMethodInitSpec(this, s)
          this.eventBus = t
          ;(function _classPrivateMethodGet(e, t, i) {
            if (!t.has(e)) throw new TypeError('attempted to get private field on non-instance')
            return i
          })(this, s, _bindListeners2).call(this, e)
        }
      }
      function _bindListeners2(e) {
        const {
          editorFreeTextFontSize: t,
          editorFreeTextColor: i,
          editorInkColor: s,
          editorInkThickness: a,
          editorInkOpacity: r
        } = e
        t.addEventListener('input', (e) => {
          this.eventBus.dispatch('switchannotationeditorparams', {
            source: this,
            type: n.AnnotationEditorParamsType.FREETEXT_SIZE,
            value: t.valueAsNumber
          })
        })
        i.addEventListener('input', (e) => {
          this.eventBus.dispatch('switchannotationeditorparams', {
            source: this,
            type: n.AnnotationEditorParamsType.FREETEXT_COLOR,
            value: i.value
          })
        })
        s.addEventListener('input', (e) => {
          this.eventBus.dispatch('switchannotationeditorparams', {
            source: this,
            type: n.AnnotationEditorParamsType.INK_COLOR,
            value: s.value
          })
        })
        a.addEventListener('input', (e) => {
          this.eventBus.dispatch('switchannotationeditorparams', {
            source: this,
            type: n.AnnotationEditorParamsType.INK_THICKNESS,
            value: a.valueAsNumber
          })
        })
        r.addEventListener('input', (e) => {
          this.eventBus.dispatch('switchannotationeditorparams', {
            source: this,
            type: n.AnnotationEditorParamsType.INK_OPACITY,
            value: r.valueAsNumber
          })
        })
        this.eventBus._on('annotationeditorparamschanged', (e) => {
          for (const [o, l] of e.details)
            switch (o) {
              case n.AnnotationEditorParamsType.FREETEXT_SIZE:
                t.value = l
                break
              case n.AnnotationEditorParamsType.FREETEXT_COLOR:
                i.value = l
                break
              case n.AnnotationEditorParamsType.INK_COLOR:
                s.value = l
                break
              case n.AnnotationEditorParamsType.INK_THICKNESS:
                a.value = l
                break
              case n.AnnotationEditorParamsType.INK_OPACITY:
                r.value = l
            }
        })
      }
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.OverlayManager = void 0
      function _classPrivateFieldInitSpec(e, t, i) {
        !(function _checkPrivateRedeclaration(e, t) {
          if (t.has(e))
            throw new TypeError('Cannot initialize the same private elements twice on an object')
        })(e, t)
        t.set(e, i)
      }
      function _classPrivateFieldSet(e, t, i) {
        !(function _classApplyDescriptorSet(e, t, i) {
          if (t.set) t.set.call(e, i)
          else {
            if (!t.writable) throw new TypeError('attempted to set read only private field')
            t.value = i
          }
        })(e, _classExtractFieldDescriptor(e, t, 'set'), i)
        return i
      }
      function _classPrivateFieldGet(e, t) {
        return (function _classApplyDescriptorGet(e, t) {
          if (t.get) return t.get.call(e)
          return t.value
        })(e, _classExtractFieldDescriptor(e, t, 'get'))
      }
      function _classExtractFieldDescriptor(e, t, i) {
        if (!t.has(e)) throw new TypeError(`attempted to ${i} private field on non-instance`)
        return t.get(e)
      }
      const n = new WeakMap()
      const s = new WeakMap()
      t.OverlayManager = class OverlayManager {
        constructor() {
          _classPrivateFieldInitSpec(this, n, { writable: !0, value: new WeakMap() })
          _classPrivateFieldInitSpec(this, s, { writable: !0, value: null })
        }

        get active() {
          return _classPrivateFieldGet(this, s)
        }

        async register(e) {
          const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
          if (typeof e !== 'object') throw new Error('Not enough parameters.')
          if (_classPrivateFieldGet(this, n).has(e))
            throw new Error('The overlay is already registered.')
          _classPrivateFieldGet(this, n).set(e, { canForceClose: t })
          if (!e.showModal) {
            i(11).registerDialog(e)
            if (!this._dialogPolyfillCSS) {
              this._dialogPolyfillCSS = !0
              const e = document.createElement('style')
              e.textContent =
                'dialog {\n  position: absolute;\n  left: 0; right: 0;\n  width: -moz-fit-content;\n  width: -webkit-fit-content;\n  width: fit-content;\n  height: -moz-fit-content;\n  height: -webkit-fit-content;\n  height: fit-content;\n  margin: auto;\n  border: solid;\n  padding: 1em;\n  background: white;\n  color: black;\n  display: block;\n}\n\ndialog:not([open]) {\n  display: none;\n}\n\ndialog + .backdrop {\n  position: fixed;\n  top: 0; right: 0; bottom: 0; left: 0;\n  background: rgba(0,0,0,0.1);\n}\n\n._dialog_overlay {\n  position: fixed;\n  top: 0; right: 0; bottom: 0; left: 0;\n}\n\ndialog.fixed {\n  position: fixed;\n  top: 50%;\n  transform: translate(0, -50%);\n}'
              document.head.prepend(e)
            }
          }
          e.addEventListener('cancel', (e) => {
            _classPrivateFieldSet(this, s, null)
          })
        }

        async unregister(e) {
          if (!_classPrivateFieldGet(this, n).has(e)) throw new Error('The overlay does not exist.')
          if (_classPrivateFieldGet(this, s) === e)
            throw new Error('The overlay cannot be removed while it is active.')
          _classPrivateFieldGet(this, n).delete(e)
        }

        async open(e) {
          if (!_classPrivateFieldGet(this, n).has(e)) throw new Error('The overlay does not exist.')
          if (_classPrivateFieldGet(this, s)) {
            if (_classPrivateFieldGet(this, s) === e)
              throw new Error('The overlay is already active.')
            if (!_classPrivateFieldGet(this, n).get(e).canForceClose)
              throw new Error('Another overlay is currently active.')
            await this.close()
          }
          _classPrivateFieldSet(this, s, e)
          e.showModal()
        }

        async close() {
          const e =
            arguments.length > 0 && void 0 !== arguments[0]
              ? arguments[0]
              : _classPrivateFieldGet(this, s)
          if (!_classPrivateFieldGet(this, n).has(e)) throw new Error('The overlay does not exist.')
          if (!_classPrivateFieldGet(this, s))
            throw new Error('The overlay is currently not active.')
          if (_classPrivateFieldGet(this, s) !== e)
            throw new Error('Another overlay is currently active.')
          e.close()
          _classPrivateFieldSet(this, s, null)
        }
      }
    },
    (e) => {
      e.exports = (function () {
        let e = window.CustomEvent
        ;(e && typeof e !== 'object') ||
          ((e = function CustomEvent(e, t) {
            t = t || {}
            const i = document.createEvent('CustomEvent')
            i.initCustomEvent(e, !!t.bubbles, !!t.cancelable, t.detail || null)
            return i
          }).prototype = window.Event.prototype)
        function safeDispatchEvent(e, t) {
          const i = `on${t.type.toLowerCase()}`
          typeof e[i] === 'function' && e[i](t)
          return e.dispatchEvent(t)
        }
        function createsStackingContext(e) {
          for (; e && e !== document.body; ) {
            var t = window.getComputedStyle(e)
            const invalid = function (e, i) {
              return !(void 0 === t[e] || t[e] === i)
            }
            if (
              t.opacity < 1 ||
              invalid('zIndex', 'auto') ||
              invalid('transform', 'none') ||
              invalid('mixBlendMode', 'normal') ||
              invalid('filter', 'none') ||
              invalid('perspective', 'none') ||
              t.isolation === 'isolate' ||
              t.position === 'fixed' ||
              t.webkitOverflowScrolling === 'touch'
            )
              return !0
            e = e.parentElement
          }
          return !1
        }
        function findNearestDialog(e) {
          for (; e; ) {
            if (e.localName === 'dialog') return e
            e = e.parentElement ? e.parentElement : e.parentNode ? e.parentNode.host : null
          }
          return null
        }
        function safeBlur(e) {
          for (; e && e.shadowRoot && e.shadowRoot.activeElement; ) e = e.shadowRoot.activeElement
          e && e.blur && e !== document.body && e.blur()
        }
        function inNodeList(e, t) {
          for (let i = 0; i < e.length; ++i) if (e[i] === t) return !0
          return !1
        }
        function isFormMethodDialog(e) {
          return (
            !(!e || !e.hasAttribute('method')) &&
            e.getAttribute('method').toLowerCase() === 'dialog'
          )
        }
        function findFocusableElementWithin(e) {
          const t = ['button', 'input', 'keygen', 'select', 'textarea'].map(function (e) {
            return `${e}:not([disabled])`
          })
          t.push('[tabindex]:not([disabled]):not([tabindex=""])')
          let i = e.querySelector(t.join(', '))
          if (!i && 'attachShadow' in Element.prototype)
            for (
              let n = e.querySelectorAll('*'), s = 0;
              s < n.length &&
              !(
                n[s].tagName &&
                n[s].shadowRoot &&
                (i = findFocusableElementWithin(n[s].shadowRoot))
              );
              s++
            );
          return i
        }
        function isConnected(e) {
          return e.isConnected || document.body.contains(e)
        }
        function findFormSubmitter(e) {
          if (e.submitter) return e.submitter
          const i = e.target
          if (!(i instanceof HTMLFormElement)) return null
          let n = t.formSubmitter
          if (!n) {
            const s = e.target
            n = (('getRootNode' in s && s.getRootNode()) || document).activeElement
          }
          return n && n.form === i ? n : null
        }
        function maybeHandleSubmit(e) {
          if (!e.defaultPrevented) {
            const i = e.target
            let n = t.imagemapUseValue
            const s = findFormSubmitter(e)
            n === null && s && (n = s.value)
            const a = findNearestDialog(i)
            if (
              a &&
              ((s && s.getAttribute('formmethod')) || i.getAttribute('method')) === 'dialog'
            ) {
              e.preventDefault()
              n != null ? a.close(n) : a.close()
            }
          }
        }
        function dialogPolyfillInfo(e) {
          this.dialog_ = e
          this.replacedStyleTop_ = !1
          this.openAsModal_ = !1
          e.hasAttribute('role') || e.setAttribute('role', 'dialog')
          e.show = this.show.bind(this)
          e.showModal = this.showModal.bind(this)
          e.close = this.close.bind(this)
          e.addEventListener('submit', maybeHandleSubmit, !1)
          'returnValue' in e || (e.returnValue = '')
          if ('MutationObserver' in window)
            new MutationObserver(this.maybeHideModal.bind(this)).observe(e, {
              attributes: !0,
              attributeFilter: ['open']
            })
          else {
            let t
            let i = !1
            const n = function () {
              i ? this.downgradeModal() : this.maybeHideModal()
              i = !1
            }.bind(this)
            const delayModel = function (s) {
              if (s.target === e) {
                const a = 'DOMNodeRemoved'
                i |= s.type.substr(0, a.length) === a
                window.clearTimeout(t)
                t = window.setTimeout(n, 0)
              }
            }
            ;['DOMAttrModified', 'DOMNodeRemoved', 'DOMNodeRemovedFromDocument'].forEach(function (
              t
            ) {
              e.addEventListener(t, delayModel)
            })
          }
          Object.defineProperty(e, 'open', {
            set: this.setOpen.bind(this),
            get: e.hasAttribute.bind(e, 'open')
          })
          this.backdrop_ = document.createElement('div')
          this.backdrop_.className = 'backdrop'
          this.backdrop_.addEventListener('mouseup', this.backdropMouseEvent_.bind(this))
          this.backdrop_.addEventListener('mousedown', this.backdropMouseEvent_.bind(this))
          this.backdrop_.addEventListener('click', this.backdropMouseEvent_.bind(this))
        }
        dialogPolyfillInfo.prototype = {
          get dialog() {
            return this.dialog_
          },
          maybeHideModal() {
            ;(this.dialog_.hasAttribute('open') && isConnected(this.dialog_)) ||
              this.downgradeModal()
          },
          downgradeModal() {
            if (this.openAsModal_) {
              this.openAsModal_ = !1
              this.dialog_.style.zIndex = ''
              if (this.replacedStyleTop_) {
                this.dialog_.style.top = ''
                this.replacedStyleTop_ = !1
              }
              this.backdrop_.parentNode && this.backdrop_.parentNode.removeChild(this.backdrop_)
              t.dm.removeDialog(this)
            }
          },
          setOpen(e) {
            if (e) this.dialog_.hasAttribute('open') || this.dialog_.setAttribute('open', '')
            else {
              this.dialog_.removeAttribute('open')
              this.maybeHideModal()
            }
          },
          backdropMouseEvent_(e) {
            if (this.dialog_.hasAttribute('tabindex')) this.dialog_.focus()
            else {
              const t = document.createElement('div')
              this.dialog_.insertBefore(t, this.dialog_.firstChild)
              t.tabIndex = -1
              t.focus()
              this.dialog_.removeChild(t)
            }
            const i = document.createEvent('MouseEvents')
            i.initMouseEvent(
              e.type,
              e.bubbles,
              e.cancelable,
              window,
              e.detail,
              e.screenX,
              e.screenY,
              e.clientX,
              e.clientY,
              e.ctrlKey,
              e.altKey,
              e.shiftKey,
              e.metaKey,
              e.button,
              e.relatedTarget
            )
            this.dialog_.dispatchEvent(i)
            e.stopPropagation()
          },
          focus_() {
            let e = this.dialog_.querySelector('[autofocus]:not([disabled])')
            !e && this.dialog_.tabIndex >= 0 && (e = this.dialog_)
            e || (e = findFocusableElementWithin(this.dialog_))
            safeBlur(document.activeElement)
            e && e.focus()
          },
          updateZIndex(e, t) {
            if (e < t) throw new Error('dialogZ should never be < backdropZ')
            this.dialog_.style.zIndex = e
            this.backdrop_.style.zIndex = t
          },
          show() {
            if (!this.dialog_.open) {
              this.setOpen(!0)
              this.focus_()
            }
          },
          showModal() {
            if (this.dialog_.hasAttribute('open'))
              throw new Error(
                "Failed to execute 'showModal' on dialog: The element is already open, and therefore cannot be opened modally."
              )
            if (!isConnected(this.dialog_))
              throw new Error(
                "Failed to execute 'showModal' on dialog: The element is not in a Document."
              )
            if (!t.dm.pushDialog(this))
              throw new Error(
                "Failed to execute 'showModal' on dialog: There are too many open modal dialogs."
              )
            createsStackingContext(this.dialog_.parentElement) &&
              console.warn(
                'A dialog is being shown inside a stacking context. This may cause it to be unusable. For more information, see this link: https://github.com/GoogleChrome/dialog-polyfill/#stacking-context'
              )
            this.setOpen(!0)
            this.openAsModal_ = !0
            if (t.needsCentering(this.dialog_)) {
              t.reposition(this.dialog_)
              this.replacedStyleTop_ = !0
            } else this.replacedStyleTop_ = !1
            this.dialog_.parentNode.insertBefore(this.backdrop_, this.dialog_.nextSibling)
            this.focus_()
          },
          close(t) {
            if (!this.dialog_.hasAttribute('open'))
              throw new Error(
                "Failed to execute 'close' on dialog: The element does not have an 'open' attribute, and therefore cannot be closed."
              )
            this.setOpen(!1)
            void 0 !== t && (this.dialog_.returnValue = t)
            const i = new e('close', { bubbles: !1, cancelable: !1 })
            safeDispatchEvent(this.dialog_, i)
          }
        }
        var t = {
          reposition(e) {
            const t = document.body.scrollTop || document.documentElement.scrollTop
            const i = t + (window.innerHeight - e.offsetHeight) / 2
            e.style.top = `${Math.max(t, i)}px`
          },
          isInlinePositionSetByStylesheet(e) {
            for (let t = 0; t < document.styleSheets.length; ++t) {
              const i = document.styleSheets[t]
              let n = null
              try {
                n = i.cssRules
              } catch (e) {}
              if (n)
                for (let s = 0; s < n.length; ++s) {
                  const a = n[s]
                  let r = null
                  try {
                    r = document.querySelectorAll(a.selectorText)
                  } catch (e) {}
                  if (r && inNodeList(r, e)) {
                    const o = a.style.getPropertyValue('top')
                    const l = a.style.getPropertyValue('bottom')
                    if ((o && o !== 'auto') || (l && l !== 'auto')) return !0
                  }
                }
            }
            return !1
          },
          needsCentering(e) {
            return !(
              window.getComputedStyle(e).position !== 'absolute' ||
              (e.style.top !== 'auto' && e.style.top !== '') ||
              (e.style.bottom !== 'auto' && e.style.bottom !== '') ||
              t.isInlinePositionSetByStylesheet(e)
            )
          },
          forceRegisterDialog(e) {
            ;(window.HTMLDialogElement || e.showModal) &&
              console.warn(
                'This browser already supports <dialog>, the polyfill may not work correctly',
                e
              )
            if (e.localName !== 'dialog')
              throw new Error('Failed to register dialog: The element is not a dialog.')
            new dialogPolyfillInfo(e)
          },
          registerDialog(e) {
            e.showModal || t.forceRegisterDialog(e)
          },
          DialogManager() {
            this.pendingDialogStack = []
            const e = this.checkDOM_.bind(this)
            this.overlay = document.createElement('div')
            this.overlay.className = '_dialog_overlay'
            this.overlay.addEventListener(
              'click',
              function (t) {
                this.forwardTab_ = void 0
                t.stopPropagation()
                e([])
              }.bind(this)
            )
            this.handleKey_ = this.handleKey_.bind(this)
            this.handleFocus_ = this.handleFocus_.bind(this)
            this.zIndexLow_ = 1e5
            this.zIndexHigh_ = 100150
            this.forwardTab_ = void 0
            'MutationObserver' in window &&
              (this.mo_ = new MutationObserver(function (t) {
                let i = []
                t.forEach(function (e) {
                  for (var t, n = 0; (t = e.removedNodes[n]); ++n)
                    if (t instanceof Element) {
                      t.localName === 'dialog' && i.push(t)
                      i = i.concat(t.querySelectorAll('dialog'))
                    }
                })
                i.length && e(i)
              }))
          }
        }
        t.DialogManager.prototype.blockDocument = function () {
          document.documentElement.addEventListener('focus', this.handleFocus_, !0)
          document.addEventListener('keydown', this.handleKey_)
          this.mo_ && this.mo_.observe(document, { childList: !0, subtree: !0 })
        }
        t.DialogManager.prototype.unblockDocument = function () {
          document.documentElement.removeEventListener('focus', this.handleFocus_, !0)
          document.removeEventListener('keydown', this.handleKey_)
          this.mo_ && this.mo_.disconnect()
        }
        t.DialogManager.prototype.updateStacking = function () {
          for (var e, t = this.zIndexHigh_, i = 0; (e = this.pendingDialogStack[i]); ++i) {
            e.updateZIndex(--t, --t)
            i === 0 && (this.overlay.style.zIndex = --t)
          }
          const n = this.pendingDialogStack[0]
          n
            ? (n.dialog.parentNode || document.body).appendChild(this.overlay)
            : this.overlay.parentNode && this.overlay.parentNode.removeChild(this.overlay)
        }
        t.DialogManager.prototype.containedByTopDialog_ = function (e) {
          for (; (e = findNearestDialog(e)); ) {
            for (var t, i = 0; (t = this.pendingDialogStack[i]); ++i)
              if (t.dialog === e) return i === 0
            e = e.parentElement
          }
          return !1
        }
        t.DialogManager.prototype.handleFocus_ = function (e) {
          const t = e.composedPath ? e.composedPath()[0] : e.target
          if (
            !this.containedByTopDialog_(t) &&
            document.activeElement !== document.documentElement
          ) {
            e.preventDefault()
            e.stopPropagation()
            safeBlur(t)
            if (void 0 !== this.forwardTab_) {
              const i = this.pendingDialogStack[0]
              i.dialog.compareDocumentPosition(t) & Node.DOCUMENT_POSITION_PRECEDING &&
                (this.forwardTab_
                  ? i.focus_()
                  : t !== document.documentElement && document.documentElement.focus())
              return !1
            }
          }
        }
        t.DialogManager.prototype.handleKey_ = function (t) {
          this.forwardTab_ = void 0
          if (t.keyCode === 27) {
            t.preventDefault()
            t.stopPropagation()
            const i = new e('cancel', { bubbles: !1, cancelable: !0 })
            const n = this.pendingDialogStack[0]
            n && safeDispatchEvent(n.dialog, i) && n.dialog.close()
          } else t.keyCode === 9 && (this.forwardTab_ = !t.shiftKey)
        }
        t.DialogManager.prototype.checkDOM_ = function (e) {
          this.pendingDialogStack.slice().forEach(function (t) {
            e.indexOf(t.dialog) !== -1 ? t.downgradeModal() : t.maybeHideModal()
          })
        }
        t.DialogManager.prototype.pushDialog = function (e) {
          const t = (this.zIndexHigh_ - this.zIndexLow_) / 2 - 1
          if (this.pendingDialogStack.length >= t) return !1
          this.pendingDialogStack.unshift(e) === 1 && this.blockDocument()
          this.updateStacking()
          return !0
        }
        t.DialogManager.prototype.removeDialog = function (e) {
          const t = this.pendingDialogStack.indexOf(e)
          if (t !== -1) {
            this.pendingDialogStack.splice(t, 1)
            this.pendingDialogStack.length === 0 && this.unblockDocument()
            this.updateStacking()
          }
        }
        t.dm = new t.DialogManager()
        t.formSubmitter = null
        t.imagemapUseValue = null
        if (void 0 === window.HTMLDialogElement) {
          const i = document.createElement('form')
          i.setAttribute('method', 'dialog')
          if (i.method !== 'dialog') {
            const n = Object.getOwnPropertyDescriptor(HTMLFormElement.prototype, 'method')
            if (n) {
              const s = n.get
              n.get = function () {
                return isFormMethodDialog(this) ? 'dialog' : s.call(this)
              }
              const a = n.set
              n.set = function (e) {
                return typeof e === 'string' && e.toLowerCase() === 'dialog'
                  ? this.setAttribute('method', e)
                  : a.call(this, e)
              }
              Object.defineProperty(HTMLFormElement.prototype, 'method', n)
            }
          }
          document.addEventListener(
            'click',
            function (e) {
              t.formSubmitter = null
              t.imagemapUseValue = null
              if (!e.defaultPrevented) {
                let i = e.target
                'composedPath' in e && (i = e.composedPath().shift() || i)
                if (i && isFormMethodDialog(i.form)) {
                  if (!(i.type === 'submit' && ['button', 'input'].indexOf(i.localName) > -1)) {
                    if (i.localName !== 'input' || i.type !== 'image') return
                    t.imagemapUseValue = `${e.offsetX},${e.offsetY}`
                  }
                  findNearestDialog(i) && (t.formSubmitter = i)
                }
              }
            },
            !1
          )
          document.addEventListener('submit', function (e) {
            const t = e.target
            if (!findNearestDialog(t)) {
              const i =
                findFormSubmitter(e)(
                  (i && i.getAttribute('formmethod')) || t.getAttribute('method')
                ) === 'dialog' && e.preventDefault()
            }
          })
          const r = HTMLFormElement.prototype.submit
          const replacementFormSubmit = function () {
            if (!isFormMethodDialog(this)) return r.call(this)
            const e = findNearestDialog(this)
            e && e.close()
          }
          HTMLFormElement.prototype.submit = replacementFormSubmit
        }
        return t
      })()
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.PasswordPrompt = void 0
      const n = i(5)
      function _classPrivateMethodInitSpec(e, t) {
        _checkPrivateRedeclaration(e, t)
        t.add(e)
      }
      function _classPrivateFieldInitSpec(e, t, i) {
        _checkPrivateRedeclaration(e, t)
        t.set(e, i)
      }
      function _checkPrivateRedeclaration(e, t) {
        if (t.has(e))
          throw new TypeError('Cannot initialize the same private elements twice on an object')
      }
      function _classPrivateFieldSet(e, t, i) {
        !(function _classApplyDescriptorSet(e, t, i) {
          if (t.set) t.set.call(e, i)
          else {
            if (!t.writable) throw new TypeError('attempted to set read only private field')
            t.value = i
          }
        })(e, _classExtractFieldDescriptor(e, t, 'set'), i)
        return i
      }
      function _classPrivateFieldGet(e, t) {
        return (function _classApplyDescriptorGet(e, t) {
          if (t.get) return t.get.call(e)
          return t.value
        })(e, _classExtractFieldDescriptor(e, t, 'get'))
      }
      function _classExtractFieldDescriptor(e, t, i) {
        if (!t.has(e)) throw new TypeError(`attempted to ${i} private field on non-instance`)
        return t.get(e)
      }
      function _classPrivateMethodGet(e, t, i) {
        if (!t.has(e)) throw new TypeError('attempted to get private field on non-instance')
        return i
      }
      const s = new WeakMap()
      const a = new WeakMap()
      const r = new WeakMap()
      const o = new WeakSet()
      const l = new WeakSet()
      const c = new WeakSet()
      t.PasswordPrompt = class PasswordPrompt {
        constructor(e, t, i) {
          const n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]
          _classPrivateMethodInitSpec(this, c)
          _classPrivateMethodInitSpec(this, l)
          _classPrivateMethodInitSpec(this, o)
          _classPrivateFieldInitSpec(this, s, { writable: !0, value: null })
          _classPrivateFieldInitSpec(this, a, { writable: !0, value: null })
          _classPrivateFieldInitSpec(this, r, { writable: !0, value: null })
          this.dialog = e.dialog
          this.label = e.label
          this.input = e.input
          this.submitButton = e.submitButton
          this.cancelButton = e.cancelButton
          this.overlayManager = t
          this.l10n = i
          this._isViewerEmbedded = n
          this.submitButton.addEventListener(
            'click',
            _classPrivateMethodGet(this, o, _verify2).bind(this)
          )
          this.cancelButton.addEventListener('click', this.close.bind(this))
          this.input.addEventListener('keydown', (e) => {
            e.keyCode === 13 && _classPrivateMethodGet(this, o, _verify2).call(this)
          })
          this.overlayManager.register(this.dialog, !0)
          this.dialog.addEventListener(
            'close',
            _classPrivateMethodGet(this, l, _cancel2).bind(this)
          )
        }

        async open() {
          _classPrivateFieldGet(this, s) && (await _classPrivateFieldGet(this, s).promise)
          _classPrivateFieldSet(this, s, (0, n.createPromiseCapability)())
          try {
            await this.overlayManager.open(this.dialog)
          } catch (e) {
            _classPrivateFieldSet(this, s, null)
            throw e
          }
          const e = _classPrivateFieldGet(this, r) === n.PasswordResponses.INCORRECT_PASSWORD
          ;(this._isViewerEmbedded && !e) || this.input.focus()
          this.label.textContent = await this.l10n.get(`password_${e ? 'invalid' : 'label'}`)
        }

        async close() {
          this.overlayManager.active === this.dialog && this.overlayManager.close(this.dialog)
        }

        async setUpdateCallback(e, t) {
          _classPrivateFieldGet(this, s) && (await _classPrivateFieldGet(this, s).promise)
          _classPrivateFieldSet(this, a, e)
          _classPrivateFieldSet(this, r, t)
        }
      }
      function _verify2() {
        const e = this.input.value
        ;(e == null ? void 0 : e.length) > 0 &&
          _classPrivateMethodGet(this, c, _invokeCallback2).call(this, e)
      }
      function _cancel2() {
        _classPrivateMethodGet(this, c, _invokeCallback2).call(
          this,
          new Error('PasswordPrompt cancelled.')
        )
        _classPrivateFieldGet(this, s).resolve()
      }
      function _invokeCallback2(e) {
        if (_classPrivateFieldGet(this, a)) {
          this.close()
          this.input.value = ''
          _classPrivateFieldGet(this, a).call(this, e)
          _classPrivateFieldSet(this, a, null)
        }
      }
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.PDFAttachmentViewer = void 0
      const n = i(5)
      const s = i(14)
      const a = i(6)
      function _classPrivateMethodInitSpec(e, t) {
        !(function _checkPrivateRedeclaration(e, t) {
          if (t.has(e))
            throw new TypeError('Cannot initialize the same private elements twice on an object')
        })(e, t)
        t.add(e)
      }
      const r = new WeakSet()
      class PDFAttachmentViewer extends s.BaseTreeViewer {
        constructor(e) {
          super(e)
          _classPrivateMethodInitSpec(this, r)
          this.downloadManager = e.downloadManager
          this.eventBus._on(
            'fileattachmentannotation',
            (function _classPrivateMethodGet(e, t, i) {
              if (!t.has(e)) throw new TypeError('attempted to get private field on non-instance')
              return i
            })(this, r, _appendAttachment2).bind(this)
          )
        }

        reset() {
          const e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
          super.reset()
          this._attachments = null
          e || (this._renderedCapability = (0, n.createPromiseCapability)())
          this._pendingDispatchEvent = !1
        }

        async _dispatchEvent(e) {
          this._renderedCapability.resolve()
          if (e === 0 && !this._pendingDispatchEvent) {
            this._pendingDispatchEvent = !0
            await (0, a.waitOnEventOrTimeout)({
              target: this.eventBus,
              name: 'annotationlayerrendered',
              delay: 1e3
            })
            if (!this._pendingDispatchEvent) return
          }
          this._pendingDispatchEvent = !1
          this.eventBus.dispatch('attachmentsloaded', { source: this, attachmentsCount: e })
        }

        _bindLink(e, t) {
          const { content: i, filename: n } = t
          e.onclick = () => {
            this.downloadManager.openOrDownloadData(e, i, n)
            return !1
          }
        }

        render(e) {
          const { attachments: t, keepRenderedCapability: i = !1 } = e
          this._attachments && this.reset(i)
          this._attachments = t || null
          if (!t) {
            this._dispatchEvent(0)
            return
          }
          const s = Object.keys(t).sort(function (e, t) {
            return e.toLowerCase().localeCompare(t.toLowerCase())
          })
          const a = document.createDocumentFragment()
          let r = 0
          for (const e of s) {
            const i = t[e]
            const s = i.content
            const o = (0, n.getFilenameFromUrl)(i.filename)
            const l = document.createElement('div')
            l.className = 'treeItem'
            const c = document.createElement('a')
            this._bindLink(c, { content: s, filename: o })
            c.textContent = this._normalizeTextContent(o)
            l.append(c)
            a.append(l)
            r++
          }
          this._finishRendering(a, r)
        }
      }
      t.PDFAttachmentViewer = PDFAttachmentViewer
      function _appendAttachment2(e) {
        const { filename: t, content: i } = e
        const n = this._renderedCapability.promise
        n.then(() => {
          if (n !== this._renderedCapability.promise) return
          const e = this._attachments || Object.create(null)
          for (const i in e) if (t === i) return
          e[t] = { filename: t, content: i }
          this.render({ attachments: e, keepRenderedCapability: !0 })
        })
      }
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.BaseTreeViewer = void 0
      const n = i(1)
      const s = 'selected'
      class BaseTreeViewer {
        constructor(e) {
          if (this.constructor === BaseTreeViewer)
            throw new Error('Cannot initialize BaseTreeViewer.')
          this.container = e.container
          this.eventBus = e.eventBus
          this.reset()
        }

        reset() {
          this._pdfDocument = null
          this._lastToggleIsShow = !0
          this._currentTreeItem = null
          this.container.textContent = ''
          this.container.classList.remove('treeWithDeepNesting')
        }

        _dispatchEvent(e) {
          throw new Error('Not implemented: _dispatchEvent')
        }

        _bindLink(e, t) {
          throw new Error('Not implemented: _bindLink')
        }

        _normalizeTextContent(e) {
          return (0, n.removeNullCharacters)(e, !0) || '–'
        }

        _addToggleButton(e) {
          const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
          const i = document.createElement('div')
          i.className = 'treeItemToggler'
          t && i.classList.add('treeItemsHidden')
          i.onclick = (t) => {
            t.stopPropagation()
            i.classList.toggle('treeItemsHidden')
            if (t.shiftKey) {
              const t = !i.classList.contains('treeItemsHidden')
              this._toggleTreeItem(e, t)
            }
          }
          e.prepend(i)
        }

        _toggleTreeItem(e) {
          const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
          this._lastToggleIsShow = t
          for (const i of e.querySelectorAll('.treeItemToggler'))
            i.classList.toggle('treeItemsHidden', !t)
        }

        _toggleAllTreeItems() {
          this._toggleTreeItem(this.container, !this._lastToggleIsShow)
        }

        _finishRendering(e, t) {
          if (arguments.length > 2 && void 0 !== arguments[2] && arguments[2]) {
            this.container.classList.add('treeWithDeepNesting')
            this._lastToggleIsShow = !e.querySelector('.treeItemsHidden')
          }
          this.container.append(e)
          this._dispatchEvent(t)
        }

        render(e) {
          throw new Error('Not implemented: render')
        }

        _updateCurrentTreeItem() {
          const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
          if (this._currentTreeItem) {
            this._currentTreeItem.classList.remove(s)
            this._currentTreeItem = null
          }
          if (e) {
            e.classList.add(s)
            this._currentTreeItem = e
          }
        }

        _scrollToCurrentTreeItem(e) {
          if (!e) return
          let t = e.parentNode
          for (; t && t !== this.container; ) {
            if (t.classList.contains('treeItem')) {
              const e = t.firstElementChild
              e == null || e.classList.remove('treeItemsHidden')
            }
            t = t.parentNode
          }
          this._updateCurrentTreeItem(e)
          this.container.scrollTo(e.offsetLeft, e.offsetTop + -100)
        }
      }
      t.BaseTreeViewer = BaseTreeViewer
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.PDFDocumentProperties = void 0
      const n = i(5)
      const s = i(1)
      function _classPrivateMethodInitSpec(e, t) {
        _checkPrivateRedeclaration(e, t)
        t.add(e)
      }
      function _checkPrivateRedeclaration(e, t) {
        if (t.has(e))
          throw new TypeError('Cannot initialize the same private elements twice on an object')
      }
      function _classPrivateFieldSet(e, t, i) {
        !(function _classApplyDescriptorSet(e, t, i) {
          if (t.set) t.set.call(e, i)
          else {
            if (!t.writable) throw new TypeError('attempted to set read only private field')
            t.value = i
          }
        })(e, _classExtractFieldDescriptor(e, t, 'set'), i)
        return i
      }
      function _classPrivateFieldGet(e, t) {
        return (function _classApplyDescriptorGet(e, t) {
          if (t.get) return t.get.call(e)
          return t.value
        })(e, _classExtractFieldDescriptor(e, t, 'get'))
      }
      function _classExtractFieldDescriptor(e, t, i) {
        if (!t.has(e)) throw new TypeError(`attempted to ${i} private field on non-instance`)
        return t.get(e)
      }
      function _classPrivateMethodGet(e, t, i) {
        if (!t.has(e)) throw new TypeError('attempted to get private field on non-instance')
        return i
      }
      const a = '-'
      const r = ['en-us', 'en-lr', 'my']
      const o = { '8.5x11': 'Letter', '8.5x14': 'Legal' }
      const l = { '297x420': 'A3', '210x297': 'A4' }
      function getPageName(e, t, i) {
        return i[`${t ? e.width : e.height}x${t ? e.height : e.width}`]
      }
      const c = new WeakMap()
      const d = new WeakSet()
      const h = new WeakSet()
      const u = new WeakSet()
      const p = new WeakSet()
      const g = new WeakSet()
      const f = new WeakSet()
      t.PDFDocumentProperties = class PDFDocumentProperties {
        constructor(e, t, i, n, s) {
          const { dialog: a, fields: o, closeButton: l } = e
          _classPrivateMethodInitSpec(this, f)
          _classPrivateMethodInitSpec(this, g)
          _classPrivateMethodInitSpec(this, p)
          _classPrivateMethodInitSpec(this, u)
          _classPrivateMethodInitSpec(this, h)
          _classPrivateMethodInitSpec(this, d)
          !(function _classPrivateFieldInitSpec(e, t, i) {
            _checkPrivateRedeclaration(e, t)
            t.set(e, i)
          })(this, c, { writable: !0, value: null })
          this.dialog = a
          this.fields = o
          this.overlayManager = t
          this.l10n = n
          this._fileNameLookup = s
          _classPrivateMethodGet(this, d, _reset2).call(this)
          l.addEventListener('click', this.close.bind(this))
          this.overlayManager.register(this.dialog)
          i._on('pagechanging', (e) => {
            this._currentPageNumber = e.pageNumber
          })
          i._on('rotationchanging', (e) => {
            this._pagesRotation = e.pagesRotation
          })
          this._isNonMetricLocale = !0
          n.getLanguage().then((e) => {
            this._isNonMetricLocale = r.includes(e)
          })
        }

        async open() {
          await Promise.all([
            this.overlayManager.open(this.dialog),
            this._dataAvailableCapability.promise
          ])
          const e = this._currentPageNumber
          const t = this._pagesRotation
          if (
            _classPrivateFieldGet(this, c) &&
            e === _classPrivateFieldGet(this, c)._currentPageNumber &&
            t === _classPrivateFieldGet(this, c)._pagesRotation
          ) {
            _classPrivateMethodGet(this, h, _updateUI2).call(this)
            return
          }
          const { info: i, contentLength: n } = await this.pdfDocument.getMetadata()
          const [a, r, o, l, d, m] = await Promise.all([
            this._fileNameLookup(),
            _classPrivateMethodGet(this, u, _parseFileSize2).call(this, n),
            _classPrivateMethodGet(this, g, _parseDate2).call(this, i.CreationDate),
            _classPrivateMethodGet(this, g, _parseDate2).call(this, i.ModDate),
            this.pdfDocument
              .getPage(e)
              .then((e) =>
                _classPrivateMethodGet(this, p, _parsePageSize2).call(
                  this,
                  (0, s.getPageSizeInches)(e),
                  t
                )
              ),
            _classPrivateMethodGet(this, f, _parseLinearization2).call(this, i.IsLinearized)
          ])
          _classPrivateFieldSet(
            this,
            c,
            Object.freeze({
              fileName: a,
              fileSize: r,
              title: i.Title,
              author: i.Author,
              subject: i.Subject,
              keywords: i.Keywords,
              creationDate: o,
              modificationDate: l,
              creator: i.Creator,
              producer: i.Producer,
              version: i.PDFFormatVersion,
              pageCount: this.pdfDocument.numPages,
              pageSize: d,
              linearized: m,
              _currentPageNumber: e,
              _pagesRotation: t
            })
          )
          _classPrivateMethodGet(this, h, _updateUI2).call(this)
          const { length: v } = await this.pdfDocument.getDownloadInfo()
          if (n === v) return
          const _ = Object.assign(Object.create(null), _classPrivateFieldGet(this, c))
          _.fileSize = await _classPrivateMethodGet(this, u, _parseFileSize2).call(this, v)
          _classPrivateFieldSet(this, c, Object.freeze(_))
          _classPrivateMethodGet(this, h, _updateUI2).call(this)
        }

        async close() {
          this.overlayManager.close(this.dialog)
        }

        setDocument(e) {
          if (this.pdfDocument) {
            _classPrivateMethodGet(this, d, _reset2).call(this)
            _classPrivateMethodGet(this, h, _updateUI2).call(this, !0)
          }
          if (e) {
            this.pdfDocument = e
            this._dataAvailableCapability.resolve()
          }
        }
      }
      function _reset2() {
        this.pdfDocument = null
        _classPrivateFieldSet(this, c, null)
        this._dataAvailableCapability = (0, n.createPromiseCapability)()
        this._currentPageNumber = 1
        this._pagesRotation = 0
      }
      function _updateUI2() {
        const e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
        if (!e && _classPrivateFieldGet(this, c)) {
          if (this.overlayManager.active === this.dialog)
            for (const e in this.fields) {
              const t = _classPrivateFieldGet(this, c)[e]
              this.fields[e].textContent = t || t === 0 ? t : a
            }
        } else for (const e in this.fields) this.fields[e].textContent = a
      }
      async function _parseFileSize2() {
        const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
        const t = e / 1024
        const i = t / 1024
        if (t)
          return this.l10n.get(`document_properties_${i >= 1 ? 'mb' : 'kb'}`, {
            size_mb: i >= 1 && (+i.toPrecision(3)).toLocaleString(),
            size_kb: i < 1 && (+t.toPrecision(3)).toLocaleString(),
            size_b: e.toLocaleString()
          })
      }
      async function _parsePageSize2(e, t) {
        if (!e) return
        t % 180 != 0 && (e = { width: e.height, height: e.width })
        const i = (0, s.isPortraitOrientation)(e)
        let n = {
          width: Math.round(100 * e.width) / 100,
          height: Math.round(100 * e.height) / 100
        }
        let a = {
          width: Math.round(25.4 * e.width * 10) / 10,
          height: Math.round(25.4 * e.height * 10) / 10
        }
        let r = getPageName(n, i, o) || getPageName(a, i, l)
        if (!(r || (Number.isInteger(a.width) && Number.isInteger(a.height)))) {
          const t = { width: 25.4 * e.width, height: 25.4 * e.height }
          const s = { width: Math.round(a.width), height: Math.round(a.height) }
          if (Math.abs(t.width - s.width) < 0.1 && Math.abs(t.height - s.height) < 0.1) {
            r = getPageName(s, i, l)
            if (r) {
              n = {
                width: Math.round((s.width / 25.4) * 100) / 100,
                height: Math.round((s.height / 25.4) * 100) / 100
              }
              a = s
            }
          }
        }
        const [{ width: c, height: d }, h, u, p] = await Promise.all([
          this._isNonMetricLocale ? n : a,
          this.l10n.get(
            `document_properties_page_size_unit_${
              this._isNonMetricLocale ? 'inches' : 'millimeters'
            }`
          ),
          r && this.l10n.get(`document_properties_page_size_name_${r.toLowerCase()}`),
          this.l10n.get(`document_properties_page_size_orientation_${i ? 'portrait' : 'landscape'}`)
        ])
        return this.l10n.get(`document_properties_page_size_dimension_${u ? 'name_' : ''}string`, {
          width: c.toLocaleString(),
          height: d.toLocaleString(),
          unit: h,
          name: u,
          orientation: p
        })
      }
      async function _parseDate2(e) {
        const t = n.PDFDateString.toDateObject(e)
        if (t)
          return this.l10n.get('document_properties_date_string', {
            date: t.toLocaleDateString(),
            time: t.toLocaleTimeString()
          })
      }
      function _parseLinearization2(e) {
        return this.l10n.get(`document_properties_linearized_${e ? 'yes' : 'no'}`)
      }
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.PDFFindBar = void 0
      const n = i(17)
      function _classPrivateMethodInitSpec(e, t) {
        !(function _checkPrivateRedeclaration(e, t) {
          if (t.has(e))
            throw new TypeError('Cannot initialize the same private elements twice on an object')
        })(e, t)
        t.add(e)
      }
      function _classPrivateMethodGet(e, t, i) {
        if (!t.has(e)) throw new TypeError('attempted to get private field on non-instance')
        return i
      }
      const s = new WeakSet()
      t.PDFFindBar = class PDFFindBar {
        constructor(e, t, i) {
          _classPrivateMethodInitSpec(this, s)
          this.opened = !1
          this.bar = e.bar
          this.toggleButton = e.toggleButton
          this.findField = e.findField
          this.highlightAll = e.highlightAllCheckbox
          this.caseSensitive = e.caseSensitiveCheckbox
          this.matchDiacritics = e.matchDiacriticsCheckbox
          this.entireWord = e.entireWordCheckbox
          this.findMsg = e.findMsg
          this.findResultsCount = e.findResultsCount
          this.findPreviousButton = e.findPreviousButton
          this.findNextButton = e.findNextButton
          this.eventBus = t
          this.l10n = i
          this.toggleButton.addEventListener('click', () => {
            this.toggle()
          })
          this.findField.addEventListener('input', () => {
            this.dispatchEvent('')
          })
          this.bar.addEventListener('keydown', (e) => {
            switch (e.keyCode) {
              case 13:
                e.target === this.findField && this.dispatchEvent('again', e.shiftKey)
                break
              case 27:
                this.close()
            }
          })
          this.findPreviousButton.addEventListener('click', () => {
            this.dispatchEvent('again', !0)
          })
          this.findNextButton.addEventListener('click', () => {
            this.dispatchEvent('again', !1)
          })
          this.highlightAll.addEventListener('click', () => {
            this.dispatchEvent('highlightallchange')
          })
          this.caseSensitive.addEventListener('click', () => {
            this.dispatchEvent('casesensitivitychange')
          })
          this.entireWord.addEventListener('click', () => {
            this.dispatchEvent('entirewordchange')
          })
          this.matchDiacritics.addEventListener('click', () => {
            this.dispatchEvent('diacriticmatchingchange')
          })
          this.eventBus._on('resize', _classPrivateMethodGet(this, s, _adjustWidth2).bind(this))
        }

        reset() {
          this.updateUIState()
        }

        dispatchEvent(e) {
          const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
          this.eventBus.dispatch('find', {
            source: this,
            type: e,
            query: this.findField.value,
            phraseSearch: !0,
            caseSensitive: this.caseSensitive.checked,
            entireWord: this.entireWord.checked,
            highlightAll: this.highlightAll.checked,
            findPrevious: t,
            matchDiacritics: this.matchDiacritics.checked
          })
        }

        updateUIState(e, t, i) {
          let a = Promise.resolve('')
          let r = ''
          switch (e) {
            case n.FindState.FOUND:
              break
            case n.FindState.PENDING:
              r = 'pending'
              break
            case n.FindState.NOT_FOUND:
              a = this.l10n.get('find_not_found')
              r = 'notFound'
              break
            case n.FindState.WRAPPED:
              a = this.l10n.get(`find_reached_${t ? 'top' : 'bottom'}`)
          }
          this.findField.setAttribute('data-status', r)
          this.findField.setAttribute('aria-invalid', e === n.FindState.NOT_FOUND)
          a.then((e) => {
            this.findMsg.textContent = e
            _classPrivateMethodGet(this, s, _adjustWidth2).call(this)
          })
          this.updateResultsCount(i)
        }

        updateResultsCount() {
          const { current: e = 0, total: t = 0 } =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
          let i = Promise.resolve('')
          if (t > 0)
            if (t > 1e3) {
              const e = 'find_match_count_limit'
              i = this.l10n.get(e, { limit: 1e3 })
            } else {
              const n = 'find_match_count'
              i = this.l10n.get(n, { current: e, total: t })
            }
          i.then((e) => {
            this.findResultsCount.textContent = e
            _classPrivateMethodGet(this, s, _adjustWidth2).call(this)
          })
        }

        open() {
          if (!this.opened) {
            this.opened = !0
            this.toggleButton.classList.add('toggled')
            this.toggleButton.setAttribute('aria-expanded', 'true')
            this.bar.classList.remove('hidden')
          }
          this.findField.select()
          this.findField.focus()
          _classPrivateMethodGet(this, s, _adjustWidth2).call(this)
        }

        close() {
          if (this.opened) {
            this.opened = !1
            this.toggleButton.classList.remove('toggled')
            this.toggleButton.setAttribute('aria-expanded', 'false')
            this.bar.classList.add('hidden')
            this.eventBus.dispatch('findbarclose', { source: this })
          }
        }

        toggle() {
          this.opened ? this.close() : this.open()
        }
      }
      function _adjustWidth2() {
        if (!this.opened) return
        this.bar.classList.remove('wrapContainers')
        this.bar.clientHeight > this.bar.firstElementChild.clientHeight &&
          this.bar.classList.add('wrapContainers')
      }
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.PDFFindController = t.FindState = void 0
      const n = i(1)
      const s = i(5)
      const a = i(18)
      function _classPrivateMethodInitSpec(e, t) {
        _checkPrivateRedeclaration(e, t)
        t.add(e)
      }
      function _checkPrivateRedeclaration(e, t) {
        if (t.has(e))
          throw new TypeError('Cannot initialize the same private elements twice on an object')
      }
      function _classPrivateFieldGet(e, t) {
        const i = (function _classExtractFieldDescriptor(e, t, i) {
          if (!t.has(e)) throw new TypeError(`attempted to ${i} private field on non-instance`)
          return t.get(e)
        })(e, t, 'get')
        return (function _classApplyDescriptorGet(e, t) {
          if (t.get) return t.get.call(e)
          return t.value
        })(e, i)
      }
      function _classPrivateMethodGet(e, t, i) {
        if (!t.has(e)) throw new TypeError('attempted to get private field on non-instance')
        return i
      }
      const r = { FOUND: 0, NOT_FOUND: 1, WRAPPED: 2, PENDING: 3 }
      t.FindState = r
      const o = {
        '‐': '-',
        '‘': "'",
        '’': "'",
        '‚': "'",
        '‛': "'",
        '“': '"',
        '”': '"',
        '„': '"',
        '‟': '"',
        '¼': '1/4',
        '½': '1/2',
        '¾': '3/4'
      }
      const l = new Set([
        12441, 12442, 2381, 2509, 2637, 2765, 2893, 3021, 3149, 3277, 3387, 3388, 3405, 3530, 3642,
        3770, 3972, 4153, 4154, 5908, 5940, 6098, 6752, 6980, 7082, 7083, 7154, 7155, 11647, 43014,
        43052, 43204, 43347, 43456, 43766, 44013, 3158, 3953, 3954, 3962, 3963, 3964, 3965, 3968,
        3956
      ])
      const c = [...l.values()].map((e) => String.fromCharCode(e)).join('')
      const d = /\p{M}+/gu
      const h = /([.*+?^${}()|[\]\\])|(\p{P})|(\s+)|(\p{M})|(\p{L})/gu
      const u = /([^\p{M}])\p{M}*$/u
      const p = /^\p{M}*([^\p{M}])/u
      const g = /[\uAC00-\uD7AF\uFA6C\uFACF-\uFAD1\uFAD5-\uFAD7]+/g
      const f = new Map()
      let m = null
      let v = null
      function normalize(e) {
        const t = []
        let i
        let n
        for (; (i = g.exec(e)) !== null; ) {
          let { index: e } = i
          for (const n of i[0]) {
            let i = f.get(n)
            if (!i) {
              i = n.normalize('NFD').length
              f.set(n, i)
            }
            t.push([i, e++])
          }
        }
        if (t.length === 0 && m) n = m
        else if (t.length > 0 && v) n = v
        else {
          const e = `([${Object.keys(o).join('')}])|(\\p{M}+(?:-\\n)?)|(\\S-\\n)|(\\n)`
          n =
            t.length === 0
              ? (m = new RegExp(`${e}|(\\u0000)`, 'gum'))
              : (v = new RegExp(
                  `${e}|([\\u1100-\\u1112\\ud7a4-\\ud7af\\ud84a\\ud84c\\ud850\\ud854\\ud857\\ud85f])`,
                  'gum'
                ))
        }
        const s = []
        for (; (i = d.exec(e)) !== null; ) s.push([i[0].length, i.index])
        let a = e.normalize('NFD')
        const r = [[0, 0]]
        let l = 0
        let c = 0
        let h = 0
        let u = 0
        let p = 0
        let _ = !1
        a = a.replace(n, (e, i, n, a, d, g, f) => {
          let m
          f -= u
          if (i) {
            const t = o[e]
            const i = t.length
            for (let e = 1; e < i; e++) r.push([f - h + e, h - e])
            h -= i - 1
            return t
          }
          if (n) {
            let v
            const e = n.endsWith('\n')
            const t = e ? n.length - 2 : n.length
            _ = !0
            let i = t
            if (f + p === ((v = s[l]) === null || void 0 === v ? void 0 : v[1])) {
              i -= s[l][0]
              ++l
            }
            for (let e = 1; e <= i; e++) r.push([f - 1 - h + e, h - e])
            h -= i
            u += i
            if (e) {
              f += t - 1
              r.push([f - h + 1, 1 + h])
              h += 1
              u += 1
              p += 1
              return n.slice(0, t)
            }
            return n
          }
          if (a) {
            r.push([f - h + 1, 1 + h])
            h += 1
            u += 1
            p += 1
            return a.charAt(0)
          }
          if (d) {
            r.push([f - h + 1, h - 1])
            h -= 1
            u += 1
            p += 1
            return ' '
          }
          if (f + p === ((m = t[c]) === null || void 0 === m ? void 0 : m[1])) {
            const e = t[c][0] - 1
            ++c
            for (let t = 1; t <= e; t++) r.push([f - (h - t), h - t])
            h -= e
            u += e
          }
          return g
        })
        r.push([a.length, h])
        return [a, r, _]
      }
      function getOriginalIndex(e, t, i) {
        if (!e) return [t, i]
        const s = t
        const a = t + i
        let r = (0, n.binarySearchFirstItem)(e, (e) => e[0] >= s)
        e[r][0] > s && --r
        let o = (0, n.binarySearchFirstItem)(e, (e) => e[0] >= a, r)
        e[o][0] > a && --o
        return [s + e[r][1], i + e[o][1] - e[r][1]]
      }
      const _ = new WeakSet()
      const b = new WeakSet()
      const w = new WeakMap()
      const P = new WeakSet()
      const y = new WeakSet()
      const S = new WeakSet()
      const A = new WeakSet()
      const E = new WeakSet()
      const x = new WeakSet()
      const C = new WeakSet()
      const M = new WeakSet()
      const T = new WeakSet()
      const k = new WeakSet()
      const I = new WeakSet()
      const D = new WeakSet()
      const L = new WeakSet()
      const R = new WeakSet()
      const O = new WeakSet()
      const N = new WeakSet()
      const B = new WeakSet()
      t.PDFFindController = class PDFFindController {
        constructor(e) {
          const { linkService: t, eventBus: i } = e
          _classPrivateMethodInitSpec(this, B)
          _classPrivateMethodInitSpec(this, N)
          _classPrivateMethodInitSpec(this, O)
          _classPrivateMethodInitSpec(this, R)
          _classPrivateMethodInitSpec(this, L)
          _classPrivateMethodInitSpec(this, D)
          _classPrivateMethodInitSpec(this, I)
          _classPrivateMethodInitSpec(this, k)
          _classPrivateMethodInitSpec(this, T)
          _classPrivateMethodInitSpec(this, M)
          _classPrivateMethodInitSpec(this, C)
          _classPrivateMethodInitSpec(this, x)
          _classPrivateMethodInitSpec(this, E)
          _classPrivateMethodInitSpec(this, A)
          _classPrivateMethodInitSpec(this, S)
          _classPrivateMethodInitSpec(this, y)
          _classPrivateMethodInitSpec(this, P)
          !(function _classPrivateFieldInitSpec(e, t, i) {
            _checkPrivateRedeclaration(e, t)
            t.set(e, i)
          })(this, w, { get: _get_query, set: void 0 })
          _classPrivateMethodInitSpec(this, b)
          _classPrivateMethodInitSpec(this, _)
          this._linkService = t
          this._eventBus = i
          _classPrivateMethodGet(this, b, _reset2).call(this)
          i._on('find', _classPrivateMethodGet(this, _, _onFind2).bind(this))
          i._on('findbarclose', _classPrivateMethodGet(this, R, _onFindBarClose2).bind(this))
        }

        get highlightMatches() {
          return this._highlightMatches
        }

        get pageMatches() {
          return this._pageMatches
        }

        get pageMatchesLength() {
          return this._pageMatchesLength
        }

        get selected() {
          return this._selected
        }

        get state() {
          return this._state
        }

        setDocument(e) {
          this._pdfDocument && _classPrivateMethodGet(this, b, _reset2).call(this)
          if (e) {
            this._pdfDocument = e
            this._firstPageCapability.resolve()
          }
        }

        scrollMatchIntoView(e) {
          const {
            element: t = null,
            selectedLeft: i = 0,
            pageIndex: s = -1,
            matchIndex: a = -1
          } = e
          if (!this._scrollMatches || !t) return
          if (a === -1 || a !== this._selected.matchIdx) return
          if (s === -1 || s !== this._selected.pageIdx) return
          this._scrollMatches = !1
          const r = { top: -50, left: i + -400 }
          ;(0, n.scrollIntoView)(t, r, !0)
        }

        getIndicesOf(e, t, i) {
          const n = e.length
          if (n === 0) return []
          let s
          let a = 0
          const r = []
          if (!i) {
            t = t.toLowerCase()
            e = e.toLowerCase()
          }
          for (; (s = t.indexOf(e, a)) > -1; ) {
            r.push(s)
            a = s + n
          }
          return r
        }

        replaceSensitiveWord(e) {
          console.log('begin to replaceSensitiveWord')
          for (
            let t = signParams.sensitiveWords, i = signParams.replaceChar, n = 0;
            n < t.length;
            ++n
          ) {
            const s = t[n]
            const a = getIndicesOf(s, e, !1)
            if (a.length != 0) {
              console.log(`sensitive word = ${s}, sensitive word indices = ${a}`)
              const r = i.repeat(s.length)
              const o = new RegExp(s, 'g')
              e = e.replace(o, r)
            }
          }
          console.log('finished replaceSensitiveWord')
          return e
        }
      }
      function _onFind2(e) {
        if (!e) return
        const t = this._pdfDocument
        const { type: i } = e
        ;(this._state === null ||
          _classPrivateMethodGet(this, P, _shouldDirtyMatch2).call(this, e)) &&
          (this._dirtyMatch = !0)
        this._state = e
        i !== 'highlightallchange' &&
          _classPrivateMethodGet(this, B, _updateUIState2).call(this, r.PENDING)
        this._firstPageCapability.promise.then(() => {
          if (!this._pdfDocument || (t && this._pdfDocument !== t)) return
          _classPrivateMethodGet(this, x, _extractText2).call(this)
          const e = !this._highlightMatches
          const n = !!this._findTimeout
          if (this._findTimeout) {
            clearTimeout(this._findTimeout)
            this._findTimeout = null
          }
          if (i)
            if (this._dirtyMatch) _classPrivateMethodGet(this, T, _nextMatch2).call(this)
            else if (i === 'again') {
              _classPrivateMethodGet(this, T, _nextMatch2).call(this)
              e &&
                this._state.highlightAll &&
                _classPrivateMethodGet(this, M, _updateAllPages2).call(this)
            } else if (i === 'highlightallchange') {
              n
                ? _classPrivateMethodGet(this, T, _nextMatch2).call(this)
                : (this._highlightMatches = !0)
              _classPrivateMethodGet(this, M, _updateAllPages2).call(this)
            } else _classPrivateMethodGet(this, T, _nextMatch2).call(this)
          else
            this._findTimeout = setTimeout(() => {
              _classPrivateMethodGet(this, T, _nextMatch2).call(this)
              this._findTimeout = null
            }, 250)
        })
      }
      function _reset2() {
        this._highlightMatches = !1
        this._scrollMatches = !1
        this._pdfDocument = null
        this._pageMatches = []
        this._pageMatchesLength = []
        this._state = null
        this._selected = { pageIdx: -1, matchIdx: -1 }
        this._offset = { pageIdx: null, matchIdx: null, wrapped: !1 }
        this._extractTextPromises = []
        this._pageContents = []
        this._pageDiffs = []
        this._hasDiacritics = []
        this._matchesCountTotal = 0
        this._pagesToSearch = null
        this._pendingFindMatches = new Set()
        this._resumePageIdx = null
        this._dirtyMatch = !1
        clearTimeout(this._findTimeout)
        this._findTimeout = null
        this._firstPageCapability = (0, s.createPromiseCapability)()
      }
      function _get_query() {
        if (this._state.query !== this._rawQuery) {
          this._rawQuery = this._state.query
          ;[this._normalizedQuery] = normalize(this._state.query)
        }
        return this._normalizedQuery
      }
      function _shouldDirtyMatch2(e) {
        if (e.query !== this._state.query) return !0
        switch (e.type) {
          case 'again':
            const e = this._selected.pageIdx + 1
            const t = this._linkService
            return e >= 1 && e <= t.pagesCount && e !== t.page && !t.isPageVisible(e)
          case 'highlightallchange':
            return !1
        }
        return !0
      }
      function _isEntireWord2(e, t, i) {
        let n = e.slice(0, t).match(u)
        if (n) {
          const i = e.charCodeAt(t)
          const s = n[1].charCodeAt(0)
          if ((0, a.getCharacterType)(i) === (0, a.getCharacterType)(s)) return !1
        }
        n = e.slice(t + i).match(p)
        if (n) {
          const s = e.charCodeAt(t + i - 1)
          const r = n[1].charCodeAt(0)
          if ((0, a.getCharacterType)(s) === (0, a.getCharacterType)(r)) return !1
        }
        return !0
      }
      function _calculateRegExpMatch2(e, t, i, n) {
        const s = []
        const a = []
        const r = this._pageDiffs[i]
        let o
        for (; (o = e.exec(n)) !== null; ) {
          if (
            t &&
            !_classPrivateMethodGet(this, y, _isEntireWord2).call(this, n, o.index, o[0].length)
          )
            continue
          const [e, i] = getOriginalIndex(r, o.index, o[0].length)
          if (i) {
            s.push(e)
            a.push(i)
          }
        }
        this._pageMatches[i] = s
        this._pageMatchesLength[i] = a
      }
      function _convertToRegExpString2(e, t) {
        const { matchDiacritics: i } = this._state
        let n = !1
        const s = '[ ]*'
        ;(e = e.replace(h, (e, s, a, r, o, c) => {
          if (s) return `[ ]*\\${s}[ ]*`
          if (a) return `[ ]*${a}[ ]*`
          if (r) return '[ ]+'
          if (i) return o || c
          if (o) return l.has(o.charCodeAt(0)) ? o : ''
          if (t) {
            n = !0
            return `${c}\\p{M}*`
          }
          return c
        })).endsWith(s) && (e = e.slice(0, e.length - s.length))
        if (i && t) {
          n = !0
          e = `${e}(?=[${c}]|[^\\p{M}]|$)`
        }
        return [n, e]
      }
      function _calculateMatch2(e) {
        let t = _classPrivateFieldGet(this, w)
        if (t.length === 0) return
        const { caseSensitive: i, entireWord: n, phraseSearch: s } = this._state
        const a = this._pageContents[e]
        const r = this._hasDiacritics[e]
        a = replaceSensitiveWord(a)
        let o = !1
        if (s) [o, t] = _classPrivateMethodGet(this, A, _convertToRegExpString2).call(this, t, r)
        else {
          const e = t.match(/\S+/g)
          e &&
            (t = e
              .sort()
              .reverse()
              .map((e) => {
                const [t, i] = _classPrivateMethodGet(this, A, _convertToRegExpString2).call(
                  this,
                  e,
                  r
                )
                o || (o = t)
                return `(${i})`
              })
              .join('|'))
        }
        t = new RegExp(t, `g${o ? 'u' : ''}${i ? '' : 'i'}`)
        _classPrivateMethodGet(this, S, _calculateRegExpMatch2).call(this, t, n, e, a)
        this._state.highlightAll && _classPrivateMethodGet(this, C, _updatePage2).call(this, e)
        if (this._resumePageIdx === e) {
          this._resumePageIdx = null
          _classPrivateMethodGet(this, I, _nextPageMatch2).call(this)
        }
        const l = this._pageMatches[e].length
        if (l > 0) {
          this._matchesCountTotal += l
          _classPrivateMethodGet(this, N, _updateUIResultsCount2).call(this)
        }
      }
      function _extractText2() {
        if (this._extractTextPromises.length > 0) return
        let e = Promise.resolve()
        for (let t = 0, i = this._linkService.pagesCount; t < i; t++) {
          const i = (0, s.createPromiseCapability)()
          this._extractTextPromises[t] = i.promise
          e = e.then(() =>
            this._pdfDocument
              .getPage(t + 1)
              .then((e) => e.getTextContent())
              .then(
                (e) => {
                  const n = []
                  for (const t of e.items) {
                    n.push(t.str)
                    t.hasEOL && n.push('\n')
                  }
                  ;[this._pageContents[t], this._pageDiffs[t], this._hasDiacritics[t]] = normalize(
                    n.join('')
                  )
                  i.resolve()
                },
                (e) => {
                  console.error(`Unable to get text content for page ${t + 1}`, e)
                  this._pageContents[t] = ''
                  this._pageDiffs[t] = null
                  this._hasDiacritics[t] = !1
                  i.resolve()
                }
              )
          )
        }
      }
      function _updatePage2(e) {
        this._scrollMatches && this._selected.pageIdx === e && (this._linkService.page = e + 1)
        this._eventBus.dispatch('updatetextlayermatches', { source: this, pageIndex: e })
      }
      function _updateAllPages2() {
        this._eventBus.dispatch('updatetextlayermatches', { source: this, pageIndex: -1 })
      }
      function _nextMatch2() {
        const e = this._state.findPrevious
        const t = this._linkService.page - 1
        const i = this._linkService.pagesCount
        this._highlightMatches = !0
        if (this._dirtyMatch) {
          this._dirtyMatch = !1
          this._selected.pageIdx = this._selected.matchIdx = -1
          this._offset.pageIdx = t
          this._offset.matchIdx = null
          this._offset.wrapped = !1
          this._resumePageIdx = null
          this._pageMatches.length = 0
          this._pageMatchesLength.length = 0
          this._matchesCountTotal = 0
          _classPrivateMethodGet(this, M, _updateAllPages2).call(this)
          for (let e = 0; e < i; e++)
            if (!this._pendingFindMatches.has(e)) {
              this._pendingFindMatches.add(e)
              this._extractTextPromises[e].then(() => {
                this._pendingFindMatches.delete(e)
                _classPrivateMethodGet(this, E, _calculateMatch2).call(this, e)
              })
            }
        }
        if (_classPrivateFieldGet(this, w) === '') {
          _classPrivateMethodGet(this, B, _updateUIState2).call(this, r.FOUND)
          return
        }
        if (this._resumePageIdx) return
        const n = this._offset
        this._pagesToSearch = i
        if (n.matchIdx !== null) {
          const t = this._pageMatches[n.pageIdx].length
          if ((!e && n.matchIdx + 1 < t) || (e && n.matchIdx > 0)) {
            n.matchIdx = e ? n.matchIdx - 1 : n.matchIdx + 1
            _classPrivateMethodGet(this, L, _updateMatch2).call(this, !0)
            return
          }
          _classPrivateMethodGet(this, D, _advanceOffsetPage2).call(this, e)
        }
        _classPrivateMethodGet(this, I, _nextPageMatch2).call(this)
      }
      function _matchesReady2(e) {
        const t = this._offset
        const i = e.length
        const n = this._state.findPrevious
        if (i) {
          t.matchIdx = n ? i - 1 : 0
          _classPrivateMethodGet(this, L, _updateMatch2).call(this, !0)
          return !0
        }
        _classPrivateMethodGet(this, D, _advanceOffsetPage2).call(this, n)
        if (t.wrapped) {
          t.matchIdx = null
          if (this._pagesToSearch < 0) {
            _classPrivateMethodGet(this, L, _updateMatch2).call(this, !1)
            return !0
          }
        }
        return !1
      }
      function _nextPageMatch2() {
        this._resumePageIdx !== null && console.error('There can only be one pending page.')
        let e = null
        do {
          const t = this._offset.pageIdx
          e = this._pageMatches[t]
          if (!e) {
            this._resumePageIdx = t
            break
          }
        } while (!_classPrivateMethodGet(this, k, _matchesReady2).call(this, e))
      }
      function _advanceOffsetPage2(e) {
        const t = this._offset
        const i = this._linkService.pagesCount
        t.pageIdx = e ? t.pageIdx - 1 : t.pageIdx + 1
        t.matchIdx = null
        this._pagesToSearch--
        if (t.pageIdx >= i || t.pageIdx < 0) {
          t.pageIdx = e ? i - 1 : 0
          t.wrapped = !0
        }
      }
      function _updateMatch2() {
        const e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
        let t = r.NOT_FOUND
        const i = this._offset.wrapped
        this._offset.wrapped = !1
        if (e) {
          const e = this._selected.pageIdx
          this._selected.pageIdx = this._offset.pageIdx
          this._selected.matchIdx = this._offset.matchIdx
          t = i ? r.WRAPPED : r.FOUND
          e !== -1 &&
            e !== this._selected.pageIdx &&
            _classPrivateMethodGet(this, C, _updatePage2).call(this, e)
        }
        _classPrivateMethodGet(this, B, _updateUIState2).call(this, t, this._state.findPrevious)
        if (this._selected.pageIdx !== -1) {
          this._scrollMatches = !0
          _classPrivateMethodGet(this, C, _updatePage2).call(this, this._selected.pageIdx)
        }
      }
      function _onFindBarClose2(e) {
        const t = this._pdfDocument
        this._firstPageCapability.promise.then(() => {
          if (this._pdfDocument && (!t || this._pdfDocument === t)) {
            if (this._findTimeout) {
              clearTimeout(this._findTimeout)
              this._findTimeout = null
            }
            if (this._resumePageIdx) {
              this._resumePageIdx = null
              this._dirtyMatch = !0
            }
            _classPrivateMethodGet(this, B, _updateUIState2).call(this, r.FOUND)
            this._highlightMatches = !1
            _classPrivateMethodGet(this, M, _updateAllPages2).call(this)
          }
        })
      }
      function _requestMatchesCount2() {
        const { pageIdx: e, matchIdx: t } = this._selected
        let i = 0
        let n = this._matchesCountTotal
        if (t !== -1) {
          for (let t = 0; t < e; t++) {
            var s
            i += ((s = this._pageMatches[t]) === null || void 0 === s ? void 0 : s.length) || 0
          }
          i += t + 1
        }
        ;(i < 1 || i > n) && (i = n = 0)
        return { current: i, total: n }
      }
      function _updateUIResultsCount2() {
        this._eventBus.dispatch('updatefindmatchescount', {
          source: this,
          matchesCount: _classPrivateMethodGet(this, O, _requestMatchesCount2).call(this)
        })
      }
      function _updateUIState2(e) {
        let t
        let i
        const n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
        this._eventBus.dispatch('updatefindcontrolstate', {
          source: this,
          state: e,
          previous: n,
          matchesCount: _classPrivateMethodGet(this, O, _requestMatchesCount2).call(this),
          rawQuery:
            (t = (i = this._state) === null || void 0 === i ? void 0 : i.query) !== null &&
            void 0 !== t
              ? t
              : null
        })
      }
    },
    (e, t) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.CharacterType = void 0
      t.getCharacterType = function getCharacterType(e) {
        if (
          (function isAlphabeticalScript(e) {
            return e < 11904
          })(e)
        )
          return (function isAscii(e) {
            return (65408 & e) == 0
          })(e)
            ? (function isAsciiSpace(e) {
                return e === 32 || e === 9 || e === 13 || e === 10
              })(e)
              ? i.SPACE
              : (function isAsciiAlpha(e) {
                  return (e >= 97 && e <= 122) || (e >= 65 && e <= 90)
                })(e) ||
                (function isAsciiDigit(e) {
                  return e >= 48 && e <= 57
                })(e) ||
                e === 95
              ? i.ALPHA_LETTER
              : i.PUNCT
            : (function isThai(e) {
                return (65408 & e) == 3584
              })(e)
            ? i.THAI_LETTER
            : e === 160
            ? i.SPACE
            : i.ALPHA_LETTER
        if (
          (function isHan(e) {
            return (e >= 13312 && e <= 40959) || (e >= 63744 && e <= 64255)
          })(e)
        )
          return i.HAN_LETTER
        if (
          (function isKatakana(e) {
            return e >= 12448 && e <= 12543
          })(e)
        )
          return i.KATAKANA_LETTER
        if (
          (function isHiragana(e) {
            return e >= 12352 && e <= 12447
          })(e)
        )
          return i.HIRAGANA_LETTER
        if (
          (function isHalfwidthKatakana(e) {
            return e >= 65376 && e <= 65439
          })(e)
        )
          return i.HALFWIDTH_KATAKANA_LETTER
        return i.ALPHA_LETTER
      }
      const i = {
        SPACE: 0,
        ALPHA_LETTER: 1,
        PUNCT: 2,
        HAN_LETTER: 3,
        KATAKANA_LETTER: 4,
        HIRAGANA_LETTER: 5,
        HALFWIDTH_KATAKANA_LETTER: 6,
        THAI_LETTER: 7
      }
      t.CharacterType = i
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.PDFHistory = void 0
      t.isDestArraysEqual = isDestArraysEqual
      t.isDestHashesEqual = isDestHashesEqual
      const n = i(1)
      const s = i(6)
      function getCurrentHash() {
        return document.location.hash
      }
      t.PDFHistory = class PDFHistory {
        constructor(e) {
          const { linkService: t, eventBus: i } = e
          this.linkService = t
          this.eventBus = i
          this._initialized = !1
          this._fingerprint = ''
          this.reset()
          this._boundEvents = null
          this.eventBus._on('pagesinit', () => {
            this._isPagesLoaded = !1
            this.eventBus._on(
              'pagesloaded',
              (e) => {
                this._isPagesLoaded = !!e.pagesCount
              },
              { once: !0 }
            )
          })
        }

        initialize(e) {
          const { fingerprint: t, resetHistory: i = !1, updateUrl: n = !1 } = e
          if (!t || typeof t !== 'string') {
            console.error('PDFHistory.initialize: The "fingerprint" must be a non-empty string.')
            return
          }
          this._initialized && this.reset()
          const s = this._fingerprint !== '' && this._fingerprint !== t
          this._fingerprint = t
          this._updateUrl = !0 === n
          this._initialized = !0
          this._bindEvents()
          const a = window.history.state
          this._popStateInProgress = !1
          this._blockHashChange = 0
          this._currentHash = getCurrentHash()
          this._numPositionUpdates = 0
          this._uid = this._maxUid = 0
          this._destination = null
          this._position = null
          if (!this._isValidState(a, !0) || i) {
            const { hash: e, page: t, rotation: n } = this._parseCurrentHash(!0)
            if (!e || s || i) {
              this._pushOrReplaceState(null, !0)
              return
            }
            this._pushOrReplaceState({ hash: e, page: t, rotation: n }, !0)
            return
          }
          const r = a.destination
          this._updateInternalState(r, a.uid, !0)
          void 0 !== r.rotation && (this._initialRotation = r.rotation)
          if (r.dest) {
            this._initialBookmark = JSON.stringify(r.dest)
            this._destination.page = null
          } else
            r.hash
              ? (this._initialBookmark = r.hash)
              : r.page && (this._initialBookmark = `page=${r.page}`)
        }

        reset() {
          if (this._initialized) {
            this._pageHide()
            this._initialized = !1
            this._unbindEvents()
          }
          if (this._updateViewareaTimeout) {
            clearTimeout(this._updateViewareaTimeout)
            this._updateViewareaTimeout = null
          }
          this._initialBookmark = null
          this._initialRotation = null
        }

        push(e) {
          const { namedDest: t = null, explicitDest: i, pageNumber: n } = e
          if (!this._initialized) return
          if (t && typeof t !== 'string') {
            console.error(`PDFHistory.push: "${t}" is not a valid namedDest parameter.`)
            return
          }
          if (!Array.isArray(i)) {
            console.error(`PDFHistory.push: "${i}" is not a valid explicitDest parameter.`)
            return
          }
          if (!this._isValidPage(n) && (n !== null || this._destination)) {
            console.error(`PDFHistory.push: "${n}" is not a valid pageNumber parameter.`)
            return
          }
          const s = t || JSON.stringify(i)
          if (!s) return
          let a = !1
          if (
            this._destination &&
            (isDestHashesEqual(this._destination.hash, s) ||
              isDestArraysEqual(this._destination.dest, i))
          ) {
            if (this._destination.page) return
            a = !0
          }
          if (!this._popStateInProgress || a) {
            this._pushOrReplaceState(
              { dest: i, hash: s, page: n, rotation: this.linkService.rotation },
              a
            )
            if (!this._popStateInProgress) {
              this._popStateInProgress = !0
              Promise.resolve().then(() => {
                this._popStateInProgress = !1
              })
            }
          }
        }

        pushPage(e) {
          let t
          if (this._initialized)
            if (this._isValidPage(e)) {
              if (
                ((t = this._destination) === null || void 0 === t ? void 0 : t.page) !== e &&
                !this._popStateInProgress
              ) {
                this._pushOrReplaceState({
                  dest: null,
                  hash: `page=${e}`,
                  page: e,
                  rotation: this.linkService.rotation
                })
                if (!this._popStateInProgress) {
                  this._popStateInProgress = !0
                  Promise.resolve().then(() => {
                    this._popStateInProgress = !1
                  })
                }
              }
            } else console.error(`PDFHistory.pushPage: "${e}" is not a valid page number.`)
        }

        pushCurrentPosition() {
          this._initialized && !this._popStateInProgress && this._tryPushCurrentPosition()
        }

        back() {
          if (!this._initialized || this._popStateInProgress) return
          const e = window.history.state
          this._isValidState(e) && e.uid > 0 && window.history.back()
        }

        forward() {
          if (!this._initialized || this._popStateInProgress) return
          const e = window.history.state
          this._isValidState(e) && e.uid < this._maxUid && window.history.forward()
        }

        get popStateInProgress() {
          return this._initialized && (this._popStateInProgress || this._blockHashChange > 0)
        }

        get initialBookmark() {
          return this._initialized ? this._initialBookmark : null
        }

        get initialRotation() {
          return this._initialized ? this._initialRotation : null
        }

        _pushOrReplaceState(e) {
          const t =
            (arguments.length > 1 && void 0 !== arguments[1] && arguments[1]) || !this._destination
          const i = {
            fingerprint: this._fingerprint,
            uid: t ? this._uid : this._uid + 1,
            destination: e
          }
          this._updateInternalState(e, i.uid)
          let n
          if (this._updateUrl && e != null && e.hash) {
            const t = document.location.href.split('#')[0]
            t.startsWith('file://') || (n = `${t}#${e.hash}`)
          }
          t ? window.history.replaceState(i, '', n) : window.history.pushState(i, '', n)
        }

        _tryPushCurrentPosition() {
          const e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
          if (!this._position) return
          let t = this._position
          if (e) {
            t = Object.assign(Object.create(null), this._position)
            t.temporary = !0
          }
          if (!this._destination) {
            this._pushOrReplaceState(t)
            return
          }
          if (this._destination.temporary) {
            this._pushOrReplaceState(t, !0)
            return
          }
          if (this._destination.hash === t.hash) return
          if (!this._destination.page && this._numPositionUpdates <= 50) return
          let i = !1
          if (this._destination.page >= t.first && this._destination.page <= t.page) {
            if (void 0 !== this._destination.dest || !this._destination.first) return
            i = !0
          }
          this._pushOrReplaceState(t, i)
        }

        _isValidPage(e) {
          return Number.isInteger(e) && e > 0 && e <= this.linkService.pagesCount
        }

        _isValidState(e) {
          const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
          if (!e) return !1
          if (e.fingerprint !== this._fingerprint) {
            if (!t) return !1
            {
              if (
                typeof e.fingerprint !== 'string' ||
                e.fingerprint.length !== this._fingerprint.length
              )
                return !1
              const [t] = performance.getEntriesByType('navigation')
              if ((t == null ? void 0 : t.type) !== 'reload') return !1
            }
          }
          return (
            !(!Number.isInteger(e.uid) || e.uid < 0) &&
            e.destination !== null &&
            typeof e.destination === 'object'
          )
        }

        _updateInternalState(e, t) {
          const i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
          if (this._updateViewareaTimeout) {
            clearTimeout(this._updateViewareaTimeout)
            this._updateViewareaTimeout = null
          }
          i && e != null && e.temporary && delete e.temporary
          this._destination = e
          this._uid = t
          this._maxUid = Math.max(this._maxUid, t)
          this._numPositionUpdates = 0
        }

        _parseCurrentHash() {
          const e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
          const t = unescape(getCurrentHash()).substring(1)
          const i = (0, n.parseQueryString)(t)
          const s = i.get('nameddest') || ''
          let a = 0 | i.get('page')
          ;(!this._isValidPage(a) || (e && s.length > 0)) && (a = null)
          return { hash: t, page: a, rotation: this.linkService.rotation }
        }

        _updateViewarea(e) {
          const { location: t } = e
          if (this._updateViewareaTimeout) {
            clearTimeout(this._updateViewareaTimeout)
            this._updateViewareaTimeout = null
          }
          this._position = {
            hash: t.pdfOpenParams.substring(1),
            page: this.linkService.page,
            first: t.pageNumber,
            rotation: t.rotation
          }
          if (!this._popStateInProgress) {
            this._isPagesLoaded &&
              this._destination &&
              !this._destination.page &&
              this._numPositionUpdates++
            this._updateViewareaTimeout = setTimeout(() => {
              this._popStateInProgress || this._tryPushCurrentPosition(!0)
              this._updateViewareaTimeout = null
            }, 1e3)
          }
        }

        _popState(e) {
          const { state: t } = e
          const i = getCurrentHash()
          const a = this._currentHash !== i
          this._currentHash = i
          if (!t) {
            this._uid++
            const { hash: e, page: t, rotation: i } = this._parseCurrentHash()
            this._pushOrReplaceState({ hash: e, page: t, rotation: i }, !0)
            return
          }
          if (!this._isValidState(t)) return
          this._popStateInProgress = !0
          if (a) {
            this._blockHashChange++
            ;(0, s.waitOnEventOrTimeout)({ target: window, name: 'hashchange', delay: 1e3 }).then(
              () => {
                this._blockHashChange--
              }
            )
          }
          const r = t.destination
          this._updateInternalState(r, t.uid, !0)
          ;(0, n.isValidRotation)(r.rotation) && (this.linkService.rotation = r.rotation)
          r.dest
            ? this.linkService.goToDestination(r.dest)
            : r.hash
            ? this.linkService.setHash(r.hash)
            : r.page && (this.linkService.page = r.page)
          Promise.resolve().then(() => {
            this._popStateInProgress = !1
          })
        }

        _pageHide() {
          ;(this._destination && !this._destination.temporary) || this._tryPushCurrentPosition()
        }

        _bindEvents() {
          if (!this._boundEvents) {
            this._boundEvents = {
              updateViewarea: this._updateViewarea.bind(this),
              popState: this._popState.bind(this),
              pageHide: this._pageHide.bind(this)
            }
            this.eventBus._on('updateviewarea', this._boundEvents.updateViewarea)
            window.addEventListener('popstate', this._boundEvents.popState)
            window.addEventListener('pagehide', this._boundEvents.pageHide)
          }
        }

        _unbindEvents() {
          if (this._boundEvents) {
            this.eventBus._off('updateviewarea', this._boundEvents.updateViewarea)
            window.removeEventListener('popstate', this._boundEvents.popState)
            window.removeEventListener('pagehide', this._boundEvents.pageHide)
            this._boundEvents = null
          }
        }
      }
      function isDestHashesEqual(e, t) {
        if (typeof e !== 'string' || typeof t !== 'string') return !1
        if (e === t) return !0
        return (0, n.parseQueryString)(e).get('nameddest') === t
      }
      function isDestArraysEqual(e, t) {
        function isEntryEqual(e, t) {
          if (typeof e !== typeof t) return !1
          if (Array.isArray(e) || Array.isArray(t)) return !1
          if (e !== null && typeof e === 'object' && t !== null) {
            if (Object.keys(e).length !== Object.keys(t).length) return !1
            for (const i in e) if (!isEntryEqual(e[i], t[i])) return !1
            return !0
          }
          return e === t || (Number.isNaN(e) && Number.isNaN(t))
        }
        if (!Array.isArray(e) || !Array.isArray(t)) return !1
        if (e.length !== t.length) return !1
        for (let i = 0, n = e.length; i < n; i++) if (!isEntryEqual(e[i], t[i])) return !1
        return !0
      }
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.PDFLayerViewer = void 0
      const n = i(14)
      class PDFLayerViewer extends n.BaseTreeViewer {
        constructor(e) {
          super(e)
          this.l10n = e.l10n
          this.eventBus._on('resetlayers', this._resetLayers.bind(this))
          this.eventBus._on('togglelayerstree', this._toggleAllTreeItems.bind(this))
        }

        reset() {
          super.reset()
          this._optionalContentConfig = null
        }

        _dispatchEvent(e) {
          this.eventBus.dispatch('layersloaded', { source: this, layersCount: e })
        }

        _bindLink(e, t) {
          const { groupId: i, input: n } = t
          const setVisibility = () => {
            this._optionalContentConfig.setVisibility(i, n.checked)
            this.eventBus.dispatch('optionalcontentconfig', {
              source: this,
              promise: Promise.resolve(this._optionalContentConfig)
            })
          }
          e.onclick = (t) => {
            if (t.target === n) {
              setVisibility()
              return !0
            }
            if (t.target !== e) return !0
            n.checked = !n.checked
            setVisibility()
            return !1
          }
        }

        async _setNestedName(e, t) {
          const { name: i = null } = t
          if (typeof i !== 'string') {
            e.textContent = await this.l10n.get('additional_layers')
            e.style.fontStyle = 'italic'
          } else e.textContent = this._normalizeTextContent(i)
        }

        _addToggleButton(e, t) {
          const { name: i = null } = t
          super._addToggleButton(e, i === null)
        }

        _toggleAllTreeItems() {
          this._optionalContentConfig && super._toggleAllTreeItems()
        }

        render(e) {
          const { optionalContentConfig: t, pdfDocument: i } = e
          this._optionalContentConfig && this.reset()
          this._optionalContentConfig = t || null
          this._pdfDocument = i || null
          const n = t == null ? void 0 : t.getOrder()
          if (!n) {
            this._dispatchEvent(0)
            return
          }
          const s = document.createDocumentFragment()
          const a = [{ parent: s, groups: n }]
          let r = 0
          let o = !1
          for (; a.length > 0; ) {
            const e = a.shift()
            for (const i of e.groups) {
              const n = document.createElement('div')
              n.className = 'treeItem'
              const s = document.createElement('a')
              n.append(s)
              if (typeof i === 'object') {
                o = !0
                this._addToggleButton(n, i)
                this._setNestedName(s, i)
                const e = document.createElement('div')
                e.className = 'treeItems'
                n.append(e)
                a.push({ parent: e, groups: i.order })
              } else {
                const e = t.getGroup(i)
                const n = document.createElement('input')
                this._bindLink(s, { groupId: i, input: n })
                n.type = 'checkbox'
                n.checked = e.visible
                const a = document.createElement('label')
                a.textContent = this._normalizeTextContent(e.name)
                a.append(n)
                s.append(a)
                r++
              }
              e.parent.append(n)
            }
          }
          this._finishRendering(s, r, o)
        }

        async _resetLayers() {
          if (!this._optionalContentConfig) return
          const e = await this._pdfDocument.getOptionalContentConfig()
          this.eventBus.dispatch('optionalcontentconfig', {
            source: this,
            promise: Promise.resolve(e)
          })
          this.render({ optionalContentConfig: e, pdfDocument: this._pdfDocument })
        }
      }
      t.PDFLayerViewer = PDFLayerViewer
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.PDFOutlineViewer = void 0
      const n = i(14)
      const s = i(5)
      const a = i(1)
      class PDFOutlineViewer extends n.BaseTreeViewer {
        constructor(e) {
          super(e)
          this.linkService = e.linkService
          this.eventBus._on('toggleoutlinetree', this._toggleAllTreeItems.bind(this))
          this.eventBus._on('currentoutlineitem', this._currentOutlineItem.bind(this))
          this.eventBus._on('pagechanging', (e) => {
            this._currentPageNumber = e.pageNumber
          })
          this.eventBus._on('pagesloaded', (e) => {
            this._isPagesLoaded = !!e.pagesCount
            this._currentOutlineItemCapability &&
              !this._currentOutlineItemCapability.settled &&
              this._currentOutlineItemCapability.resolve(this._isPagesLoaded)
          })
          this.eventBus._on('sidebarviewchanged', (e) => {
            this._sidebarView = e.view
          })
        }

        reset() {
          super.reset()
          this._outline = null
          this._pageNumberToDestHashCapability = null
          this._currentPageNumber = 1
          this._isPagesLoaded = null
          this._currentOutlineItemCapability &&
            !this._currentOutlineItemCapability.settled &&
            this._currentOutlineItemCapability.resolve(!1)
          this._currentOutlineItemCapability = null
        }

        _dispatchEvent(e) {
          let t
          this._currentOutlineItemCapability = (0, s.createPromiseCapability)()
          e === 0 ||
          ((t = this._pdfDocument) !== null && void 0 !== t && t.loadingParams.disableAutoFetch)
            ? this._currentOutlineItemCapability.resolve(!1)
            : this._isPagesLoaded !== null &&
              this._currentOutlineItemCapability.resolve(this._isPagesLoaded)
          this.eventBus.dispatch('outlineloaded', {
            source: this,
            outlineCount: e,
            currentOutlineItemPromise: this._currentOutlineItemCapability.promise
          })
        }

        _bindLink(e, t) {
          const { url: i, newWindow: n, dest: s } = t
          const { linkService: a } = this
          if (i) a.addLinkAttributes(e, i, n)
          else {
            e.href = a.getDestinationHash(s)
            e.onclick = (e) => {
              this._updateCurrentTreeItem(e.target.parentNode)
              s && a.goToDestination(s)
              return !1
            }
          }
        }

        _setStyles(e, t) {
          const { bold: i, italic: n } = t
          i && (e.style.fontWeight = 'bold')
          n && (e.style.fontStyle = 'italic')
        }

        _addToggleButton(e, t) {
          const { count: i, items: n } = t
          const s = !1
          if (i < 0) {
            let e = n.length
            if (e > 0) {
              const t = [...n]
              for (; t.length > 0; ) {
                const { count: i, items: n } = t.shift()
                if (i > 0 && n.length > 0) {
                  e += n.length
                  t.push(...n)
                }
              }
            }
            Math.abs(i) === e && (s = !0)
          }
          super._addToggleButton(e, s)
        }

        _toggleAllTreeItems() {
          this._outline && super._toggleAllTreeItems()
        }

        render(e) {
          const { outline: t, pdfDocument: i } = e
          this._outline && this.reset()
          this._outline = t || null
          this._pdfDocument = i || null
          if (!t) {
            this._dispatchEvent(0)
            return
          }
          const n = document.createDocumentFragment()
          const s = [{ parent: n, items: t }]
          let a = 0
          let r = !1
          for (; s.length > 0; ) {
            const e = s.shift()
            for (const t of e.items) {
              const i = document.createElement('div')
              i.className = 'treeItem'
              const n = document.createElement('a')
              this._bindLink(n, t)
              this._setStyles(n, t)
              n.textContent = this._normalizeTextContent(t.title)
              i.append(n)
              if (t.items.length > 0) {
                r = !0
                this._addToggleButton(i, t)
                const e = document.createElement('div')
                e.className = 'treeItems'
                i.append(e)
                s.push({ parent: e, items: t.items })
              }
              e.parent.append(i)
              a++
            }
          }
          this._finishRendering(n, a, r)
        }

        async _currentOutlineItem() {
          if (!this._isPagesLoaded)
            throw new Error('_currentOutlineItem: All pages have not been loaded.')
          if (!this._outline || !this._pdfDocument) return
          const e = await this._getPageNumberToDestHash(this._pdfDocument)
          if (e) {
            this._updateCurrentTreeItem(null)
            if (this._sidebarView === a.SidebarView.OUTLINE)
              for (let t = this._currentPageNumber; t > 0; t--) {
                const i = e.get(t)
                if (!i) continue
                const n = this.container.querySelector(`a[href="${i}"]`)
                if (n) {
                  this._scrollToCurrentTreeItem(n.parentNode)
                  break
                }
              }
          }
        }

        async _getPageNumberToDestHash(e) {
          if (this._pageNumberToDestHashCapability)
            return this._pageNumberToDestHashCapability.promise
          this._pageNumberToDestHashCapability = (0, s.createPromiseCapability)()
          const t = new Map()
          const i = new Map()
          const n = [{ nesting: 0, items: this._outline }]
          for (; n.length > 0; ) {
            const s = n.shift()
            const a = s.nesting
            for (const { dest: r, items: o } of s.items) {
              let s
              let l
              if (typeof r === 'string') {
                s = await e.getDestination(r)
                if (e !== this._pdfDocument) return null
              } else s = r
              if (Array.isArray(s)) {
                const [n] = s
                if (typeof n === 'object' && n !== null) {
                  l = this.linkService._cachedPageNumber(n)
                  if (!l)
                    try {
                      l = (await e.getPageIndex(n)) + 1
                      if (e !== this._pdfDocument) return null
                      this.linkService.cachePageRef(l, n)
                    } catch (e) {}
                } else Number.isInteger(n) && (l = n + 1)
                if (Number.isInteger(l) && (!t.has(l) || a > i.get(l))) {
                  const e = this.linkService.getDestinationHash(r)
                  t.set(l, e)
                  i.set(l, a)
                }
              }
              o.length > 0 && n.push({ nesting: a + 1, items: o })
            }
          }
          this._pageNumberToDestHashCapability.resolve(t.size > 0 ? t : null)
          return this._pageNumberToDestHashCapability.promise
        }
      }
      t.PDFOutlineViewer = PDFOutlineViewer
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.PDFPresentationMode = void 0
      const n = i(1)
      const s = i(5)
      function _classPrivateMethodInitSpec(e, t) {
        _checkPrivateRedeclaration(e, t)
        t.add(e)
      }
      function _classPrivateFieldInitSpec(e, t, i) {
        _checkPrivateRedeclaration(e, t)
        t.set(e, i)
      }
      function _checkPrivateRedeclaration(e, t) {
        if (t.has(e))
          throw new TypeError('Cannot initialize the same private elements twice on an object')
      }
      function _classPrivateFieldGet(e, t) {
        return (function _classApplyDescriptorGet(e, t) {
          if (t.get) return t.get.call(e)
          return t.value
        })(e, _classExtractFieldDescriptor(e, t, 'get'))
      }
      function _classPrivateFieldSet(e, t, i) {
        !(function _classApplyDescriptorSet(e, t, i) {
          if (t.set) t.set.call(e, i)
          else {
            if (!t.writable) throw new TypeError('attempted to set read only private field')
            t.value = i
          }
        })(e, _classExtractFieldDescriptor(e, t, 'set'), i)
        return i
      }
      function _classExtractFieldDescriptor(e, t, i) {
        if (!t.has(e)) throw new TypeError(`attempted to ${i} private field on non-instance`)
        return t.get(e)
      }
      function _classPrivateMethodGet(e, t, i) {
        if (!t.has(e)) throw new TypeError('attempted to get private field on non-instance')
        return i
      }
      const a = 'pdfPresentationMode'
      const r = 'pdfPresentationModeControls'
      const o = Math.PI / 6
      const l = new WeakMap()
      const c = new WeakMap()
      const d = new WeakSet()
      const h = new WeakSet()
      const u = new WeakSet()
      const p = new WeakSet()
      const g = new WeakSet()
      const f = new WeakSet()
      const m = new WeakSet()
      const v = new WeakSet()
      const _ = new WeakSet()
      const b = new WeakSet()
      const w = new WeakSet()
      const P = new WeakSet()
      const y = new WeakSet()
      const S = new WeakSet()
      const A = new WeakSet()
      t.PDFPresentationMode = class PDFPresentationMode {
        constructor(e) {
          const { container: t, pdfViewer: i, eventBus: s } = e
          _classPrivateMethodInitSpec(this, A)
          _classPrivateMethodInitSpec(this, S)
          _classPrivateMethodInitSpec(this, y)
          _classPrivateMethodInitSpec(this, P)
          _classPrivateMethodInitSpec(this, w)
          _classPrivateMethodInitSpec(this, b)
          _classPrivateMethodInitSpec(this, _)
          _classPrivateMethodInitSpec(this, v)
          _classPrivateMethodInitSpec(this, m)
          _classPrivateMethodInitSpec(this, f)
          _classPrivateMethodInitSpec(this, g)
          _classPrivateMethodInitSpec(this, p)
          _classPrivateMethodInitSpec(this, u)
          _classPrivateMethodInitSpec(this, h)
          _classPrivateMethodInitSpec(this, d)
          _classPrivateFieldInitSpec(this, l, {
            writable: !0,
            value: n.PresentationModeState.UNKNOWN
          })
          _classPrivateFieldInitSpec(this, c, { writable: !0, value: null })
          this.container = t
          this.pdfViewer = i
          this.eventBus = s
          this.contextMenuOpen = !1
          this.mouseScrollTimeStamp = 0
          this.mouseScrollDelta = 0
          this.touchSwipeState = null
        }

        async request() {
          const { container: e, pdfViewer: t } = this
          if (this.active || !t.pagesCount || !e.requestFullscreen) return !1
          _classPrivateMethodGet(this, S, _addFullscreenChangeListeners2).call(this)
          _classPrivateMethodGet(this, h, _notifyStateChange2).call(
            this,
            n.PresentationModeState.CHANGING
          )
          const i = e.requestFullscreen()
          _classPrivateFieldSet(this, c, {
            pageNumber: t.currentPageNumber,
            scaleValue: t.currentScaleValue,
            scrollMode: t.scrollMode,
            spreadMode: null,
            annotationEditorMode: null
          })
          if (!(t.spreadMode === n.SpreadMode.NONE || (t.pageViewsReady && t.hasEqualPageSizes))) {
            console.warn(
              'Ignoring Spread modes when entering PresentationMode, since the document may contain varying page sizes.'
            )
            _classPrivateFieldGet(this, c).spreadMode = t.spreadMode
          }
          t.annotationEditorMode !== s.AnnotationEditorType.DISABLE &&
            (_classPrivateFieldGet(this, c).annotationEditorMode = t.annotationEditorMode)
          try {
            await i
            t.focus()
            return !0
          } catch (e) {
            _classPrivateMethodGet(this, A, _removeFullscreenChangeListeners2).call(this)
            _classPrivateMethodGet(this, h, _notifyStateChange2).call(
              this,
              n.PresentationModeState.NORMAL
            )
          }
          return !1
        }

        get active() {
          return (
            _classPrivateFieldGet(this, l) === n.PresentationModeState.CHANGING ||
            _classPrivateFieldGet(this, l) === n.PresentationModeState.FULLSCREEN
          )
        }
      }
      function _mouseWheel2(e) {
        if (!this.active) return
        e.preventDefault()
        const t = (0, n.normalizeWheelEventDelta)(e)
        const i = Date.now()
        const s = this.mouseScrollTimeStamp
        if (!(i > s && i - s < 50)) {
          ;((this.mouseScrollDelta > 0 && t < 0) || (this.mouseScrollDelta < 0 && t > 0)) &&
            _classPrivateMethodGet(this, _, _resetMouseScrollState2).call(this)
          this.mouseScrollDelta += t
          if (Math.abs(this.mouseScrollDelta) >= 0.1) {
            const e = this.mouseScrollDelta
            _classPrivateMethodGet(this, _, _resetMouseScrollState2).call(this)
            ;(e > 0 ? this.pdfViewer.previousPage() : this.pdfViewer.nextPage()) &&
              (this.mouseScrollTimeStamp = i)
          }
        }
      }
      function _notifyStateChange2(e) {
        _classPrivateFieldSet(this, l, e)
        this.eventBus.dispatch('presentationmodechanged', { source: this, state: e })
      }
      function _enter2() {
        _classPrivateMethodGet(this, h, _notifyStateChange2).call(
          this,
          n.PresentationModeState.FULLSCREEN
        )
        this.container.classList.add(a)
        setTimeout(() => {
          this.pdfViewer.scrollMode = n.ScrollMode.PAGE
          _classPrivateFieldGet(this, c).spreadMode !== null &&
            (this.pdfViewer.spreadMode = n.SpreadMode.NONE)
          this.pdfViewer.currentPageNumber = _classPrivateFieldGet(this, c).pageNumber
          this.pdfViewer.currentScaleValue = 'page-fit'
          _classPrivateFieldGet(this, c).annotationEditorMode !== null &&
            (this.pdfViewer.annotationEditorMode = s.AnnotationEditorType.NONE)
        }, 0)
        _classPrivateMethodGet(this, w, _addWindowListeners2).call(this)
        _classPrivateMethodGet(this, m, _showControls2).call(this)
        this.contextMenuOpen = !1
        window.getSelection().removeAllRanges()
      }
      function _exit2() {
        const e = this.pdfViewer.currentPageNumber
        this.container.classList.remove(a)
        setTimeout(() => {
          _classPrivateMethodGet(this, A, _removeFullscreenChangeListeners2).call(this)
          _classPrivateMethodGet(this, h, _notifyStateChange2).call(
            this,
            n.PresentationModeState.NORMAL
          )
          this.pdfViewer.scrollMode = _classPrivateFieldGet(this, c).scrollMode
          _classPrivateFieldGet(this, c).spreadMode !== null &&
            (this.pdfViewer.spreadMode = _classPrivateFieldGet(this, c).spreadMode)
          this.pdfViewer.currentScaleValue = _classPrivateFieldGet(this, c).scaleValue
          this.pdfViewer.currentPageNumber = e
          _classPrivateFieldGet(this, c).annotationEditorMode !== null &&
            (this.pdfViewer.annotationEditorMode = _classPrivateFieldGet(
              this,
              c
            ).annotationEditorMode)
          _classPrivateFieldSet(this, c, null)
        }, 0)
        _classPrivateMethodGet(this, P, _removeWindowListeners2).call(this)
        _classPrivateMethodGet(this, v, _hideControls2).call(this)
        _classPrivateMethodGet(this, _, _resetMouseScrollState2).call(this)
        this.contextMenuOpen = !1
      }
      function _mouseDown2(e) {
        if (this.contextMenuOpen) {
          this.contextMenuOpen = !1
          e.preventDefault()
        } else if (e.button === 0) {
          if (!(e.target.href && e.target.classList.contains('internalLink'))) {
            e.preventDefault()
            e.shiftKey ? this.pdfViewer.previousPage() : this.pdfViewer.nextPage()
          }
        }
      }
      function _contextMenu2() {
        this.contextMenuOpen = !0
      }
      function _showControls2() {
        this.controlsTimeout ? clearTimeout(this.controlsTimeout) : this.container.classList.add(r)
        this.controlsTimeout = setTimeout(() => {
          this.container.classList.remove(r)
          delete this.controlsTimeout
        }, 3e3)
      }
      function _hideControls2() {
        if (this.controlsTimeout) {
          clearTimeout(this.controlsTimeout)
          this.container.classList.remove(r)
          delete this.controlsTimeout
        }
      }
      function _resetMouseScrollState2() {
        this.mouseScrollTimeStamp = 0
        this.mouseScrollDelta = 0
      }
      function _touchSwipe2(e) {
        if (this.active)
          if (e.touches.length > 1) this.touchSwipeState = null
          else
            switch (e.type) {
              case 'touchstart':
                this.touchSwipeState = {
                  startX: e.touches[0].pageX,
                  startY: e.touches[0].pageY,
                  endX: e.touches[0].pageX,
                  endY: e.touches[0].pageY
                }
                break
              case 'touchmove':
                if (this.touchSwipeState === null) return
                this.touchSwipeState.endX = e.touches[0].pageX
                this.touchSwipeState.endY = e.touches[0].pageY
                e.preventDefault()
                break
              case 'touchend':
                if (this.touchSwipeState === null) return
                let t = 0
                const i = this.touchSwipeState.endX - this.touchSwipeState.startX
                const n = this.touchSwipeState.endY - this.touchSwipeState.startY
                const s = Math.abs(Math.atan2(n, i))
                Math.abs(i) > 50 && (s <= o || s >= Math.PI - o)
                  ? (t = i)
                  : Math.abs(n) > 50 && Math.abs(s - Math.PI / 2) <= o && (t = n)
                t > 0 ? this.pdfViewer.previousPage() : t < 0 && this.pdfViewer.nextPage()
            }
      }
      function _addWindowListeners2() {
        this.showControlsBind = _classPrivateMethodGet(this, m, _showControls2).bind(this)
        this.mouseDownBind = _classPrivateMethodGet(this, g, _mouseDown2).bind(this)
        this.mouseWheelBind = _classPrivateMethodGet(this, d, _mouseWheel2).bind(this)
        this.resetMouseScrollStateBind = _classPrivateMethodGet(
          this,
          _,
          _resetMouseScrollState2
        ).bind(this)
        this.contextMenuBind = _classPrivateMethodGet(this, f, _contextMenu2).bind(this)
        this.touchSwipeBind = _classPrivateMethodGet(this, b, _touchSwipe2).bind(this)
        window.addEventListener('mousemove', this.showControlsBind)
        window.addEventListener('mousedown', this.mouseDownBind)
        window.addEventListener('wheel', this.mouseWheelBind, { passive: !1 })
        window.addEventListener('keydown', this.resetMouseScrollStateBind)
        window.addEventListener('contextmenu', this.contextMenuBind)
        window.addEventListener('touchstart', this.touchSwipeBind)
        window.addEventListener('touchmove', this.touchSwipeBind)
        window.addEventListener('touchend', this.touchSwipeBind)
      }
      function _removeWindowListeners2() {
        window.removeEventListener('mousemove', this.showControlsBind)
        window.removeEventListener('mousedown', this.mouseDownBind)
        window.removeEventListener('wheel', this.mouseWheelBind, { passive: !1 })
        window.removeEventListener('keydown', this.resetMouseScrollStateBind)
        window.removeEventListener('contextmenu', this.contextMenuBind)
        window.removeEventListener('touchstart', this.touchSwipeBind)
        window.removeEventListener('touchmove', this.touchSwipeBind)
        window.removeEventListener('touchend', this.touchSwipeBind)
        delete this.showControlsBind
        delete this.mouseDownBind
        delete this.mouseWheelBind
        delete this.resetMouseScrollStateBind
        delete this.contextMenuBind
        delete this.touchSwipeBind
      }
      function _fullscreenChange2() {
        document.fullscreenElement
          ? _classPrivateMethodGet(this, u, _enter2).call(this)
          : _classPrivateMethodGet(this, p, _exit2).call(this)
      }
      function _addFullscreenChangeListeners2() {
        this.fullscreenChangeBind = _classPrivateMethodGet(this, y, _fullscreenChange2).bind(this)
        window.addEventListener('fullscreenchange', this.fullscreenChangeBind)
      }
      function _removeFullscreenChangeListeners2() {
        window.removeEventListener('fullscreenchange', this.fullscreenChangeBind)
        delete this.fullscreenChangeBind
      }
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.PDFRenderingQueue = void 0
      const n = i(5)
      const s = i(1)
      t.PDFRenderingQueue = class PDFRenderingQueue {
        constructor() {
          this.pdfViewer = null
          this.pdfThumbnailViewer = null
          this.onIdle = null
          this.highestPriorityPage = null
          this.idleTimeout = null
          this.printing = !1
          this.isThumbnailViewEnabled = !1
        }

        setViewer(e) {
          this.pdfViewer = e
        }

        setThumbnailViewer(e) {
          this.pdfThumbnailViewer = e
        }

        isHighestPriority(e) {
          return this.highestPriorityPage === e.renderingId
        }

        hasViewer() {
          return !!this.pdfViewer
        }

        renderHighestPriority(e) {
          let t
          if (this.idleTimeout) {
            clearTimeout(this.idleTimeout)
            this.idleTimeout = null
          }
          this.pdfViewer.forceRendering(e) ||
            (this.isThumbnailViewEnabled &&
              (t = this.pdfThumbnailViewer) !== null &&
              void 0 !== t &&
              t.forceRendering()) ||
            this.printing ||
            (this.onIdle && (this.idleTimeout = setTimeout(this.onIdle.bind(this), 3e4)))
        }

        getHighestPriority(e, t, i) {
          const n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]
          const s = e.views
          const a = s.length
          if (a === 0) return null
          for (let e = 0; e < a; e++) {
            const t = s[e].view
            if (!this.isViewFinished(t)) return t
          }
          const r = e.first.id
          const o = e.last.id
          if (o - r + 1 > a) {
            const n = e.ids
            for (let e = 1, s = o - r; e < s; e++) {
              const s = i ? r + e : o - e
              if (n.has(s)) continue
              const a = t[s - 1]
              if (!this.isViewFinished(a)) return a
            }
          }
          let l = i ? o : r - 2
          let c = t[l]
          if (c && !this.isViewFinished(c)) return c
          if (n) {
            l += i ? 1 : -1
            c = t[l]
            if (c && !this.isViewFinished(c)) return c
          }
          return null
        }

        isViewFinished(e) {
          return e.renderingState === s.RenderingStates.FINISHED
        }

        renderView(e) {
          switch (e.renderingState) {
            case s.RenderingStates.FINISHED:
              return !1
            case s.RenderingStates.PAUSED:
              this.highestPriorityPage = e.renderingId
              e.resume()
              break
            case s.RenderingStates.RUNNING:
              this.highestPriorityPage = e.renderingId
              break
            case s.RenderingStates.INITIAL:
              this.highestPriorityPage = e.renderingId
              e.draw()
                .finally(() => {
                  this.renderHighestPriority()
                })
                .catch((e) => {
                  e instanceof n.RenderingCancelledException || console.error(`renderView: "${e}"`)
                })
          }
          return !0
        }
      }
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.PDFScriptingManager = void 0
      const n = i(1)
      const s = i(5)
      t.PDFScriptingManager = class PDFScriptingManager {
        constructor(e) {
          const {
            eventBus: t,
            sandboxBundleSrc: i = null,
            scriptingFactory: n = null,
            docPropertiesLookup: s = null
          } = e
          this._pdfDocument = null
          this._pdfViewer = null
          this._closeCapability = null
          this._destroyCapability = null
          this._scripting = null
          this._mouseState = Object.create(null)
          this._ready = !1
          this._eventBus = t
          this._sandboxBundleSrc = i
          this._scriptingFactory = n
          this._docPropertiesLookup = s
        }

        setViewer(e) {
          this._pdfViewer = e
        }

        async setDocument(e) {
          let t
          this._pdfDocument && (await this._destroyScripting())
          this._pdfDocument = e
          if (!e) return
          const [i, n, s] = await Promise.all([
            e.getFieldObjects(),
            e.getCalculationOrderIds(),
            e.getJSActions()
          ])
          if (i || s) {
            if (e === this._pdfDocument) {
              try {
                this._scripting = this._createScripting()
              } catch (e) {
                console.error(
                  `PDFScriptingManager.setDocument: "${e == null ? void 0 : e.message}".`
                )
                await this._destroyScripting()
                return
              }
              this._internalEvents.set('updatefromsandbox', (e) => {
                ;(e == null ? void 0 : e.source) === window && this._updateFromSandbox(e.detail)
              })
              this._internalEvents.set('dispatcheventinsandbox', (e) => {
                let t
                ;(t = this._scripting) === null ||
                  void 0 === t ||
                  t.dispatchEventInSandbox(e.detail)
              })
              this._internalEvents.set('pagechanging', (e) => {
                const { pageNumber: t, previous: i } = e
                if (t !== i) {
                  this._dispatchPageClose(i)
                  this._dispatchPageOpen(t)
                }
              })
              this._internalEvents.set('pagerendered', (e) => {
                const { pageNumber: t } = e
                this._pageOpenPending.has(t) &&
                  t === this._pdfViewer.currentPageNumber &&
                  this._dispatchPageOpen(t)
              })
              this._internalEvents.set('pagesdestroy', async (e) => {
                let t
                let i
                await this._dispatchPageClose(this._pdfViewer.currentPageNumber)
                ;(await ((t = this._scripting) === null || void 0 === t
                  ? void 0
                  : t.dispatchEventInSandbox({ id: 'doc', name: 'WillClose' }))(
                  (i = this._closeCapability)
                )) === null ||
                  void 0 === i ||
                  i.resolve()
              })
              this._domEvents.set('mousedown', (e) => {
                this._mouseState.isDown = !0
              })
              this._domEvents.set('mouseup', (e) => {
                this._mouseState.isDown = !1
              })
              for (const [e, t] of this._internalEvents) this._eventBus._on(e, t)
              for (const [e, t] of this._domEvents) window.addEventListener(e, t, !0)
              try {
                const t = await this._getDocProperties()
                if (e !== this._pdfDocument) return
                await this._scripting.createSandbox({
                  objects: i,
                  calculationOrder: n,
                  appInfo: { platform: navigator.platform, language: navigator.language },
                  docInfo: { ...t, actions: s }
                })
                this._eventBus.dispatch('sandboxcreated', { source: this })
              } catch (e) {
                console.error(
                  `PDFScriptingManager.setDocument: "${e == null ? void 0 : e.message}".`
                )
                await this._destroyScripting()
                return
              }
              await ((t = this._scripting) === null || void 0 === t
                ? void 0
                : t.dispatchEventInSandbox({ id: 'doc', name: 'Open' }))
              await this._dispatchPageOpen(this._pdfViewer.currentPageNumber, !0)
              Promise.resolve().then(() => {
                e === this._pdfDocument && (this._ready = !0)
              })
            }
          } else await this._destroyScripting()
        }

        async dispatchWillSave(e) {
          let t
          return (t = this._scripting) === null || void 0 === t
            ? void 0
            : t.dispatchEventInSandbox({ id: 'doc', name: 'WillSave' })
        }

        async dispatchDidSave(e) {
          let t
          return (t = this._scripting) === null || void 0 === t
            ? void 0
            : t.dispatchEventInSandbox({ id: 'doc', name: 'DidSave' })
        }

        async dispatchWillPrint(e) {
          let t
          return (t = this._scripting) === null || void 0 === t
            ? void 0
            : t.dispatchEventInSandbox({ id: 'doc', name: 'WillPrint' })
        }

        async dispatchDidPrint(e) {
          let t
          return (t = this._scripting) === null || void 0 === t
            ? void 0
            : t.dispatchEventInSandbox({ id: 'doc', name: 'DidPrint' })
        }

        get mouseState() {
          return this._mouseState
        }

        get destroyPromise() {
          let e
          return (
            ((e = this._destroyCapability) === null || void 0 === e ? void 0 : e.promise) || null
          )
        }

        get ready() {
          return this._ready
        }

        get _internalEvents() {
          return (0, s.shadow)(this, '_internalEvents', new Map())
        }

        get _domEvents() {
          return (0, s.shadow)(this, '_domEvents', new Map())
        }

        get _pageOpenPending() {
          return (0, s.shadow)(this, '_pageOpenPending', new Set())
        }

        get _visitedPages() {
          return (0, s.shadow)(this, '_visitedPages', new Map())
        }

        async _updateFromSandbox(e) {
          const t =
            this._pdfViewer.isInPresentationMode || this._pdfViewer.isChangingPresentationMode
          const { id: i, siblings: s, command: a, value: r } = e
          if (!i) {
            switch (a) {
              case 'clear':
                console.clear()
                break
              case 'error':
                console.error(r)
                break
              case 'layout':
                if (t) return
                const e = (0, n.apiPageLayoutToViewerModes)(r)
                this._pdfViewer.spreadMode = e.spreadMode
                break
              case 'page-num':
                this._pdfViewer.currentPageNumber = r + 1
                break
              case 'print':
                await this._pdfViewer.pagesPromise
                this._eventBus.dispatch('print', { source: this })
                break
              case 'println':
                console.log(r)
                break
              case 'zoom':
                if (t) return
                this._pdfViewer.currentScaleValue = r
                break
              case 'SaveAs':
                this._eventBus.dispatch('download', { source: this })
                break
              case 'FirstPage':
                this._pdfViewer.currentPageNumber = 1
                break
              case 'LastPage':
                this._pdfViewer.currentPageNumber = this._pdfViewer.pagesCount
                break
              case 'NextPage':
                this._pdfViewer.nextPage()
                break
              case 'PrevPage':
                this._pdfViewer.previousPage()
                break
              case 'ZoomViewIn':
                if (t) return
                this._pdfViewer.increaseScale()
                break
              case 'ZoomViewOut':
                if (t) return
                this._pdfViewer.decreaseScale()
            }
            return
          }
          if (t && e.focus) return
          delete e.id
          delete e.siblings
          const o = s ? [i, ...s] : [i]
          for (const t of o) {
            const i = document.querySelector(`[data-element-id="${t}"]`)
            if (i) i.dispatchEvent(new CustomEvent('updatefromsandbox', { detail: e }))
            else {
              var l
              ;(l = this._pdfDocument) === null ||
                void 0 === l ||
                l.annotationStorage.setValue(t, e)
            }
          }
        }

        async _dispatchPageOpen(e) {
          const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
          const i = this._pdfDocument
          const a = this._visitedPages
          t && (this._closeCapability = (0, s.createPromiseCapability)())
          if (!this._closeCapability) return
          const r = this._pdfViewer.getPageView(e - 1)
          if ((r == null ? void 0 : r.renderingState) !== n.RenderingStates.FINISHED) {
            this._pageOpenPending.add(e)
            return
          }
          this._pageOpenPending.delete(e)
          const o = (async () => {
            let t
            let n
            const s = await (a.has(e)
              ? null
              : (t = r.pdfPage) === null || void 0 === t
              ? void 0
              : t.getJSActions())
            i === this._pdfDocument &&
              (await ((n = this._scripting) === null || void 0 === n
                ? void 0
                : n.dispatchEventInSandbox({
                    id: 'page',
                    name: 'PageOpen',
                    pageNumber: e,
                    actions: s
                  })))
          })()
          a.set(e, o)
        }

        async _dispatchPageClose(e) {
          let t
          const i = this._pdfDocument
          const n = this._visitedPages
          if (!this._closeCapability) return
          if (this._pageOpenPending.has(e)) return
          const s = n.get(e)
          if (s) {
            n.set(e, null)
            await s
            i === this._pdfDocument &&
              (await ((t = this._scripting) === null || void 0 === t
                ? void 0
                : t.dispatchEventInSandbox({ id: 'page', name: 'PageClose', pageNumber: e })))
          }
        }

        async _getDocProperties() {
          if (this._docPropertiesLookup) return this._docPropertiesLookup(this._pdfDocument)
          throw new Error('_getDocProperties: Unable to lookup properties.')
        }

        _createScripting() {
          this._destroyCapability = (0, s.createPromiseCapability)()
          if (this._scripting) throw new Error('_createScripting: Scripting already exists.')
          if (this._scriptingFactory)
            return this._scriptingFactory.createScripting({
              sandboxBundleSrc: this._sandboxBundleSrc
            })
          throw new Error('_createScripting: Cannot create scripting.')
        }

        async _destroyScripting() {
          let e
          if (this._scripting) {
            if (this._closeCapability) {
              await Promise.race([
                this._closeCapability.promise,
                new Promise((e) => {
                  setTimeout(e, 1e3)
                })
              ]).catch((e) => {})
              this._closeCapability = null
            }
            this._pdfDocument = null
            try {
              await this._scripting.destroySandbox()
            } catch (e) {}
            for (const [e, t] of this._internalEvents) this._eventBus._off(e, t)
            this._internalEvents.clear()
            for (const [e, t] of this._domEvents) window.removeEventListener(e, t, !0)
            this._domEvents.clear()
            this._pageOpenPending.clear()
            this._visitedPages.clear()
            this._scripting = null
            delete this._mouseState.isDown
            this._ready = !1((e = this._destroyCapability)) === null || void 0 === e || e.resolve()
          } else {
            let t
            this._pdfDocument =
              null((t = this._destroyCapability)) === null || void 0 === t || t.resolve()
          }
        }
      }
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.PDFSidebar = void 0
      const n = i(1)
      function _classPrivateMethodInitSpec(e, t) {
        !(function _checkPrivateRedeclaration(e, t) {
          if (t.has(e))
            throw new TypeError('Cannot initialize the same private elements twice on an object')
        })(e, t)
        t.add(e)
      }
      function _classPrivateMethodGet(e, t, i) {
        if (!t.has(e)) throw new TypeError('attempted to get private field on non-instance')
        return i
      }
      const s = 'pdfSidebarNotification'
      const a = new WeakSet()
      const r = new WeakSet()
      const o = new WeakSet()
      const l = new WeakSet()
      const c = new WeakSet()
      const d = new WeakSet()
      t.PDFSidebar = class PDFSidebar {
        constructor(e) {
          const { elements: t, pdfViewer: i, pdfThumbnailViewer: s, eventBus: h, l10n: u } = e
          _classPrivateMethodInitSpec(this, d)
          _classPrivateMethodInitSpec(this, c)
          _classPrivateMethodInitSpec(this, l)
          _classPrivateMethodInitSpec(this, o)
          _classPrivateMethodInitSpec(this, r)
          _classPrivateMethodInitSpec(this, a)
          this.isOpen = !1
          this.active = n.SidebarView.THUMBS
          this.isInitialViewSet = !1
          this.isInitialEventDispatched = !1
          this.onToggled = null
          this.pdfViewer = i
          this.pdfThumbnailViewer = s
          this.outerContainer = t.outerContainer
          this.sidebarContainer = t.sidebarContainer
          this.toggleButton = t.toggleButton
          this.thumbnailButton = t.thumbnailButton
          this.outlineButton = t.outlineButton
          this.attachmentsButton = t.attachmentsButton
          this.layersButton = t.layersButton
          this.thumbnailView = t.thumbnailView
          this.outlineView = t.outlineView
          this.attachmentsView = t.attachmentsView
          this.layersView = t.layersView
          this._outlineOptionsContainer = t.outlineOptionsContainer
          this._currentOutlineItemButton = t.currentOutlineItemButton
          this.eventBus = h
          this.l10n = u
          _classPrivateMethodGet(this, d, _addEventListeners2).call(this)
        }

        reset() {
          this.isInitialViewSet = !1
          this.isInitialEventDispatched = !1
          _classPrivateMethodGet(this, c, _hideUINotification2).call(this, !0)
          this.switchView(n.SidebarView.THUMBS)
          this.outlineButton.disabled = !1
          this.attachmentsButton.disabled = !1
          this.layersButton.disabled = !1
          this._currentOutlineItemButton.disabled = !0
        }

        get visibleView() {
          return this.isOpen ? this.active : n.SidebarView.NONE
        }

        setInitialView() {
          const e =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : n.SidebarView.NONE
          if (!this.isInitialViewSet) {
            this.isInitialViewSet = !0
            if (e !== n.SidebarView.NONE && e !== n.SidebarView.UNKNOWN) {
              this.switchView(e, !0)
              this.isInitialEventDispatched ||
                _classPrivateMethodGet(this, a, _dispatchEvent2).call(this)
            } else _classPrivateMethodGet(this, a, _dispatchEvent2).call(this)
          }
        }

        switchView(e) {
          const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
          const i = e !== this.active
          let s = !1
          switch (e) {
            case n.SidebarView.NONE:
              this.isOpen && this.close()
              return
            case n.SidebarView.THUMBS:
              this.isOpen && i && (s = !0)
              break
            case n.SidebarView.OUTLINE:
              if (this.outlineButton.disabled) return
              break
            case n.SidebarView.ATTACHMENTS:
              if (this.attachmentsButton.disabled) return
              break
            case n.SidebarView.LAYERS:
              if (this.layersButton.disabled) return
              break
            default:
              console.error(`PDFSidebar.switchView: "${e}" is not a valid view.`)
              return
          }
          this.active = e
          const l = e === n.SidebarView.THUMBS
          const c = e === n.SidebarView.OUTLINE
          const d = e === n.SidebarView.ATTACHMENTS
          const h = e === n.SidebarView.LAYERS
          this.thumbnailButton.classList.toggle('toggled', l)
          this.outlineButton.classList.toggle('toggled', c)
          this.attachmentsButton.classList.toggle('toggled', d)
          this.layersButton.classList.toggle('toggled', h)
          this.thumbnailButton.setAttribute('aria-checked', l)
          this.outlineButton.setAttribute('aria-checked', c)
          this.attachmentsButton.setAttribute('aria-checked', d)
          this.layersButton.setAttribute('aria-checked', h)
          this.thumbnailView.classList.toggle('hidden', !l)
          this.outlineView.classList.toggle('hidden', !c)
          this.attachmentsView.classList.toggle('hidden', !d)
          this.layersView.classList.toggle('hidden', !h)
          this._outlineOptionsContainer.classList.toggle('hidden', !c)
          if (!t || this.isOpen) {
            if (s) {
              _classPrivateMethodGet(this, o, _updateThumbnailViewer2).call(this)
              _classPrivateMethodGet(this, r, _forceRendering2).call(this)
            }
            i && _classPrivateMethodGet(this, a, _dispatchEvent2).call(this)
          } else this.open()
        }

        open() {
          if (!this.isOpen) {
            this.isOpen = !0
            this.toggleButton.classList.add('toggled')
            this.toggleButton.setAttribute('aria-expanded', 'true')
            this.outerContainer.classList.add('sidebarMoving', 'sidebarOpen')
            this.active === n.SidebarView.THUMBS &&
              _classPrivateMethodGet(this, o, _updateThumbnailViewer2).call(this)
            _classPrivateMethodGet(this, r, _forceRendering2).call(this)
            _classPrivateMethodGet(this, a, _dispatchEvent2).call(this)
            _classPrivateMethodGet(this, c, _hideUINotification2).call(this)
          }
        }

        close() {
          if (this.isOpen) {
            this.isOpen = !1
            this.toggleButton.classList.remove('toggled')
            this.toggleButton.setAttribute('aria-expanded', 'false')
            this.outerContainer.classList.add('sidebarMoving')
            this.outerContainer.classList.remove('sidebarOpen')
            _classPrivateMethodGet(this, r, _forceRendering2).call(this)
            _classPrivateMethodGet(this, a, _dispatchEvent2).call(this)
          }
        }

        toggle() {
          this.isOpen ? this.close() : this.open()
        }
      }
      function _dispatchEvent2() {
        this.isInitialViewSet &&
          !this.isInitialEventDispatched &&
          (this.isInitialEventDispatched = !0)
        this.eventBus.dispatch('sidebarviewchanged', { source: this, view: this.visibleView })
      }
      function _forceRendering2() {
        if (this.onToggled) this.onToggled()
        else {
          this.pdfViewer.forceRendering()
          this.pdfThumbnailViewer.forceRendering()
        }
      }
      function _updateThumbnailViewer2() {
        const { pdfViewer: e, pdfThumbnailViewer: t } = this
        const i = e.pagesCount
        for (let s = 0; s < i; s++) {
          const i = e.getPageView(s)
          if ((i == null ? void 0 : i.renderingState) === n.RenderingStates.FINISHED) {
            t.getThumbnail(s).setImage(i)
          }
        }
        t.scrollThumbnailIntoView(e.currentPageNumber)
      }
      function _showUINotification2() {
        this.l10n.get('toggle_sidebar_notification2.title').then((e) => {
          this.toggleButton.title = e
        })
        this.isOpen || this.toggleButton.classList.add(s)
      }
      function _hideUINotification2() {
        const e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
        ;(this.isOpen || e) && this.toggleButton.classList.remove(s)
        e &&
          this.l10n.get('toggle_sidebar.title').then((e) => {
            this.toggleButton.title = e
          })
      }
      function _addEventListeners2() {
        this.sidebarContainer.addEventListener('transitionend', (e) => {
          e.target === this.sidebarContainer &&
            this.outerContainer.classList.remove('sidebarMoving')
        })
        this.toggleButton.addEventListener('click', () => {
          this.toggle()
        })
        this.thumbnailButton.addEventListener('click', () => {
          this.switchView(n.SidebarView.THUMBS)
        })
        this.outlineButton.addEventListener('click', () => {
          this.switchView(n.SidebarView.OUTLINE)
        })
        this.outlineButton.addEventListener('dblclick', () => {
          this.eventBus.dispatch('toggleoutlinetree', { source: this })
        })
        this.attachmentsButton.addEventListener('click', () => {
          this.switchView(n.SidebarView.ATTACHMENTS)
        })
        this.layersButton.addEventListener('click', () => {
          this.switchView(n.SidebarView.LAYERS)
        })
        this.layersButton.addEventListener('dblclick', () => {
          this.eventBus.dispatch('resetlayers', { source: this })
        })
        this._currentOutlineItemButton.addEventListener('click', () => {
          this.eventBus.dispatch('currentoutlineitem', { source: this })
        })
        const onTreeLoaded = (e, t, i) => {
          t.disabled = !e
          e
            ? _classPrivateMethodGet(this, l, _showUINotification2).call(this)
            : this.active === i && this.switchView(n.SidebarView.THUMBS)
        }
        this.eventBus._on('outlineloaded', (e) => {
          onTreeLoaded(e.outlineCount, this.outlineButton, n.SidebarView.OUTLINE)
          e.currentOutlineItemPromise.then((e) => {
            this.isInitialViewSet && (this._currentOutlineItemButton.disabled = !e)
          })
        })
        this.eventBus._on('attachmentsloaded', (e) => {
          onTreeLoaded(e.attachmentsCount, this.attachmentsButton, n.SidebarView.ATTACHMENTS)
        })
        this.eventBus._on('layersloaded', (e) => {
          onTreeLoaded(e.layersCount, this.layersButton, n.SidebarView.LAYERS)
        })
        this.eventBus._on('presentationmodechanged', (e) => {
          e.state === n.PresentationModeState.NORMAL &&
            this.visibleView === n.SidebarView.THUMBS &&
            _classPrivateMethodGet(this, o, _updateThumbnailViewer2).call(this)
        })
      }
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.PDFSidebarResizer = void 0
      const n = i(1)
      const s = 'sidebarResizing'
      t.PDFSidebarResizer = class PDFSidebarResizer {
        constructor(e, t, i) {
          this.isRTL = !1
          this.sidebarOpen = !1
          this._width = null
          this._outerContainerWidth = null
          this._boundEvents = Object.create(null)
          this.outerContainer = e.outerContainer
          this.resizer = e.resizer
          this.eventBus = t
          i.getDirection().then((e) => {
            this.isRTL = e === 'rtl'
          })
          this._addEventListeners()
        }

        get outerContainerWidth() {
          return (
            this._outerContainerWidth ||
            (this._outerContainerWidth = this.outerContainer.clientWidth)
          )
        }

        _updateWidth() {
          let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
          const t = Math.floor(this.outerContainerWidth / 2)
          e > t && (e = t)
          e < 200 && (e = 200)
          if (e === this._width) return !1
          this._width = e
          n.docStyle.setProperty('--sidebar-width', `${e}px`)
          return !0
        }

        _mouseMove(e) {
          let t = e.clientX
          this.isRTL && (t = this.outerContainerWidth - t)
          this._updateWidth(t)
        }

        _mouseUp(e) {
          this.outerContainer.classList.remove(s)
          this.eventBus.dispatch('resize', { source: this })
          const t = this._boundEvents
          window.removeEventListener('mousemove', t.mouseMove)
          window.removeEventListener('mouseup', t.mouseUp)
        }

        _addEventListeners() {
          const e = this._boundEvents
          e.mouseMove = this._mouseMove.bind(this)
          e.mouseUp = this._mouseUp.bind(this)
          this.resizer.addEventListener('mousedown', (t) => {
            if (t.button === 0) {
              this.outerContainer.classList.add(s)
              window.addEventListener('mousemove', e.mouseMove)
              window.addEventListener('mouseup', e.mouseUp)
            }
          })
          this.eventBus._on('sidebarviewchanged', (e) => {
            this.sidebarOpen = !(e == null || !e.view)
          })
          this.eventBus._on('resize', (e) => {
            if ((e == null ? void 0 : e.source) !== window) return
            this._outerContainerWidth = null
            if (!this._width) return
            if (!this.sidebarOpen) {
              this._updateWidth(this._width)
              return
            }
            this.outerContainer.classList.add(s)
            const t = this._updateWidth(this._width)
            Promise.resolve().then(() => {
              this.outerContainer.classList.remove(s)
              t && this.eventBus.dispatch('resize', { source: this })
            })
          })
        }
      }
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.PDFThumbnailViewer = void 0
      const n = i(1)
      const s = i(28)
      function _classPrivateMethodInitSpec(e, t) {
        !(function _checkPrivateRedeclaration(e, t) {
          if (t.has(e))
            throw new TypeError('Cannot initialize the same private elements twice on an object')
        })(e, t)
        t.add(e)
      }
      function _classPrivateMethodGet(e, t, i) {
        if (!t.has(e)) throw new TypeError('attempted to get private field on non-instance')
        return i
      }
      const a = 'selected'
      const r = new WeakSet()
      const o = new WeakSet()
      t.PDFThumbnailViewer = class PDFThumbnailViewer {
        constructor(e) {
          const {
            container: t,
            eventBus: i,
            linkService: s,
            renderingQueue: a,
            l10n: l,
            pageColors: c
          } = e
          _classPrivateMethodInitSpec(this, o)
          _classPrivateMethodInitSpec(this, r)
          this.container = t
          this.linkService = s
          this.renderingQueue = a
          this.l10n = l
          this.pageColors = c || null
          if (
            this.pageColors &&
            (!CSS.supports('color', this.pageColors.background) ||
              !CSS.supports('color', this.pageColors.foreground))
          ) {
            ;(this.pageColors.background || this.pageColors.foreground) &&
              console.warn(
                "PDFThumbnailViewer: Ignoring `pageColors`-option, since the browser doesn't support the values used."
              )
            this.pageColors = null
          }
          this.scroll = (0, n.watchScroll)(this.container, this._scrollUpdated.bind(this))
          this._resetView()
        }

        _scrollUpdated() {
          this.renderingQueue.renderHighestPriority()
        }

        getThumbnail(e) {
          return this._thumbnails[e]
        }

        _getVisibleThumbs() {
          return (0, n.getVisibleElements)({ scrollEl: this.container, views: this._thumbnails })
        }

        scrollThumbnailIntoView(e) {
          if (!this.pdfDocument) return
          const t = this._thumbnails[e - 1]
          if (!t) {
            console.error('scrollThumbnailIntoView: Invalid "pageNumber" parameter.')
            return
          }
          if (e !== this._currentPageNumber) {
            this._thumbnails[this._currentPageNumber - 1].div.classList.remove(a)
            t.div.classList.add(a)
          }
          const { first: i, last: s, views: r } = this._getVisibleThumbs()
          if (r.length > 0) {
            let a = !1
            if (e <= i.id || e >= s.id) a = !0
            else
              for (const { id: t, percent: i } of r)
                if (t === e) {
                  a = i < 100
                  break
                }
            a && (0, n.scrollIntoView)(t.div, { top: -19 })
          }
          this._currentPageNumber = e
        }

        get pagesRotation() {
          return this._pagesRotation
        }

        set pagesRotation(e) {
          if (!(0, n.isValidRotation)(e)) throw new Error('Invalid thumbnails rotation angle.')
          if (!this.pdfDocument) return
          if (this._pagesRotation === e) return
          this._pagesRotation = e
          const t = { rotation: e }
          for (const e of this._thumbnails) e.update(t)
        }

        cleanup() {
          for (const e of this._thumbnails)
            e.renderingState !== n.RenderingStates.FINISHED && e.reset()
          s.TempImageFactory.destroyCanvas()
        }

        _resetView() {
          this._thumbnails = []
          this._currentPageNumber = 1
          this._pageLabels = null
          this._pagesRotation = 0
          this.container.textContent = ''
        }

        setDocument(e) {
          if (this.pdfDocument) {
            this._cancelRendering()
            this._resetView()
          }
          this.pdfDocument = e
          if (!e) return
          const t = e.getPage(1)
          const i = e.getOptionalContentConfig()
          t.then((t) => {
            const n = e.numPages
            const r = t.getViewport({ scale: 1 })
            for (let e = 1; e <= n; ++e) {
              const t = new s.PDFThumbnailView({
                container: this.container,
                id: e,
                defaultViewport: r.clone(),
                optionalContentConfigPromise: i,
                linkService: this.linkService,
                renderingQueue: this.renderingQueue,
                l10n: this.l10n,
                pageColors: this.pageColors
              })
              this._thumbnails.push(t)
            }
            const o = this._thumbnails[0]
            o && o.setPdfPage(t)
            this._thumbnails[this._currentPageNumber - 1].div.classList.add(a)
          }).catch((e) => {
            console.error('Unable to initialize thumbnail viewer', e)
          })
        }

        _cancelRendering() {
          for (const e of this._thumbnails) e.cancelRendering()
        }

        setPageLabels(e) {
          if (this.pdfDocument) {
            if (e)
              if (Array.isArray(e) && this.pdfDocument.numPages === e.length) this._pageLabels = e
              else {
                this._pageLabels = null
                console.error('PDFThumbnailViewer_setPageLabels: Invalid page labels.')
              }
            else this._pageLabels = null
            for (let e = 0, n = this._thumbnails.length; e < n; e++) {
              var t
              var i
              this._thumbnails[e].setPageLabel(
                (t = (i = this._pageLabels) === null || void 0 === i ? void 0 : i[e]) !== null &&
                  void 0 !== t
                  ? t
                  : null
              )
            }
          }
        }

        forceRendering() {
          const e = this._getVisibleThumbs()
          const t = _classPrivateMethodGet(this, o, _getScrollAhead2).call(this, e)
          const i = this.renderingQueue.getHighestPriority(e, this._thumbnails, t)
          if (i) {
            _classPrivateMethodGet(this, r, _ensurePdfPageLoaded2)
              .call(this, i)
              .then(() => {
                this.renderingQueue.renderView(i)
              })
            return !0
          }
          return !1
        }
      }
      async function _ensurePdfPageLoaded2(e) {
        if (e.pdfPage) return e.pdfPage
        try {
          const t = await this.pdfDocument.getPage(e.id)
          e.pdfPage || e.setPdfPage(t)
          return t
        } catch (e) {
          console.error('Unable to get page for thumb view', e)
          return null
        }
      }
      function _getScrollAhead2(e) {
        let t
        let i
        return (
          ((t = e.first) === null || void 0 === t ? void 0 : t.id) === 1 ||
          (((i = e.last) === null || void 0 === i ? void 0 : i.id) !== this._thumbnails.length &&
            this.scroll.down)
        )
      }
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.TempImageFactory = t.PDFThumbnailView = void 0
      const n = i(1)
      const s = i(5)
      function _classStaticPrivateFieldSpecSet(e, t, i, n) {
        _classCheckPrivateStaticAccess(e, t)
        _classCheckPrivateStaticFieldDescriptor(i, 'set')
        !(function _classApplyDescriptorSet(e, t, i) {
          if (t.set) t.set.call(e, i)
          else {
            if (!t.writable) throw new TypeError('attempted to set read only private field')
            t.value = i
          }
        })(e, i, n)
        return n
      }
      function _classStaticPrivateFieldSpecGet(e, t, i) {
        _classCheckPrivateStaticAccess(e, t)
        _classCheckPrivateStaticFieldDescriptor(i, 'get')
        return (function _classApplyDescriptorGet(e, t) {
          if (t.get) return t.get.call(e)
          return t.value
        })(e, i)
      }
      function _classCheckPrivateStaticFieldDescriptor(e, t) {
        if (void 0 === e)
          throw new TypeError(`attempted to ${t} private static field before its declaration`)
      }
      function _classCheckPrivateStaticAccess(e, t) {
        if (e !== t) throw new TypeError('Private static access of wrong provenance')
      }
      class TempImageFactory {
        static getCanvas(e, t) {
          const i =
            _classStaticPrivateFieldSpecGet(this, TempImageFactory, a) ||
            _classStaticPrivateFieldSpecSet(
              this,
              TempImageFactory,
              a,
              document.createElement('canvas')
            )
          i.width = e
          i.height = t
          const n = i.getContext('2d', { alpha: !1 })
          n.save()
          n.fillStyle = 'rgb(255, 255, 255)'
          n.fillRect(0, 0, e, t)
          n.restore()
          return [i, i.getContext('2d')]
        }

        static destroyCanvas() {
          const e = _classStaticPrivateFieldSpecGet(this, TempImageFactory, a)
          if (e) {
            e.width = 0
            e.height = 0
          }
          _classStaticPrivateFieldSpecSet(this, TempImageFactory, a, null)
        }
      }
      t.TempImageFactory = TempImageFactory
      var a = { writable: !0, value: null }
      t.PDFThumbnailView = class PDFThumbnailView {
        constructor(e) {
          const {
            container: t,
            id: i,
            defaultViewport: s,
            optionalContentConfigPromise: a,
            linkService: r,
            renderingQueue: o,
            l10n: l,
            pageColors: c
          } = e
          this.id = i
          this.renderingId = `thumbnail${i}`
          this.pageLabel = null
          this.pdfPage = null
          this.rotation = 0
          this.viewport = s
          this.pdfPageRotate = s.rotation
          this._optionalContentConfigPromise = a || null
          this.pageColors = c || null
          this.linkService = r
          this.renderingQueue = o
          this.renderTask = null
          this.renderingState = n.RenderingStates.INITIAL
          this.resume = null
          const d = this.viewport.width
          const h = d / this.viewport.height
          this.canvasWidth = 98
          this.canvasHeight = (this.canvasWidth / h) | 0
          this.scale = this.canvasWidth / d
          this.l10n = l
          const u = document.createElement('a')
          u.href = r.getAnchorUrl(`#page=${i}`)
          this._thumbPageTitle.then((e) => {
            u.title = e
          })
          u.onclick = function () {
            r.goToPage(i)
            return !1
          }
          this.anchor = u
          const p = document.createElement('div')
          p.className = 'thumbnail'
          p.setAttribute('data-page-number', this.id)
          this.div = p
          const g = document.createElement('div')
          g.className = 'thumbnailSelectionRing'
          g.style.width = `${this.canvasWidth + 2}px`
          g.style.height = `${this.canvasHeight + 2}px`
          this.ring = g
          p.append(g)
          u.append(p)
          t.append(u)
        }

        setPdfPage(e) {
          this.pdfPage = e
          this.pdfPageRotate = e.rotate
          const t = (this.rotation + this.pdfPageRotate) % 360
          this.viewport = e.getViewport({ scale: 1, rotation: t })
          this.reset()
        }

        reset() {
          this.cancelRendering()
          this.renderingState = n.RenderingStates.INITIAL
          const e = this.viewport.width
          const t = e / this.viewport.height
          this.canvasHeight = (this.canvasWidth / t) | 0
          this.scale = this.canvasWidth / e
          this.div.removeAttribute('data-loaded')
          const i = this.ring
          i.textContent = ''
          i.style.width = `${this.canvasWidth + 2}px`
          i.style.height = `${this.canvasHeight + 2}px`
          if (this.canvas) {
            this.canvas.width = 0
            this.canvas.height = 0
            delete this.canvas
          }
          if (this.image) {
            this.image.removeAttribute('src')
            delete this.image
          }
        }

        update(e) {
          const { rotation: t = null } = e
          typeof t === 'number' && (this.rotation = t)
          const i = (this.rotation + this.pdfPageRotate) % 360
          this.viewport = this.viewport.clone({ scale: 1, rotation: i })
          this.reset()
        }

        cancelRendering() {
          if (this.renderTask) {
            this.renderTask.cancel()
            this.renderTask = null
          }
          this.resume = null
        }

        _getPageDrawContext() {
          const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1
          const t = document.createElement('canvas')
          const i = t.getContext('2d', { alpha: !1 })
          const s = new n.OutputScale()
          t.width = (e * this.canvasWidth * s.sx) | 0
          t.height = (e * this.canvasHeight * s.sy) | 0
          return { ctx: i, canvas: t, transform: s.scaled ? [s.sx, 0, 0, s.sy, 0, 0] : null }
        }

        _convertCanvasToImage(e) {
          if (this.renderingState !== n.RenderingStates.FINISHED)
            throw new Error('_convertCanvasToImage: Rendering has not finished.')
          const t = this._reduceImage(e)
          const i = document.createElement('img')
          i.className = 'thumbnailImage'
          this._thumbPageCanvas.then((e) => {
            i.setAttribute('aria-label', e)
          })
          i.style.width = `${this.canvasWidth}px`
          i.style.height = `${this.canvasHeight}px`
          i.src = t.toDataURL()
          this.image = i
          this.div.setAttribute('data-loaded', !0)
          this.ring.append(i)
          t.width = 0
          t.height = 0
        }

        draw() {
          const e = this
          if (this.renderingState !== n.RenderingStates.INITIAL) {
            console.error('Must be in new state before drawing')
            return Promise.resolve()
          }
          const { pdfPage: t } = this
          if (!t) {
            this.renderingState = n.RenderingStates.FINISHED
            return Promise.reject(new Error('pdfPage is not loaded'))
          }
          this.renderingState = n.RenderingStates.RUNNING
          const finishRenderTask = async function () {
            const t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
            l === e.renderTask && (e.renderTask = null)
            if (!(t instanceof s.RenderingCancelledException)) {
              e.renderingState = n.RenderingStates.FINISHED
              e._convertCanvasToImage(a)
              if (t) throw t
            }
          }
          const { ctx: i, canvas: a, transform: r } = this._getPageDrawContext(2)
          const o = {
            canvasContext: i,
            transform: r,
            viewport: this.viewport.clone({ scale: 2 * this.scale }),
            optionalContentConfigPromise: this._optionalContentConfigPromise,
            pageColors: this.pageColors
          }
          const l = (this.renderTask = t.render(o))
          l.onContinue = (e) => {
            if (this.renderingQueue.isHighestPriority(this)) e()
            else {
              this.renderingState = n.RenderingStates.PAUSED
              this.resume = () => {
                this.renderingState = n.RenderingStates.RUNNING
                e()
              }
            }
          }
          const c = l.promise.then(
            function () {
              return finishRenderTask(null)
            },
            function (e) {
              return finishRenderTask(e)
            }
          )
          c.finally(() => {
            a.width = 0
            a.height = 0
            if (!this.linkService.isPageCached(this.id)) {
              let e
              ;(e = this.pdfPage) === null || void 0 === e || e.cleanup()
            }
          })
          return c
        }

        setImage(e) {
          if (this.renderingState !== n.RenderingStates.INITIAL) return
          const { thumbnailCanvas: t, pdfPage: i, scale: s } = e
          if (t) {
            this.pdfPage || this.setPdfPage(i)
            if (!(s < this.scale)) {
              this.renderingState = n.RenderingStates.FINISHED
              this._convertCanvasToImage(t)
            }
          }
        }

        _reduceImage(e) {
          const { ctx: t, canvas: i } = this._getPageDrawContext()
          if (e.width <= 2 * i.width) {
            t.drawImage(e, 0, 0, e.width, e.height, 0, 0, i.width, i.height)
            return i
          }
          let n = i.width << 3
          let s = i.height << 3
          const [a, r] = TempImageFactory.getCanvas(n, s)
          for (; n > e.width || s > e.height; ) {
            n >>= 1
            s >>= 1
          }
          r.drawImage(e, 0, 0, e.width, e.height, 0, 0, n, s)
          for (; n > 2 * i.width; ) {
            r.drawImage(a, 0, 0, n, s, 0, 0, n >> 1, s >> 1)
            n >>= 1
            s >>= 1
          }
          t.drawImage(a, 0, 0, n, s, 0, 0, i.width, i.height)
          return i
        }

        get _thumbPageTitle() {
          let e
          return this.l10n.get('thumb_page_title', {
            page: (e = this.pageLabel) !== null && void 0 !== e ? e : this.id
          })
        }

        get _thumbPageCanvas() {
          let e
          return this.l10n.get('thumb_page_canvas', {
            page: (e = this.pageLabel) !== null && void 0 !== e ? e : this.id
          })
        }

        setPageLabel(e) {
          this.pageLabel = typeof e === 'string' ? e : null
          this._thumbPageTitle.then((e) => {
            this.anchor.title = e
          })
          this.renderingState === n.RenderingStates.FINISHED &&
            this._thumbPageCanvas.then((e) => {
              let t
              ;(t = this.image) === null || void 0 === t || t.setAttribute('aria-label', e)
            })
        }
      }
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.PDFViewer = t.PDFSinglePageViewer = void 0
      const n = i(1)
      const s = i(30)
      class PDFViewer extends s.BaseViewer {}
      t.PDFViewer = PDFViewer
      class PDFSinglePageViewer extends s.BaseViewer {
        _resetView() {
          super._resetView()
          this._scrollMode = n.ScrollMode.PAGE
          this._spreadMode = n.SpreadMode.NONE
        }

        set scrollMode(e) {}

        _updateScrollMode() {}

        set spreadMode(e) {}

        _updateSpreadMode() {}
      }
      t.PDFSinglePageViewer = PDFSinglePageViewer
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.PagesCountLimit = t.PDFPageViewBuffer = t.BaseViewer = void 0
      const n = i(5)
      const s = i(1)
      const a = i(31)
      const r = i(33)
      const o = i(32)
      const l = i(34)
      const c = i(23)
      const d = i(3)
      const h = i(38)
      const u = i(39)
      const p = i(40)
      const g = i(41)
      const f = i(36)
      let m
      function _classPrivateMethodInitSpec(e, t) {
        _checkPrivateRedeclaration(e, t)
        t.add(e)
      }
      function _classPrivateFieldInitSpec(e, t, i) {
        _checkPrivateRedeclaration(e, t)
        t.set(e, i)
      }
      function _checkPrivateRedeclaration(e, t) {
        if (t.has(e))
          throw new TypeError('Cannot initialize the same private elements twice on an object')
      }
      function _classPrivateMethodGet(e, t, i) {
        if (!t.has(e)) throw new TypeError('attempted to get private field on non-instance')
        return i
      }
      function _classPrivateFieldGet(e, t) {
        return (function _classApplyDescriptorGet(e, t) {
          if (t.get) return t.get.call(e)
          return t.value
        })(e, _classExtractFieldDescriptor(e, t, 'get'))
      }
      function _classPrivateFieldSet(e, t, i) {
        !(function _classApplyDescriptorSet(e, t, i) {
          if (t.set) t.set.call(e, i)
          else {
            if (!t.writable) throw new TypeError('attempted to set read only private field')
            t.value = i
          }
        })(e, _classExtractFieldDescriptor(e, t, 'set'), i)
        return i
      }
      function _classExtractFieldDescriptor(e, t, i) {
        if (!t.has(e)) throw new TypeError(`attempted to ${i} private field on non-instance`)
        return t.get(e)
      }
      const v = 'enablePermissions'
      const _ = {
        FORCE_SCROLL_MODE_PAGE: 15e3,
        FORCE_LAZY_PAGE_INIT: 7500,
        PAUSE_EAGER_PAGE_INIT: 250
      }
      t.PagesCountLimit = _
      function isValidAnnotationEditorMode(e) {
        return (
          Object.values(n.AnnotationEditorType).includes(e) && e !== n.AnnotationEditorType.DISABLE
        )
      }
      const b = new WeakMap()
      const w = new WeakMap()
      const P = new WeakSet()
      m = Symbol.iterator
      class PDFPageViewBuffer {
        constructor(e) {
          _classPrivateMethodInitSpec(this, P)
          _classPrivateFieldInitSpec(this, b, { writable: !0, value: new Set() })
          _classPrivateFieldInitSpec(this, w, { writable: !0, value: 0 })
          _classPrivateFieldSet(this, w, e)
        }

        push(e) {
          const t = _classPrivateFieldGet(this, b)
          t.has(e) && t.delete(e)
          t.add(e)
          t.size > _classPrivateFieldGet(this, w) &&
            _classPrivateMethodGet(this, P, _destroyFirstView2).call(this)
        }

        resize(e) {
          const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
          _classPrivateFieldSet(this, w, e)
          const i = _classPrivateFieldGet(this, b)
          if (t) {
            const e = i.size
            let n = 1
            for (const s of i) {
              if (t.has(s.id)) {
                i.delete(s)
                i.add(s)
              }
              if (++n > e) break
            }
          }
          for (; i.size > _classPrivateFieldGet(this, w); )
            _classPrivateMethodGet(this, P, _destroyFirstView2).call(this)
        }

        has(e) {
          return _classPrivateFieldGet(this, b).has(e)
        }

        [m]() {
          return _classPrivateFieldGet(this, b).keys()
        }
      }
      t.PDFPageViewBuffer = PDFPageViewBuffer
      function _destroyFirstView2() {
        const e = _classPrivateFieldGet(this, b).keys().next().value
        e == null || e.destroy()
        _classPrivateFieldGet(this, b).delete(e)
      }
      const y = new WeakMap()
      const S = new WeakMap()
      const A = new WeakMap()
      const E = new WeakMap()
      const x = new WeakMap()
      const C = new WeakMap()
      const M = new WeakMap()
      const T = new WeakMap()
      const k = new WeakSet()
      const I = new WeakSet()
      const D = new WeakSet()
      const L = new WeakSet()
      const R = new WeakSet()
      const O = new WeakSet()
      const N = new WeakSet()
      const B = new WeakSet()
      const G = new WeakSet()
      class BaseViewer {
        constructor(e) {
          let t
          let i
          let a
          let r
          let l
          _classPrivateMethodInitSpec(this, G)
          _classPrivateMethodInitSpec(this, B)
          _classPrivateMethodInitSpec(this, N)
          _classPrivateMethodInitSpec(this, O)
          _classPrivateMethodInitSpec(this, R)
          _classPrivateMethodInitSpec(this, L)
          _classPrivateMethodInitSpec(this, D)
          _classPrivateMethodInitSpec(this, I)
          _classPrivateMethodInitSpec(this, k)
          _classPrivateFieldInitSpec(this, y, { writable: !0, value: null })
          _classPrivateFieldInitSpec(this, S, {
            writable: !0,
            value: n.AnnotationEditorType.DISABLE
          })
          _classPrivateFieldInitSpec(this, A, { writable: !0, value: null })
          _classPrivateFieldInitSpec(this, E, {
            writable: !0,
            value: n.AnnotationMode.ENABLE_FORMS
          })
          _classPrivateFieldInitSpec(this, x, { writable: !0, value: !1 })
          _classPrivateFieldInitSpec(this, C, { writable: !0, value: 0 })
          _classPrivateFieldInitSpec(this, M, { writable: !0, value: null })
          _classPrivateFieldInitSpec(this, T, { writable: !0, value: null })
          if (this.constructor === BaseViewer) throw new Error('Cannot initialize BaseViewer.')
          ;(0, f.log_debug)(`begin to construct ${this.constructor}`)
          const h = '2.16.0'
          if (n.version !== h)
            throw new Error(
              `The API version "${n.version}" does not match the Viewer version "2.16.0".`
            )
          this.container = e.container
          this.viewer = e.viewer || e.container.firstElementChild
          if (
            ((t = this.container) === null || void 0 === t ? void 0 : t.tagName.toUpperCase()) !==
              'DIV' ||
            ((i = this.viewer) === null || void 0 === i ? void 0 : i.tagName.toUpperCase()) !==
              'DIV'
          )
            throw new Error('Invalid `container` and/or `viewer` option.')
          if (
            this.container.offsetParent &&
            getComputedStyle(this.container).position !== 'absolute'
          )
            throw new Error('The `container` must be absolutely positioned.')
          this.eventBus = e.eventBus
          this.linkService = e.linkService || new d.SimpleLinkService()
          this.downloadManager = e.downloadManager || null
          this.findController = e.findController || null
          this._scriptingManager = e.scriptingManager || null
          this.removePageBorders = e.removePageBorders || !1
          this.textLayerMode =
            (a = e.textLayerMode) !== null && void 0 !== a ? a : s.TextLayerMode.ENABLE
          _classPrivateFieldSet(
            this,
            E,
            (r = e.annotationMode) !== null && void 0 !== r ? r : n.AnnotationMode.ENABLE_FORMS
          )
          _classPrivateFieldSet(
            this,
            S,
            (l = e.annotationEditorMode) !== null && void 0 !== l
              ? l
              : n.AnnotationEditorType.DISABLE
          )
          this.imageResourcesPath = e.imageResourcesPath || ''
          this.enablePrintAutoRotate = e.enablePrintAutoRotate || !1
          this.renderer = e.renderer || s.RendererType.CANVAS
          this.useOnlyCssZoom = e.useOnlyCssZoom || !1
          this.maxCanvasPixels = e.maxCanvasPixels
          this.l10n = e.l10n || o.NullL10n
          _classPrivateFieldSet(this, x, e.enablePermissions || !1)
          this.pageColors = e.pageColors || null
          if (
            this.pageColors &&
            (!CSS.supports('color', this.pageColors.background) ||
              !CSS.supports('color', this.pageColors.foreground))
          ) {
            ;(this.pageColors.background || this.pageColors.foreground) &&
              console.warn(
                "BaseViewer: Ignoring `pageColors`-option, since the browser doesn't support the values used."
              )
            this.pageColors = null
          }
          this.defaultRenderingQueue = !e.renderingQueue
          if (this.defaultRenderingQueue) {
            this.renderingQueue = new c.PDFRenderingQueue()
            this.renderingQueue.setViewer(this)
          } else this.renderingQueue = e.renderingQueue
          this.scroll = (0, s.watchScroll)(this.container, this._scrollUpdate.bind(this))
          this.presentationModeState = s.PresentationModeState.UNKNOWN
          this._onBeforeDraw = this._onAfterDraw = null
          this._resetView()
          this.removePageBorders && this.viewer.classList.add('removePageBorders')
          this.updateContainerHeightCss()
        }

        get pagesCount() {
          return this._pages.length
        }

        getPageView(e) {
          return this._pages[e]
        }

        get pageViewsReady() {
          return (
            !!this._pagesCapability.settled &&
            this._pages.every(function (e) {
              return e == null ? void 0 : e.pdfPage
            })
          )
        }

        get renderForms() {
          return _classPrivateFieldGet(this, E) === n.AnnotationMode.ENABLE_FORMS
        }

        get enableScripting() {
          return !!this._scriptingManager
        }

        get currentPageNumber() {
          return this._currentPageNumber
        }

        set currentPageNumber(e) {
          if (!Number.isInteger(e)) throw new Error('Invalid page number.')
          this.pdfDocument &&
            (this._setCurrentPageNumber(e, !0) ||
              console.error(`currentPageNumber: "${e}" is not a valid page.`))
        }

        _setCurrentPageNumber(e) {
          let t
          let i
          const n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
          if (this._currentPageNumber === e) {
            n && _classPrivateMethodGet(this, O, _resetCurrentPageView2).call(this)
            return !0
          }
          if (!(e > 0 && e <= this.pagesCount)) return !1
          const s = this._currentPageNumber
          this._currentPageNumber = e
          this.eventBus.dispatch('pagechanging', {
            source: this,
            pageNumber: e,
            pageLabel:
              (t = (i = this._pageLabels) === null || void 0 === i ? void 0 : i[e - 1]) !== null &&
              void 0 !== t
                ? t
                : null,
            previous: s
          })
          n && _classPrivateMethodGet(this, O, _resetCurrentPageView2).call(this)
          return !0
        }

        get currentPageLabel() {
          let e
          let t
          return (e =
            (t = this._pageLabels) === null || void 0 === t
              ? void 0
              : t[this._currentPageNumber - 1]) !== null && void 0 !== e
            ? e
            : null
        }

        set currentPageLabel(e) {
          if (!this.pdfDocument) return
          let t = 0 | e
          if (this._pageLabels) {
            const i = this._pageLabels.indexOf(e)
            i >= 0 && (t = i + 1)
          }
          this._setCurrentPageNumber(t, !0) ||
            console.error(`currentPageLabel: "${e}" is not a valid page.`)
        }

        get currentScale() {
          return this._currentScale !== s.UNKNOWN_SCALE ? this._currentScale : s.DEFAULT_SCALE
        }

        set currentScale(e) {
          if (isNaN(e)) throw new Error('Invalid numeric scale.')
          this.pdfDocument && this._setScale(e, !1)
        }

        get currentScaleValue() {
          return this._currentScaleValue
        }

        set currentScaleValue(e) {
          this.pdfDocument && this._setScale(e, !1)
        }

        get pagesRotation() {
          return this._pagesRotation
        }

        set pagesRotation(e) {
          if (!(0, s.isValidRotation)(e)) throw new Error('Invalid pages rotation angle.')
          if (!this.pdfDocument) return
          ;(e %= 360) < 0 && (e += 360)
          if (this._pagesRotation === e) return
          this._pagesRotation = e
          const t = this._currentPageNumber
          const i = { rotation: e }
          for (const e of this._pages) e.update(i)
          this._currentScaleValue && this._setScale(this._currentScaleValue, !0)
          this.eventBus.dispatch('rotationchanging', {
            source: this,
            pagesRotation: e,
            pageNumber: t
          })
          this.defaultRenderingQueue && this.update()
        }

        get firstPagePromise() {
          return this.pdfDocument ? this._firstPageCapability.promise : null
        }

        get onePageRendered() {
          return this.pdfDocument ? this._onePageRenderedCapability.promise : null
        }

        get pagesPromise() {
          return this.pdfDocument ? this._pagesCapability.promise : null
        }

        setDocument(e) {
          if (this.pdfDocument) {
            this.eventBus.dispatch('pagesdestroy', { source: this })
            this._cancelRendering()
            this._resetView()
            this.findController && this.findController.setDocument(null)
            this._scriptingManager && this._scriptingManager.setDocument(null)
            if (_classPrivateFieldGet(this, A)) {
              _classPrivateFieldGet(this, A).destroy()
              _classPrivateFieldSet(this, A, null)
            }
          }
          this.pdfDocument = e
          if (!e) return
          const t = e.isPureXfa
          const i = e.numPages
          const a = e.getPage(1)
          const r = e.getOptionalContentConfig()
          const o = _classPrivateFieldGet(this, x) ? e.getPermissions() : Promise.resolve()
          if (i > _.FORCE_SCROLL_MODE_PAGE) {
            console.warn(
              'Forcing PAGE-scrolling for performance reasons, given the length of the document.'
            )
            const e = (this._scrollMode = s.ScrollMode.PAGE)
            this.eventBus.dispatch('scrollmodechanged', { source: this, mode: e })
          }
          this._pagesCapability.promise.then(
            () => {
              this.eventBus.dispatch('pagesloaded', { source: this, pagesCount: i })
            },
            () => {}
          )
          this._onBeforeDraw = (e) => {
            const t = this._pages[e.pageNumber - 1]
            t && _classPrivateFieldGet(this, y).push(t)
          }
          this.eventBus._on('pagerender', this._onBeforeDraw)
          this._onAfterDraw = (e) => {
            if (!e.cssTransform && !this._onePageRenderedCapability.settled) {
              this._onePageRenderedCapability.resolve({ timestamp: e.timestamp })
              this.eventBus._off('pagerendered', this._onAfterDraw)
              this._onAfterDraw = null
              if (_classPrivateFieldGet(this, T)) {
                document.removeEventListener('visibilitychange', _classPrivateFieldGet(this, T))
                _classPrivateFieldSet(this, T, null)
              }
            }
          }
          this.eventBus._on('pagerendered', this._onAfterDraw)
          Promise.all([a, o])
            .then((a) => {
              const [o, c] = a
              if (e !== this.pdfDocument) return
              this._firstPageCapability.resolve(o)
              this._optionalContentConfigPromise = r
              const {
                annotationEditorMode: d,
                annotationMode: h,
                textLayerMode: u
              } = _classPrivateMethodGet(this, k, _initializePermissions2).call(this, c)
              if (d !== n.AnnotationEditorType.DISABLE) {
                const e = d
                if (t) console.warn('Warning: XFA-editing is not implemented.')
                else if (isValidAnnotationEditorMode(e)) {
                  _classPrivateFieldSet(
                    this,
                    A,
                    new n.AnnotationEditorUIManager(this.container, this.eventBus)
                  )
                  e !== n.AnnotationEditorType.NONE && _classPrivateFieldGet(this, A).updateMode(e)
                } else console.error(`Invalid AnnotationEditor mode: ${e}`)
              }
              const p = this._scrollMode === s.ScrollMode.PAGE ? null : this.viewer
              const g = this.currentScale
              const f = o.getViewport({ scale: g * n.PixelsPerInch.PDF_TO_CSS_UNITS })
              const m = u === s.TextLayerMode.DISABLE || t ? null : this
              const v = h !== n.AnnotationMode.DISABLE ? this : null
              const b = t ? this : null
              const w = _classPrivateFieldGet(this, A) ? this : null
              for (let e = 1; e <= i; ++e) {
                const t = new l.PDFPageView({
                  container: p,
                  eventBus: this.eventBus,
                  id: e,
                  scale: g,
                  defaultViewport: f.clone(),
                  optionalContentConfigPromise: r,
                  renderingQueue: this.renderingQueue,
                  textLayerFactory: m,
                  textLayerMode: u,
                  annotationLayerFactory: v,
                  annotationMode: h,
                  xfaLayerFactory: b,
                  annotationEditorLayerFactory: w,
                  textHighlighterFactory: this,
                  structTreeLayerFactory: this,
                  imageResourcesPath: this.imageResourcesPath,
                  renderer: this.renderer,
                  useOnlyCssZoom: this.useOnlyCssZoom,
                  maxCanvasPixels: this.maxCanvasPixels,
                  pageColors: this.pageColors,
                  l10n: this.l10n
                })
                this._pages.push(t)
              }
              const P = this._pages[0]
              if (P) {
                P.setPdfPage(o)
                this.linkService.cachePageRef(1, o.ref)
              }
              this._scrollMode === s.ScrollMode.PAGE
                ? _classPrivateMethodGet(this, D, _ensurePageViewVisible2).call(this)
                : this._spreadMode !== s.SpreadMode.NONE && this._updateSpreadMode()
              _classPrivateMethodGet(this, I, _onePageRenderedOrForceFetch2)
                .call(this)
                .then(async () => {
                  this.findController && this.findController.setDocument(e)
                  this._scriptingManager && this._scriptingManager.setDocument(e)
                  _classPrivateFieldGet(this, A) &&
                    this.eventBus.dispatch('annotationeditormodechanged', {
                      source: this,
                      mode: _classPrivateFieldGet(this, S)
                    })
                  if (e.loadingParams.disableAutoFetch || i > _.FORCE_LAZY_PAGE_INIT) {
                    this._pagesCapability.resolve()
                    return
                  }
                  let t = i - 1
                  if (t <= 0) this._pagesCapability.resolve()
                  else
                    for (let n = 2; n <= i; ++n) {
                      const i = e.getPage(n).then(
                        (e) => {
                          const i = this._pages[n - 1]
                          i.pdfPage || i.setPdfPage(e)
                          this.linkService.cachePageRef(n, e.ref)
                          --t == 0 && this._pagesCapability.resolve()
                        },
                        (e) => {
                          console.error(`Unable to get page ${n} to initialize viewer`, e)
                          --t == 0 && this._pagesCapability.resolve()
                        }
                      )
                      n % _.PAUSE_EAGER_PAGE_INIT == 0 && (await i)
                    }
                })
              this.eventBus.dispatch('pagesinit', { source: this })
              e.getMetadata().then((t) => {
                const { info: i } = t
                e === this.pdfDocument && i.Language && (this.viewer.lang = i.Language)
              })
              this.defaultRenderingQueue && this.update()
            })
            .catch((e) => {
              console.error('Unable to initialize viewer', e)
              this._pagesCapability.reject(e)
            })
        }

        setPageLabels(e) {
          if (this.pdfDocument) {
            if (e)
              if (Array.isArray(e) && this.pdfDocument.numPages === e.length) this._pageLabels = e
              else {
                this._pageLabels = null
                console.error('setPageLabels: Invalid page labels.')
              }
            else this._pageLabels = null
            for (let e = 0, n = this._pages.length; e < n; e++) {
              var t
              var i
              this._pages[e].setPageLabel(
                (t = (i = this._pageLabels) === null || void 0 === i ? void 0 : i[e]) !== null &&
                  void 0 !== t
                  ? t
                  : null
              )
            }
          }
        }

        _resetView() {
          this._pages = []
          this._currentPageNumber = 1
          this._currentScale = s.UNKNOWN_SCALE
          this._currentScaleValue = null
          this._pageLabels = null
          _classPrivateFieldSet(this, y, new PDFPageViewBuffer(10))
          this._location = null
          this._pagesRotation = 0
          this._optionalContentConfigPromise = null
          this._firstPageCapability = (0, n.createPromiseCapability)()
          this._onePageRenderedCapability = (0, n.createPromiseCapability)()
          this._pagesCapability = (0, n.createPromiseCapability)()
          this._scrollMode = s.ScrollMode.VERTICAL
          this._previousScrollMode = s.ScrollMode.UNKNOWN
          this._spreadMode = s.SpreadMode.NONE
          _classPrivateFieldSet(this, M, { previousPageNumber: 1, scrollDown: !0, pages: [] })
          if (this._onBeforeDraw) {
            this.eventBus._off('pagerender', this._onBeforeDraw)
            this._onBeforeDraw = null
          }
          if (this._onAfterDraw) {
            this.eventBus._off('pagerendered', this._onAfterDraw)
            this._onAfterDraw = null
          }
          if (_classPrivateFieldGet(this, T)) {
            document.removeEventListener('visibilitychange', _classPrivateFieldGet(this, T))
            _classPrivateFieldSet(this, T, null)
          }
          this.viewer.textContent = ''
          this._updateScrollMode()
          this.viewer.removeAttribute('lang')
          this.viewer.classList.remove(v)
        }

        _scrollUpdate() {
          this.pagesCount !== 0 && this.update()
        }

        _setScaleUpdatePages(e, t) {
          const i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
          const a = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]
          this._currentScaleValue = t.toString()
          if (_classPrivateMethodGet(this, R, _isSameScale2).call(this, e)) {
            a && this.eventBus.dispatch('scalechanging', { source: this, scale: e, presetValue: t })
            return
          }
          s.docStyle.setProperty('--scale-factor', e * n.PixelsPerInch.PDF_TO_CSS_UNITS)
          const r = { scale: e }
          for (const e of this._pages) e.update(r)
          this._currentScale = e
          if (!i) {
            let e
            let t = this._currentPageNumber
            if (this._location && !this.isInPresentationMode && !this.isChangingPresentationMode) {
              t = this._location.pageNumber
              e = [null, { name: 'XYZ' }, this._location.left, this._location.top, null]
            }
            this.scrollPageIntoView({ pageNumber: t, destArray: e, allowNegativeOffset: !0 })
          }
          this.eventBus.dispatch('scalechanging', {
            source: this,
            scale: e,
            presetValue: a ? t : void 0
          })
          this.defaultRenderingQueue && this.update()
          this.updateContainerHeightCss()
        }

        get _pageWidthScaleFactor() {
          return this._spreadMode !== s.SpreadMode.NONE &&
            this._scrollMode !== s.ScrollMode.HORIZONTAL
            ? 2
            : 1
        }

        _setScale(e) {
          const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
          let i = parseFloat(e)
          if (i > 0) this._setScaleUpdatePages(i, e, t, !1)
          else {
            const n = this._pages[this._currentPageNumber - 1]
            if (!n) return
            let a = s.SCROLLBAR_PADDING
            let r = s.VERTICAL_PADDING
            this.isInPresentationMode
              ? (a = r = 4)
              : this.removePageBorders
              ? (a = r = 0)
              : this._scrollMode === s.ScrollMode.HORIZONTAL && ([a, r] = [r, a])
            const o =
              (((this.container.clientWidth - a) / n.width) * n.scale) / this._pageWidthScaleFactor
            const l = ((this.container.clientHeight - r) / n.height) * n.scale
            switch (e) {
              case 'page-actual':
                i = 1
                break
              case 'page-width':
                i = o
                break
              case 'page-height':
                i = l
                break
              case 'page-fit':
                i = Math.min(o, l)
                break
              case 'auto':
                const t = (0, s.isPortraitOrientation)(n) ? o : Math.min(l, o)
                i = Math.min(s.MAX_AUTO_SCALE, t)
                break
              default:
                console.error(`_setScale: "${e}" is an unknown zoom value.`)
                return
            }
            this._setScaleUpdatePages(i, e, t, !0)
          }
        }

        pageLabelToPageNumber(e) {
          if (!this._pageLabels) return null
          const t = this._pageLabels.indexOf(e)
          return t < 0 ? null : t + 1
        }

        scrollPageIntoView(e) {
          const {
            pageNumber: t,
            destArray: i = null,
            allowNegativeOffset: a = !1,
            ignoreDestinationZoom: r = !1
          } = e
          if (!this.pdfDocument) return
          const o = Number.isInteger(t) && this._pages[t - 1]
          if (!o) {
            console.error(`scrollPageIntoView: "${t}" is not a valid pageNumber parameter.`)
            return
          }
          if (this.isInPresentationMode || !i) {
            this._setCurrentPageNumber(t, !0)
            return
          }
          let l
          let c
          let d = 0
          let h = 0
          let u = 0
          let p = 0
          const g = o.rotation % 180 != 0
          const f = (g ? o.height : o.width) / o.scale / n.PixelsPerInch.PDF_TO_CSS_UNITS
          const m = (g ? o.width : o.height) / o.scale / n.PixelsPerInch.PDF_TO_CSS_UNITS
          let v = 0
          switch (i[1].name) {
            case 'XYZ':
              d = i[2]
              h = i[3]
              v = i[4]
              d = d !== null ? d : 0
              h = h !== null ? h : m
              break
            case 'Fit':
            case 'FitB':
              v = 'page-fit'
              break
            case 'FitH':
            case 'FitBH':
              h = i[2]
              v = 'page-width'
              if (h === null && this._location) {
                d = this._location.left
                h = this._location.top
              } else (typeof h !== 'number' || h < 0) && (h = m)
              break
            case 'FitV':
            case 'FitBV':
              d = i[2]
              u = f
              p = m
              v = 'page-height'
              break
            case 'FitR':
              d = i[2]
              h = i[3]
              u = i[4] - d
              p = i[5] - h
              const e = this.removePageBorders ? 0 : s.SCROLLBAR_PADDING
              const t = this.removePageBorders ? 0 : s.VERTICAL_PADDING
              l = (this.container.clientWidth - e) / u / n.PixelsPerInch.PDF_TO_CSS_UNITS
              c = (this.container.clientHeight - t) / p / n.PixelsPerInch.PDF_TO_CSS_UNITS
              v = Math.min(Math.abs(l), Math.abs(c))
              break
            default:
              console.error(`scrollPageIntoView: "${i[1].name}" is not a valid destination type.`)
              return
          }
          r ||
            (v && v !== this._currentScale
              ? (this.currentScaleValue = v)
              : this._currentScale === s.UNKNOWN_SCALE &&
                (this.currentScaleValue = s.DEFAULT_SCALE_VALUE))
          if (v === 'page-fit' && !i[4]) {
            _classPrivateMethodGet(this, L, _scrollIntoView2).call(this, o)
            return
          }
          const _ = [
            o.viewport.convertToViewportPoint(d, h),
            o.viewport.convertToViewportPoint(d + u, h + p)
          ]
          let b = Math.min(_[0][0], _[1][0])
          let w = Math.min(_[0][1], _[1][1])
          if (!a) {
            b = Math.max(b, 0)
            w = Math.max(w, 0)
          }
          _classPrivateMethodGet(this, L, _scrollIntoView2).call(this, o, { left: b, top: w })
        }

        _updateLocation(e) {
          const t = this._currentScale
          const i = this._currentScaleValue
          const n = parseFloat(i) === t ? Math.round(1e4 * t) / 100 : i
          const s = e.id
          const a = this._pages[s - 1]
          const r = this.container
          const o = a.getPagePoint(r.scrollLeft - e.x, r.scrollTop - e.y)
          const l = Math.round(o[0])
          const c = Math.round(o[1])
          let d = `#page=${s}`
          this.isInPresentationMode || (d += `&zoom=${n},${l},${c}`)
          this._location = {
            pageNumber: s,
            scale: n,
            top: c,
            left: l,
            rotation: this._pagesRotation,
            pdfOpenParams: d
          }
        }

        update() {
          const e = this._getVisiblePages()
          const t = e.views
          const i = t.length
          if (i === 0) return
          const n = Math.max(10, 2 * i + 1)
          _classPrivateFieldGet(this, y).resize(n, e.ids)
          this.renderingQueue.renderHighestPriority(e)
          const a =
            this._spreadMode === s.SpreadMode.NONE &&
            (this._scrollMode === s.ScrollMode.PAGE || this._scrollMode === s.ScrollMode.VERTICAL)
          const r = this._currentPageNumber
          let o = !1
          for (const e of t) {
            if (e.percent < 100) break
            if (e.id === r && a) {
              o = !0
              break
            }
          }
          this._setCurrentPageNumber(o ? r : t[0].id)
          this._updateLocation(e.first)
          this.eventBus.dispatch('updateviewarea', { source: this, location: this._location })
        }

        containsElement(e) {
          return this.container.contains(e)
        }

        focus() {
          this.container.focus()
        }

        get _isContainerRtl() {
          return getComputedStyle(this.container).direction === 'rtl'
        }

        get isInPresentationMode() {
          return this.presentationModeState === s.PresentationModeState.FULLSCREEN
        }

        get isChangingPresentationMode() {
          return this.presentationModeState === s.PresentationModeState.CHANGING
        }

        get isHorizontalScrollbarEnabled() {
          return (
            !this.isInPresentationMode && this.container.scrollWidth > this.container.clientWidth
          )
        }

        get isVerticalScrollbarEnabled() {
          return (
            !this.isInPresentationMode && this.container.scrollHeight > this.container.clientHeight
          )
        }

        _getVisiblePages() {
          const e =
            this._scrollMode === s.ScrollMode.PAGE
              ? _classPrivateFieldGet(this, M).pages
              : this._pages
          const t = this._scrollMode === s.ScrollMode.HORIZONTAL
          const i = t && this._isContainerRtl
          return (0, s.getVisibleElements)({
            scrollEl: this.container,
            views: e,
            sortByVisibility: !0,
            horizontal: t,
            rtl: i
          })
        }

        isPageVisible(e) {
          if (!this.pdfDocument) return !1
          if (!(Number.isInteger(e) && e > 0 && e <= this.pagesCount)) {
            console.error(`isPageVisible: "${e}" is not a valid page.`)
            return !1
          }
          return this._getVisiblePages().ids.has(e)
        }

        isPageCached(e) {
          if (!this.pdfDocument) return !1
          if (!(Number.isInteger(e) && e > 0 && e <= this.pagesCount)) {
            console.error(`isPageCached: "${e}" is not a valid page.`)
            return !1
          }
          const t = this._pages[e - 1]
          return _classPrivateFieldGet(this, y).has(t)
        }

        cleanup() {
          for (const e of this._pages) e.renderingState !== s.RenderingStates.FINISHED && e.reset()
        }

        _cancelRendering() {
          for (const e of this._pages) e.cancelRendering()
        }

        forceRendering(e) {
          const t = e || this._getVisiblePages()
          const i = _classPrivateMethodGet(this, B, _getScrollAhead2).call(this, t)
          const n =
            this._spreadMode !== s.SpreadMode.NONE && this._scrollMode !== s.ScrollMode.HORIZONTAL
          const a = this.renderingQueue.getHighestPriority(t, this._pages, i, n)
          _classPrivateMethodGet(this, G, _toggleLoadingIconSpinner2).call(this, t.ids)
          if (a) {
            _classPrivateMethodGet(this, N, _ensurePdfPageLoaded2)
              .call(this, a)
              .then(() => {
                this.renderingQueue.renderView(a)
              })
            return !0
          }
          return !1
        }

        createTextLayerBuilder(e) {
          const {
            textLayerDiv: t,
            pageIndex: i,
            viewport: n,
            enhanceTextSelection: s = !1,
            eventBus: a,
            highlighter: r,
            accessibilityManager: o = null
          } = e
          return new p.TextLayerBuilder({
            textLayerDiv: t,
            eventBus: a,
            pageIndex: i,
            viewport: n,
            enhanceTextSelection: !this.isInPresentationMode && s,
            highlighter: r,
            accessibilityManager: o
          })
        }

        createTextHighlighter(e) {
          const { pageIndex: t, eventBus: i } = e
          return new u.TextHighlighter({
            eventBus: i,
            pageIndex: t,
            findController: this.isInPresentationMode ? null : this.findController
          })
        }

        createAnnotationLayerBuilder(e) {
          let t
          let i
          let n
          let s
          const {
            pageDiv: a,
            pdfPage: l,
            annotationStorage: c = (t = this.pdfDocument) === null || void 0 === t
              ? void 0
              : t.annotationStorage,
            imageResourcesPath: d = '',
            renderForms: h = !0,
            l10n: u = o.NullL10n,
            enableScripting: p = this.enableScripting,
            hasJSActionsPromise: g = (i = this.pdfDocument) === null || void 0 === i
              ? void 0
              : i.hasJSActions(),
            mouseState: f = (n = this._scriptingManager) === null || void 0 === n
              ? void 0
              : n.mouseState,
            fieldObjectsPromise: m = (s = this.pdfDocument) === null || void 0 === s
              ? void 0
              : s.getFieldObjects(),
            annotationCanvasMap: v = null,
            accessibilityManager: _ = null
          } = e
          return new r.AnnotationLayerBuilder({
            pageDiv: a,
            pdfPage: l,
            annotationStorage: c,
            imageResourcesPath: d,
            renderForms: h,
            linkService: this.linkService,
            downloadManager: this.downloadManager,
            l10n: u,
            enableScripting: p,
            hasJSActionsPromise: g,
            mouseState: f,
            fieldObjectsPromise: m,
            annotationCanvasMap: v,
            accessibilityManager: _
          })
        }

        createAnnotationEditorLayerBuilder(e) {
          let t
          const {
            uiManager: i = _classPrivateFieldGet(this, A),
            pageDiv: n,
            pdfPage: s,
            accessibilityManager: r = null,
            l10n: o,
            annotationStorage: l = (t = this.pdfDocument) === null || void 0 === t
              ? void 0
              : t.annotationStorage
          } = e
          return new a.AnnotationEditorLayerBuilder({
            uiManager: i,
            pageDiv: n,
            pdfPage: s,
            annotationStorage: l,
            accessibilityManager: r,
            l10n: o
          })
        }

        createXfaLayerBuilder(e) {
          let t
          const {
            pageDiv: i,
            pdfPage: n,
            annotationStorage: s = (t = this.pdfDocument) === null || void 0 === t
              ? void 0
              : t.annotationStorage
          } = e
          return new g.XfaLayerBuilder({
            pageDiv: i,
            pdfPage: n,
            annotationStorage: s,
            linkService: this.linkService
          })
        }

        createStructTreeLayerBuilder(e) {
          const { pdfPage: t } = e
          return new h.StructTreeLayerBuilder({ pdfPage: t })
        }

        get hasEqualPageSizes() {
          const e = this._pages[0]
          for (let t = 1, i = this._pages.length; t < i; ++t) {
            const i = this._pages[t]
            if (i.width !== e.width || i.height !== e.height) return !1
          }
          return !0
        }

        getPagesOverview() {
          return this._pages.map((e) => {
            const t = e.pdfPage.getViewport({ scale: 1 })
            return !this.enablePrintAutoRotate || (0, s.isPortraitOrientation)(t)
              ? { width: t.width, height: t.height, rotation: t.rotation }
              : { width: t.height, height: t.width, rotation: (t.rotation - 90) % 360 }
          })
        }

        get optionalContentConfigPromise() {
          if (!this.pdfDocument) return Promise.resolve(null)
          if (!this._optionalContentConfigPromise) {
            console.error('optionalContentConfigPromise: Not initialized yet.')
            return this.pdfDocument.getOptionalContentConfig()
          }
          return this._optionalContentConfigPromise
        }

        set optionalContentConfigPromise(e) {
          if (!(e instanceof Promise)) throw new Error(`Invalid optionalContentConfigPromise: ${e}`)
          if (!this.pdfDocument) return
          if (!this._optionalContentConfigPromise) return
          this._optionalContentConfigPromise = e
          const t = { optionalContentConfigPromise: e }
          for (const e of this._pages) e.update(t)
          this.update()
          this.eventBus.dispatch('optionalcontentconfigchanged', { source: this, promise: e })
        }

        get scrollMode() {
          return this._scrollMode
        }

        set scrollMode(e) {
          if (this._scrollMode !== e) {
            if (!(0, s.isValidScrollMode)(e)) throw new Error(`Invalid scroll mode: ${e}`)
            if (!(this.pagesCount > _.FORCE_SCROLL_MODE_PAGE)) {
              this._previousScrollMode = this._scrollMode
              this._scrollMode = e
              this.eventBus.dispatch('scrollmodechanged', { source: this, mode: e })
              this._updateScrollMode(this._currentPageNumber)
            }
          }
        }

        _updateScrollMode() {
          const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
          const t = this._scrollMode
          const i = this.viewer
          i.classList.toggle('scrollHorizontal', t === s.ScrollMode.HORIZONTAL)
          i.classList.toggle('scrollWrapped', t === s.ScrollMode.WRAPPED)
          if (this.pdfDocument && e) {
            t === s.ScrollMode.PAGE
              ? _classPrivateMethodGet(this, D, _ensurePageViewVisible2).call(this)
              : this._previousScrollMode === s.ScrollMode.PAGE && this._updateSpreadMode()
            this._currentScaleValue &&
              isNaN(this._currentScaleValue) &&
              this._setScale(this._currentScaleValue, !0)
            this._setCurrentPageNumber(e, !0)
            this.update()
          }
        }

        get spreadMode() {
          return this._spreadMode
        }

        set spreadMode(e) {
          if (this._spreadMode !== e) {
            if (!(0, s.isValidSpreadMode)(e)) throw new Error(`Invalid spread mode: ${e}`)
            this._spreadMode = e
            this.eventBus.dispatch('spreadmodechanged', { source: this, mode: e })
            this._updateSpreadMode(this._currentPageNumber)
          }
        }

        _updateSpreadMode() {
          const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
          if (!this.pdfDocument) return
          const t = this.viewer
          const i = this._pages
          if (this._scrollMode === s.ScrollMode.PAGE)
            _classPrivateMethodGet(this, D, _ensurePageViewVisible2).call(this)
          else {
            t.textContent = ''
            if (this._spreadMode === s.SpreadMode.NONE) for (const e of this._pages) t.append(e.div)
            else {
              const e = this._spreadMode - 1
              let n = null
              for (let s = 0, a = i.length; s < a; ++s) {
                if (n === null) {
                  n = document.createElement('div')
                  n.className = 'spread'
                  t.append(n)
                } else if (s % 2 === e) {
                  n = n.cloneNode(!1)
                  t.append(n)
                }
                n.append(i[s].div)
              }
            }
          }
          if (e) {
            this._currentScaleValue &&
              isNaN(this._currentScaleValue) &&
              this._setScale(this._currentScaleValue, !0)
            this._setCurrentPageNumber(e, !0)
            this.update()
          }
        }

        _getPageAdvance(e) {
          const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
          switch (this._scrollMode) {
            case s.ScrollMode.WRAPPED: {
              const { views: i } = this._getVisiblePages()
              const n = new Map()
              for (const { id: e, y: t, percent: s, widthPercent: a } of i) {
                if (s === 0 || a < 100) continue
                let i = n.get(t)
                i || n.set(t, i || (i = []))
                i.push(e)
              }
              for (const i of n.values()) {
                const n = i.indexOf(e)
                if (n === -1) continue
                const s = i.length
                if (s === 1) break
                if (t)
                  for (let t = n - 1, s = 0; t >= s; t--) {
                    const n = i[t]
                    const s = i[t + 1] - 1
                    if (n < s) return e - s
                  }
                else
                  for (let t = n + 1, a = s; t < a; t++) {
                    const n = i[t]
                    const s = i[t - 1] + 1
                    if (n > s) return s - e
                  }
                if (t) {
                  const t = i[0]
                  if (t < e) return e - t + 1
                } else {
                  const t = i[s - 1]
                  if (t > e) return t - e + 1
                }
                break
              }
              break
            }
            case s.ScrollMode.HORIZONTAL:
              break
            case s.ScrollMode.PAGE:
            case s.ScrollMode.VERTICAL: {
              if (this._spreadMode === s.SpreadMode.NONE) break
              const i = this._spreadMode - 1
              if (t && e % 2 !== i) break
              if (!t && e % 2 === i) break
              const { views: n } = this._getVisiblePages()
              const a = t ? e - 1 : e + 1
              for (const { id: e, percent: t, widthPercent: i } of n)
                if (e === a) {
                  if (t > 0 && i === 100) return 2
                  break
                }
              break
            }
          }
          return 1
        }

        nextPage() {
          const e = this._currentPageNumber
          const t = this.pagesCount
          if (e >= t) return !1
          const i = this._getPageAdvance(e, !1) || 1
          this.currentPageNumber = Math.min(e + i, t)
          return !0
        }

        previousPage() {
          const e = this._currentPageNumber
          if (e <= 1) return !1
          const t = this._getPageAdvance(e, !0) || 1
          this.currentPageNumber = Math.max(e - t, 1)
          return !0
        }

        increaseScale() {
          let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1
          let t = this._currentScale
          do {
            t = (t * s.DEFAULT_SCALE_DELTA).toFixed(2)
            t = Math.ceil(10 * t) / 10
            t = Math.min(s.MAX_SCALE, t)
          } while (--e > 0 && t < s.MAX_SCALE)
          this.currentScaleValue = t
        }

        decreaseScale() {
          let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1
          let t = this._currentScale
          do {
            t = (t / s.DEFAULT_SCALE_DELTA).toFixed(2)
            t = Math.floor(10 * t) / 10
            t = Math.max(s.MIN_SCALE, t)
          } while (--e > 0 && t > s.MIN_SCALE)
          this.currentScaleValue = t
        }

        updateContainerHeightCss() {
          const e = this.container.clientHeight
          if (e !== _classPrivateFieldGet(this, C)) {
            _classPrivateFieldSet(this, C, e)
            s.docStyle.setProperty('--viewer-container-height', `${e}px`)
          }
        }

        get annotationEditorMode() {
          return _classPrivateFieldGet(this, A)
            ? _classPrivateFieldGet(this, S)
            : n.AnnotationEditorType.DISABLE
        }

        set annotationEditorMode(e) {
          if (!_classPrivateFieldGet(this, A))
            throw new Error('The AnnotationEditor is not enabled.')
          if (_classPrivateFieldGet(this, S) !== e) {
            if (!isValidAnnotationEditorMode(e))
              throw new Error(`Invalid AnnotationEditor mode: ${e}`)
            if (this.pdfDocument) {
              _classPrivateFieldSet(this, S, e)
              this.eventBus.dispatch('annotationeditormodechanged', { source: this, mode: e })
              _classPrivateFieldGet(this, A).updateMode(e)
            }
          }
        }

        set annotationEditorParams(e) {
          const { type: t, value: i } = e
          if (!_classPrivateFieldGet(this, A))
            throw new Error('The AnnotationEditor is not enabled.')
          _classPrivateFieldGet(this, A).updateParams(t, i)
        }

        refresh() {
          if (!this.pdfDocument) return
          const e = {}
          for (const t of this._pages) t.update(e)
          this.update()
        }
      }
      t.BaseViewer = BaseViewer
      function _initializePermissions2(e) {
        const t = {
          annotationEditorMode: _classPrivateFieldGet(this, S),
          annotationMode: _classPrivateFieldGet(this, E),
          textLayerMode: this.textLayerMode
        }
        if (!e) return t
        e.includes(n.PermissionFlag.COPY) || this.viewer.classList.add(v)
        e.includes(n.PermissionFlag.MODIFY_CONTENTS) ||
          (t.annotationEditorMode = n.AnnotationEditorType.DISABLE)
        e.includes(n.PermissionFlag.MODIFY_ANNOTATIONS) ||
          e.includes(n.PermissionFlag.FILL_INTERACTIVE_FORMS) ||
          _classPrivateFieldGet(this, E) !== n.AnnotationMode.ENABLE_FORMS ||
          (t.annotationMode = n.AnnotationMode.ENABLE)
        return t
      }
      function _onePageRenderedOrForceFetch2() {
        if (
          document.visibilityState === 'hidden' ||
          !this.container.offsetParent ||
          this._getVisiblePages().views.length === 0
        )
          return Promise.resolve()
        const e = new Promise((e) => {
          _classPrivateFieldSet(this, T, () => {
            if (document.visibilityState === 'hidden') {
              e()
              document.removeEventListener('visibilitychange', _classPrivateFieldGet(this, T))
              _classPrivateFieldSet(this, T, null)
            }
          })
          document.addEventListener('visibilitychange', _classPrivateFieldGet(this, T))
        })
        return Promise.race([this._onePageRenderedCapability.promise, e])
      }
      function _ensurePageViewVisible2() {
        if (this._scrollMode !== s.ScrollMode.PAGE)
          throw new Error('#ensurePageViewVisible: Invalid scrollMode value.')
        const e = this._currentPageNumber
        const t = _classPrivateFieldGet(this, M)
        const i = this.viewer
        i.textContent = ''
        t.pages.length = 0
        if (this._spreadMode !== s.SpreadMode.NONE || this.isInPresentationMode) {
          const n = new Set()
          const s = this._spreadMode - 1
          if (s === -1) n.add(e - 1)
          else if (e % 2 !== s) {
            n.add(e - 1)
            n.add(e)
          } else {
            n.add(e - 2)
            n.add(e - 1)
          }
          const a = document.createElement('div')
          a.className = 'spread'
          if (this.isInPresentationMode) {
            const e = document.createElement('div')
            e.className = 'dummyPage'
            a.append(e)
          }
          for (const e of n) {
            const i = this._pages[e]
            if (i) {
              a.append(i.div)
              t.pages.push(i)
            }
          }
          i.append(a)
        } else {
          const n = this._pages[e - 1]
          i.append(n.div)
          t.pages.push(n)
        }
        t.scrollDown = e >= t.previousPageNumber
        t.previousPageNumber = e
      }
      function _scrollIntoView2(e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
        const { div: i, id: n } = e
        if (this._scrollMode === s.ScrollMode.PAGE) {
          this._setCurrentPageNumber(n)
          _classPrivateMethodGet(this, D, _ensurePageViewVisible2).call(this)
          this.update()
        }
        if (!t && !this.isInPresentationMode) {
          const e = i.offsetLeft + i.clientLeft
          const n = e + i.clientWidth
          const { scrollLeft: a, clientWidth: r } = this.container
          ;(this._scrollMode === s.ScrollMode.HORIZONTAL || e < a || n > a + r) &&
            (t = { left: 0, top: 0 })
        }
        ;(0, s.scrollIntoView)(i, t)
      }
      function _isSameScale2(e) {
        return e === this._currentScale || Math.abs(e - this._currentScale) < 1e-15
      }
      function _resetCurrentPageView2() {
        const e = this._pages[this._currentPageNumber - 1]
        this.isInPresentationMode && this._setScale(this._currentScaleValue, !0)
        _classPrivateMethodGet(this, L, _scrollIntoView2).call(this, e)
      }
      async function _ensurePdfPageLoaded2(e) {
        if (e.pdfPage) return e.pdfPage
        try {
          let t
          let i
          const n = await this.pdfDocument.getPage(e.id)
          e.pdfPage || e.setPdfPage(n)
          ;((t = (i = this.linkService)._cachedPageNumber) !== null &&
            void 0 !== t &&
            t.call(i, n.ref)) ||
            this.linkService.cachePageRef(e.id, n.ref)
          return n
        } catch (e) {
          console.error('Unable to get page for page view', e)
          return null
        }
      }
      function _getScrollAhead2(e) {
        let t
        let i
        if (((t = e.first) === null || void 0 === t ? void 0 : t.id) === 1) return !0
        if (((i = e.last) === null || void 0 === i ? void 0 : i.id) === this.pagesCount) return !1
        switch (this._scrollMode) {
          case s.ScrollMode.PAGE:
            return _classPrivateFieldGet(this, M).scrollDown
          case s.ScrollMode.HORIZONTAL:
            return this.scroll.right
        }
        return this.scroll.down
      }
      function _toggleLoadingIconSpinner2(e) {
        for (const t of e) {
          const e = this._pages[t - 1]
          e == null || e.toggleLoadingIconSpinner(!0)
        }
        for (const t of _classPrivateFieldGet(this, y))
          e.has(t.id) || t.toggleLoadingIconSpinner(!1)
      }
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.AnnotationEditorLayerBuilder = void 0
      const n = i(5)
      const s = i(32)
      function _classPrivateFieldInitSpec(e, t, i) {
        !(function _checkPrivateRedeclaration(e, t) {
          if (t.has(e))
            throw new TypeError('Cannot initialize the same private elements twice on an object')
        })(e, t)
        t.set(e, i)
      }
      function _classPrivateFieldSet(e, t, i) {
        !(function _classApplyDescriptorSet(e, t, i) {
          if (t.set) t.set.call(e, i)
          else {
            if (!t.writable) throw new TypeError('attempted to set read only private field')
            t.value = i
          }
        })(e, _classExtractFieldDescriptor(e, t, 'set'), i)
        return i
      }
      function _classExtractFieldDescriptor(e, t, i) {
        if (!t.has(e)) throw new TypeError(`attempted to ${i} private field on non-instance`)
        return t.get(e)
      }
      const a = new WeakMap()
      t.AnnotationEditorLayerBuilder = class AnnotationEditorLayerBuilder {
        constructor(e) {
          _classPrivateFieldInitSpec(this, a, { writable: !0, value: void 0 })
          this.pageDiv = e.pageDiv
          this.pdfPage = e.pdfPage
          this.annotationStorage = e.annotationStorage || null
          this.accessibilityManager = e.accessibilityManager
          this.l10n = e.l10n || s.NullL10n
          this.annotationEditorLayer = null
          this.div = null
          this._cancelled = !1
          _classPrivateFieldSet(this, a, e.uiManager)
        }

        async render(e) {
          const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'display'
          if (t !== 'display') return
          if (this._cancelled) return
          const i = e.clone({ dontFlip: !0 })
          if (this.div) {
            this.annotationEditorLayer.update({ viewport: i })
            this.show()
            return
          }
          this.div = document.createElement('div')
          this.div.className = 'annotationEditorLayer'
          this.div.tabIndex = 0
          this.pageDiv.append(this.div)
          this.annotationEditorLayer = new n.AnnotationEditorLayer({
            uiManager:
              ((s = this),
              (r = a),
              (function _classApplyDescriptorGet(e, t) {
                return t.get ? t.get.call(e) : t.value
              })(s, _classExtractFieldDescriptor(s, r, 'get'))),
            div: this.div,
            annotationStorage: this.annotationStorage,
            accessibilityManager: this.accessibilityManager,
            pageIndex: this.pdfPage._pageIndex,
            l10n: this.l10n,
            viewport: i
          })
          let s
          let r
          const o = { viewport: i, div: this.div, annotations: null, intent: t }
          this.annotationEditorLayer.render(o)
        }

        cancel() {
          this._cancelled = !0
          this.destroy()
        }

        hide() {
          this.div && (this.div.hidden = !0)
        }

        show() {
          this.div && (this.div.hidden = !1)
        }

        destroy() {
          if (this.div) {
            this.pageDiv = null
            this.annotationEditorLayer.destroy()
            this.div.remove()
          }
        }
      }
    },
    (e, t) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.NullL10n = void 0
      t.fixupLangCode = function fixupLangCode(e) {
        return n[e == null ? void 0 : e.toLowerCase()] || e
      }
      t.getL10nFallback = getL10nFallback
      const i = {
        of_pages: 'of {{pagesCount}}',
        page_of_pages: '({{pageNumber}} of {{pagesCount}})',
        document_properties_kb: '{{size_kb}} KB ({{size_b}} bytes)',
        document_properties_mb: '{{size_mb}} MB ({{size_b}} bytes)',
        document_properties_date_string: '{{date}}, {{time}}',
        document_properties_page_size_unit_inches: 'in',
        document_properties_page_size_unit_millimeters: 'mm',
        document_properties_page_size_orientation_portrait: 'portrait',
        document_properties_page_size_orientation_landscape: 'landscape',
        document_properties_page_size_name_a3: 'A3',
        document_properties_page_size_name_a4: 'A4',
        document_properties_page_size_name_letter: 'Letter',
        document_properties_page_size_name_legal: 'Legal',
        document_properties_page_size_dimension_string:
          '{{width}} × {{height}} {{unit}} ({{orientation}})',
        document_properties_page_size_dimension_name_string:
          '{{width}} × {{height}} {{unit}} ({{name}}, {{orientation}})',
        document_properties_linearized_yes: 'Yes',
        document_properties_linearized_no: 'No',
        print_progress_percent: '{{progress}}%',
        'toggle_sidebar.title': 'Toggle Sidebar',
        'toggle_sidebar_notification2.title':
          'Toggle Sidebar (document contains outline/attachments/layers)',
        additional_layers: 'Additional Layers',
        page_landmark: 'Page {{page}}',
        thumb_page_title: 'Page {{page}}',
        thumb_page_canvas: 'Thumbnail of Page {{page}}',
        find_reached_top: 'Reached top of document, continued from bottom',
        find_reached_bottom: 'Reached end of document, continued from top',
        'find_match_count[one]': '{{current}} of {{total}} match',
        'find_match_count[other]': '{{current}} of {{total}} matches',
        'find_match_count_limit[one]': 'More than {{limit}} match',
        'find_match_count_limit[other]': 'More than {{limit}} matches',
        find_not_found: 'Phrase not found',
        error_version_info: 'PDF.js v{{version}} (build: {{build}})',
        error_message: 'Message: {{message}}',
        error_stack: 'Stack: {{stack}}',
        error_file: 'File: {{file}}',
        error_line: 'Line: {{line}}',
        rendering_error: 'An error occurred while rendering the page.',
        page_scale_width: 'Page Width',
        page_scale_fit: 'Page Fit',
        page_scale_auto: 'Automatic Zoom',
        page_scale_actual: 'Actual Size',
        page_scale_percent: '{{scale}}%',
        loading: 'Loading…',
        loading_error: 'An error occurred while loading the PDF.',
        invalid_file_error: 'Invalid or corrupted PDF file.',
        missing_file_error: 'Missing PDF file.',
        unexpected_response_error: 'Unexpected server response.',
        printing_not_supported: 'Warning: Printing is not fully supported by this browser.',
        printing_not_ready: 'Warning: The PDF is not fully loaded for printing.',
        web_fonts_disabled: 'Web fonts are disabled: unable to use embedded PDF fonts.',
        free_text_default_content: 'Enter text…',
        editor_free_text_aria_label: 'FreeText Editor',
        editor_ink_aria_label: 'Ink Editor',
        editor_ink_canvas_aria_label: 'User-created image'
      }
      function getL10nFallback(e, t) {
        switch (e) {
          case 'find_match_count':
            e = `find_match_count[${t.total === 1 ? 'one' : 'other'}]`
            break
          case 'find_match_count_limit':
            e = `find_match_count_limit[${t.limit === 1 ? 'one' : 'other'}]`
        }
        return i[e] || ''
      }
      const n = {
        en: 'en-US',
        es: 'es-ES',
        fy: 'fy-NL',
        ga: 'ga-IE',
        gu: 'gu-IN',
        hi: 'hi-IN',
        hy: 'hy-AM',
        nb: 'nb-NO',
        ne: 'ne-NP',
        nn: 'nn-NO',
        pa: 'pa-IN',
        pt: 'pt-PT',
        sv: 'sv-SE',
        zh: 'zh-CN'
      }
      const s = {
        getLanguage: async () => 'en-us',
        getDirection: async () => 'ltr',
        async get(e) {
          const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
          return (function formatL10nValue(e, t) {
            return t ? e.replace(/\{\{\s*(\w+)\s*\}\}/g, (e, i) => (i in t ? t[i] : `{{${i}}}`)) : e
          })(
            arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : getL10nFallback(e, t),
            t
          )
        },
        async translate(e) {}
      }
      t.NullL10n = s
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.AnnotationLayerBuilder = void 0
      const n = i(5)
      const s = i(32)
      t.AnnotationLayerBuilder = class AnnotationLayerBuilder {
        constructor(e) {
          const {
            pageDiv: t,
            pdfPage: i,
            linkService: n,
            downloadManager: a,
            annotationStorage: r = null,
            imageResourcesPath: o = '',
            renderForms: l = !0,
            l10n: c = s.NullL10n,
            enableScripting: d = !1,
            hasJSActionsPromise: h = null,
            fieldObjectsPromise: u = null,
            mouseState: p = null,
            annotationCanvasMap: g = null,
            accessibilityManager: f = null
          } = e
          this.pageDiv = t
          this.pdfPage = i
          this.linkService = n
          this.downloadManager = a
          this.imageResourcesPath = o
          this.renderForms = l
          this.l10n = c
          this.annotationStorage = r
          this.enableScripting = d
          this._hasJSActionsPromise = h
          this._fieldObjectsPromise = u
          this._mouseState = p
          this._annotationCanvasMap = g
          this._accessibilityManager = f
          this.div = null
          this._cancelled = !1
        }

        async render(e) {
          const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'display'
          const [i, s = !1, a = null] = await Promise.all([
            this.pdfPage.getAnnotations({ intent: t }),
            this._hasJSActionsPromise,
            this._fieldObjectsPromise
          ])
          if (this._cancelled || i.length === 0) return
          const r = {
            viewport: e.clone({ dontFlip: !0 }),
            div: this.div,
            annotations: i,
            page: this.pdfPage,
            imageResourcesPath: this.imageResourcesPath,
            renderForms: this.renderForms,
            linkService: this.linkService,
            downloadManager: this.downloadManager,
            annotationStorage: this.annotationStorage,
            enableScripting: this.enableScripting,
            hasJSActions: s,
            fieldObjects: a,
            mouseState: this._mouseState,
            annotationCanvasMap: this._annotationCanvasMap,
            accessibilityManager: this._accessibilityManager
          }
          if (this.div) n.AnnotationLayer.update(r)
          else {
            this.div = document.createElement('div')
            this.div.className = 'annotationLayer'
            this.pageDiv.append(this.div)
            r.div = this.div
            n.AnnotationLayer.render(r)
            this.l10n.translate(this.div)
          }
        }

        cancel() {
          this._cancelled = !0
        }

        hide() {
          this.div && (this.div.hidden = !0)
        }
      }
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.PDFPageView = void 0
      const n = i(5)
      const s = i(1)
      const a = i(2)
      const r = i(32)
      const o = i(35)
      const l = i(36)
      const c = i(37)
      function _classPrivateFieldInitSpec(e, t, i) {
        !(function _checkPrivateRedeclaration(e, t) {
          if (t.has(e))
            throw new TypeError('Cannot initialize the same private elements twice on an object')
        })(e, t)
        t.set(e, i)
      }
      function _classPrivateFieldGet(e, t) {
        return (function _classApplyDescriptorGet(e, t) {
          if (t.get) return t.get.call(e)
          return t.value
        })(e, _classExtractFieldDescriptor(e, t, 'get'))
      }
      function _classPrivateFieldSet(e, t, i) {
        !(function _classApplyDescriptorSet(e, t, i) {
          if (t.set) t.set.call(e, i)
          else {
            if (!t.writable) throw new TypeError('attempted to set read only private field')
            t.value = i
          }
        })(e, _classExtractFieldDescriptor(e, t, 'set'), i)
        return i
      }
      function _classExtractFieldDescriptor(e, t, i) {
        if (!t.has(e)) throw new TypeError(`attempted to ${i} private field on non-instance`)
        return t.get(e)
      }
      const d = a.compatibilityParams.maxCanvasPixels || 16777216
      const h = new WeakMap()
      const u = new WeakMap()
      t.PDFPageView = class PDFPageView {
        constructor(e) {
          let t
          let i
          let a
          let o
          _classPrivateFieldInitSpec(this, h, {
            writable: !0,
            value: n.AnnotationMode.ENABLE_FORMS
          })
          _classPrivateFieldInitSpec(this, u, {
            writable: !0,
            value: { initialOptionalContent: !0, regularAnnotations: !0 }
          })
          const l = e.container
          const c = e.defaultViewport
          this.id = e.id
          this.renderingId = `page${this.id}`
          this.pdfPage = null
          this.pageLabel = null
          this.rotation = 0
          this.scale = e.scale || s.DEFAULT_SCALE
          this.viewport = c
          this.pdfPageRotate = c.rotation
          this._optionalContentConfigPromise = e.optionalContentConfigPromise || null
          this.hasRestrictedScaling = !1
          this.textLayerMode =
            (t = e.textLayerMode) !== null && void 0 !== t ? t : s.TextLayerMode.ENABLE
          _classPrivateFieldSet(
            this,
            h,
            (i = e.annotationMode) !== null && void 0 !== i ? i : n.AnnotationMode.ENABLE_FORMS
          )
          this.imageResourcesPath = e.imageResourcesPath || ''
          this.useOnlyCssZoom = e.useOnlyCssZoom || !1
          this.maxCanvasPixels = e.maxCanvasPixels || d
          this.pageColors = e.pageColors || null
          this.eventBus = e.eventBus
          this.renderingQueue = e.renderingQueue
          this.textLayerFactory = e.textLayerFactory
          this.annotationLayerFactory = e.annotationLayerFactory
          this.annotationEditorLayerFactory = e.annotationEditorLayerFactory
          this.xfaLayerFactory = e.xfaLayerFactory
          this.textHighlighter =
            (a = e.textHighlighterFactory) === null || void 0 === a
              ? void 0
              : a.createTextHighlighter({ pageIndex: this.id - 1, eventBus: this.eventBus })
          this.structTreeLayerFactory = e.structTreeLayerFactory
          this.renderer = e.renderer || s.RendererType.CANVAS
          this.l10n = e.l10n || r.NullL10n
          this.paintTask = null
          this.paintedViewportMap = new WeakMap()
          this.renderingState = s.RenderingStates.INITIAL
          this.resume = null
          this._renderError = null
          this._isStandalone = !(
            (o = this.renderingQueue) !== null &&
            void 0 !== o &&
            o.hasViewer()
          )
          this._annotationCanvasMap = null
          this.annotationLayer = null
          this.annotationEditorLayer = null
          this.textLayer = null
          this.zoomLayer = null
          this.xfaLayer = null
          this.structTreeLayer = null
          const p = document.createElement('div')
          p.className = 'page'
          p.style.width = `${Math.floor(this.viewport.width)}px`
          p.style.height = `${Math.floor(this.viewport.height)}px`
          p.setAttribute('data-page-number', this.id)
          p.setAttribute('role', 'region')
          this.l10n.get('page_landmark', { page: this.id }).then((e) => {
            p.setAttribute('aria-label', e)
          })
          this.div = p
          l == null || l.append(p)
          if (this._isStandalone) {
            const { optionalContentConfigPromise: t } = e
            t &&
              t.then((e) => {
                t === this._optionalContentConfigPromise &&
                  (_classPrivateFieldGet(this, u).initialOptionalContent = e.hasInitialVisibility)
              })
          }
          this.initCanvasSnapShot = null
          this.annotSnapShot = null
          this.anInfoArray = new Array()
          this.rightClickedAnnot = null
          this.sigStatusArray = new Array()
        }

        setPdfPage(e) {
          this.pdfPage = e
          this.pdfPageRotate = e.rotate
          const t = (this.rotation + this.pdfPageRotate) % 360
          this.viewport = e.getViewport({
            scale: this.scale * n.PixelsPerInch.PDF_TO_CSS_UNITS,
            rotation: t
          })
          this.reset()
        }

        destroy() {
          this.reset()
          this.pdfPage && this.pdfPage.cleanup()
        }

        async _renderAnnotationLayer() {
          let e = null
          try {
            await this.annotationLayer.render(this.viewport, 'display')
          } catch (t) {
            console.error(`_renderAnnotationLayer: "${t}".`)
            e = t
          } finally {
            this.eventBus.dispatch('annotationlayerrendered', {
              source: this,
              pageNumber: this.id,
              error: e
            })
          }
        }

        async _renderAnnotationEditorLayer() {
          let e = null
          try {
            await this.annotationEditorLayer.render(this.viewport, 'display')
          } catch (t) {
            console.error(`_renderAnnotationEditorLayer: "${t}".`)
            e = t
          } finally {
            this.eventBus.dispatch('annotationeditorlayerrendered', {
              source: this,
              pageNumber: this.id,
              error: e
            })
          }
        }

        async _renderXfaLayer() {
          let e = null
          try {
            const t = await this.xfaLayer.render(this.viewport, 'display')
            this.textHighlighter && this._buildXfaTextContentItems(t.textDivs)
          } catch (t) {
            console.error(`_renderXfaLayer: "${t}".`)
            e = t
          } finally {
            this.eventBus.dispatch('xfalayerrendered', {
              source: this,
              pageNumber: this.id,
              error: e
            })
          }
        }

        async _buildXfaTextContentItems(e) {
          const t = await this.pdfPage.getTextContent()
          const i = []
          for (const e of t.items) i.push(e.str)
          this.textHighlighter.setTextMapping(e, i)
          this.textHighlighter.enable()
        }

        saveInitPageSnapShot() {
          ;(0, l.log_debug)('save inint page snapshot')
          const e = this.canvas.getContext('2d')
          this.initCanvasSnapShot = e.getImageData(0, 0, this.canvas.width, this.canvas.height)
        }

        restoreInitPageSnapShot() {
          if (this.initCanvasSnapShot == null) return
          this.canvas.getContext('2d').putImageData(this.initCanvasSnapShot, 0, 0)
        }

        saveSnapShot() {
          ;(0, l.log_debug)('save canvas snapshot')
          const e = this.canvas.getContext('2d')
          this.annotSnapShot = e.getImageData(0, 0, this.canvas.width, this.canvas.height)
        }

        restoreSnapShot() {
          if (this.canvas == null || this.canvas == null) return
          if (this.annotSnapShot == null) return
          this.canvas.getContext('2d').putImageData(this.annotSnapShot, 0, 0)
        }

        putBjcaAnnotInfo(e) {
          this.anInfoArray.push(e)
        }

        addBjcaAnnotInfo(e) {
          this.anInfoArray.push(e)
          ;(0, c.dispatchCustomEvent)('addBjcaAnnot', e, parent.document)
        }

        lookupBjcaAnnot(e) {
          for (let t = 0; t < this.anInfoArray.length; ++t)
            if (this.anInfoArray[t].id == e) return t
          return -1
        }

        deleteBjcaAnnotInfo(e) {
          if (e < 0 || e >= this.anInfoArray.length) {
            ;(0, l.log_error)(
              `deleteBjcaAnnotInfo: annot index is invalid, index = ${e}, input id = ${t}`
            )
            ;(0, c.dispatchError)(parent.document, c.ErrorCode[0])
          } else {
            document.focusAn != null &&
              document.focusAn.id == this.anInfoArray[e].id &&
              (document.focusAn = null)
            var t = this.anInfoArray[e].id
            this.anInfoArray.splice(e, 1)
            ;(0, c.dispatchCustomEvent)(
              'delBjcaAnnot',
              { id: t, pageNumber: this.id },
              parent.document
            )
          }
        }

        setFocusBjcaAnnot(e) {
          const t = this.lookupBjcaAnnot(e)
          if (t < 0 || t >= this.anInfoArray.length) {
            ;(0, l.log_error)(
              `setFocusBjcaAnnot: annot index is invalid, index = ${t}, input id = ${e}`
            )
            ;(0, c.dispatchError)(parent.document, c.ErrorCode[0])
          } else {
            this.restoreSnapShot()
            const i = this.anInfoArray[t]
            if (
              void 0 !== document.focusAn &&
              document.focusAn !== null &&
              document.focusAn.page !== i.page
            ) {
              window.PDFViewerApplication.pdfViewer
                .getPageView(document.focusAn.page - 1)
                .restoreSnapShot()
            }
            this.focusBjcaAnnot(i)
          }
        }

        focusBjcaAnnot(e) {
          e.drawBorder(this.canvas)
          document.focusAn = e
        }

        getBjcaAnnotInfo(e) {
          return this.anInfoArray.length == 0 || this.anInfoArray.length <= e
            ? null
            : this.anInfoArray[e]
        }

        redrawPageAnnot() {
          for (var e = !1, t = 0; t < this.anInfoArray.length; ++t) {
            this.anInfoArray[t].draw(this.canvas)
            e = !0
          }
          return e
        }

        redrawSignture() {
          for (let e = 0; e < this.sigStatusArray.length; ++e)
            this.drawSignatureStatus(this.sigStatusArray[e])
        }

        drawSignatureStatus(e) {
          if (this.annotationLayer == null) {
            ;(0, l.log_error)(
              'setSignatureStatus: there is no signature in doc or call this method too early'
            )
            ;(0, c.dispatchError)(parent.document, c.ErrorCode[4])
            return !1
          }
          if (this.canvas == null) {
            ;(0, l.log_error)('setSignatureStatus: canvas is null')
            return !1
          }
          const t = document.getElementsByName(e)
          if (!t) {
            ;(0, l.log_error)(`cannot get element ${e}`)
            return !1
          }
          const i = this.canvas.getContext('2d')
          i.save()
          i.beginPath()
          i.globalAlpha = 0.5
          const n = this.canvas.getBoundingClientRect().left
          const s = this.canvas.getBoundingClientRect().top
          let a = t[0].getBoundingClientRect().left - n
          let r = t[0].getBoundingClientRect().top - s
          let o = t[0].getBoundingClientRect().bottom - s
          let d = t[0].getBoundingClientRect().right - n
          const h = d - a
          const u = o - r
          const p = Math.max(u, h)
          i.lineWidth = p / 10
          i.lineWidth <= 5 && (i.lineWidth = 5)
          const g = Math.min(u, h)
          a += (h - g) / 2
          d -= (h - g) / 2
          o -= (u - g) / 2
          r += (u - g) / 2
          i.scale(this.outputScale.sx, this.outputScale.sy)
          i.lineCap = 'round'
          i.shadowOffsetX = 15
          i.shadowOffsetY = 15
          i.shadowBlur = 14
          i.shadowColor = 'rgba(0, 0, 0, 0.5)'
          i.strokeStyle = 'red'
          i.moveTo(a, r)
          i.lineTo(d, o)
          i.moveTo(a, o)
          i.lineTo(d, r)
          i.stroke()
          i.restore()
          this.addSigStatusArray(e)
          this.saveSnapShot()
          return !0
        }

        lookupSigStatusArray(e) {
          for (let t = 0; t < this.sigStatusArray.length; ++t)
            if (this.sigStatusArray[t] == e) return t
          return -1
        }

        addSigStatusArray(e) {
          if (this.lookupSigStatusArray(e) != -1) return !1
          this.sigStatusArray.push(e)
          return !0
        }

        setSignatureStatus(e) {
          return this.lookupSigStatusArray(e) == -1 && this.drawSignatureStatus(e)
        }

        _resetZoomLayer() {
          const e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
          if (!this.zoomLayer) return
          const t = this.zoomLayer.firstChild
          this.paintedViewportMap.delete(t)
          t.width = 0
          t.height = 0
          e && this.zoomLayer.remove()
          this.zoomLayer = null
        }

        reset() {
          let e
          let t
          let i
          const {
            keepZoomLayer: n = !1,
            keepAnnotationLayer: a = !1,
            keepAnnotationEditorLayer: r = !1,
            keepXfaLayer: o = !1
          } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
          this.cancelRendering({
            keepAnnotationLayer: a,
            keepAnnotationEditorLayer: r,
            keepXfaLayer: o
          })
          this.renderingState = s.RenderingStates.INITIAL
          const l = this.div
          l.style.width = `${Math.floor(this.viewport.width)}px`
          l.style.height = `${Math.floor(this.viewport.height)}px`
          const c = l.childNodes
          const d = (n && this.zoomLayer) || null
          const h =
            (a && ((e = this.annotationLayer) === null || void 0 === e ? void 0 : e.div)) || null
          const u =
            (r && ((t = this.annotationEditorLayer) === null || void 0 === t ? void 0 : t.div)) ||
            null
          const p = (o && ((i = this.xfaLayer) === null || void 0 === i ? void 0 : i.div)) || null
          for (let e = c.length - 1; e >= 0; e--) {
            const t = c[e]
            switch (t) {
              case d:
              case h:
              case u:
              case p:
                continue
            }
            t.remove()
          }
          l.removeAttribute('data-loaded')
          h && this.annotationLayer.hide()
          if (u) this.annotationEditorLayer.hide()
          else {
            let g
            ;(g = this.annotationEditorLayer) === null || void 0 === g || g.destroy()
          }
          p && this.xfaLayer.hide()
          if (!d) {
            if (this.canvas) {
              this.paintedViewportMap.delete(this.canvas)
              this.canvas.width = 0
              this.canvas.height = 0
              delete this.canvas
            }
            this._resetZoomLayer()
          }
          if (this.svg) {
            this.paintedViewportMap.delete(this.svg)
            delete this.svg
          }
          this.loadingIconDiv = document.createElement('div')
          this.loadingIconDiv.className = 'loadingIcon notVisible'
          this._isStandalone && this.toggleLoadingIconSpinner(!0)
          this.loadingIconDiv.setAttribute('role', 'img')
          this.l10n.get('loading').then((e) => {
            let t
            ;(t = this.loadingIconDiv) === null || void 0 === t || t.setAttribute('aria-label', e)
          })
          l.append(this.loadingIconDiv)
        }

        update(e) {
          const { scale: t = 0, rotation: i = null, optionalContentConfigPromise: a = null } = e
          this.scale = t || this.scale
          typeof i === 'number' && (this.rotation = i)
          if (a instanceof Promise) {
            this._optionalContentConfigPromise = a
            a.then((e) => {
              a === this._optionalContentConfigPromise &&
                (_classPrivateFieldGet(this, u).initialOptionalContent = e.hasInitialVisibility)
            })
          }
          const r = (this.rotation + this.pdfPageRotate) % 360
          this.viewport = this.viewport.clone({
            scale: this.scale * n.PixelsPerInch.PDF_TO_CSS_UNITS,
            rotation: r
          })
          this._isStandalone && s.docStyle.setProperty('--scale-factor', this.viewport.scale)
          if (this.svg) {
            this.cssTransform({
              target: this.svg,
              redrawAnnotationLayer: !0,
              redrawAnnotationEditorLayer: !0,
              redrawXfaLayer: !0
            })
            this.eventBus.dispatch('pagerendered', {
              source: this,
              pageNumber: this.id,
              cssTransform: !0,
              timestamp: performance.now(),
              error: this._renderError
            })
            return
          }
          let o = !1
          if (this.canvas && this.maxCanvasPixels > 0) {
            const e = this.outputScale
            ;((Math.floor(this.viewport.width) * e.sx) | 0) *
              ((Math.floor(this.viewport.height) * e.sy) | 0) >
              this.maxCanvasPixels && (o = !0)
          }
          if (this.canvas) {
            if (this.useOnlyCssZoom || (this.hasRestrictedScaling && o)) {
              this.cssTransform({
                target: this.canvas,
                redrawAnnotationLayer: !0,
                redrawAnnotationEditorLayer: !0,
                redrawXfaLayer: !0
              })
              this.eventBus.dispatch('pagerendered', {
                source: this,
                pageNumber: this.id,
                cssTransform: !0,
                timestamp: performance.now(),
                error: this._renderError
              })
              return
            }
            if (!this.zoomLayer && !this.canvas.hidden) {
              this.zoomLayer = this.canvas.parentNode
              this.zoomLayer.style.position = 'absolute'
            }
          }
          this.zoomLayer && this.cssTransform({ target: this.zoomLayer.firstChild })
          this.reset({
            keepZoomLayer: !0,
            keepAnnotationLayer: !0,
            keepAnnotationEditorLayer: !0,
            keepXfaLayer: !0
          })
        }

        cancelRendering() {
          const {
            keepAnnotationLayer: e = !1,
            keepAnnotationEditorLayer: t = !1,
            keepXfaLayer: i = !1
          } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
          if (this.paintTask) {
            this.paintTask.cancel()
            this.paintTask = null
          }
          this.resume = null
          if (this.textLayer) {
            this.textLayer.cancel()
            this.textLayer = null
          }
          if (this.annotationLayer && (!e || !this.annotationLayer.div)) {
            this.annotationLayer.cancel()
            this.annotationLayer = null
            this._annotationCanvasMap = null
          }
          if (this.annotationEditorLayer && (!t || !this.annotationEditorLayer.div)) {
            this.annotationEditorLayer.cancel()
            this.annotationEditorLayer = null
          }
          if (this.xfaLayer && (!i || !this.xfaLayer.div)) {
            let n
            this.xfaLayer.cancel()
            this.xfaLayer = null((n = this.textHighlighter)) === null || void 0 === n || n.disable()
          }
          if (this._onTextLayerRendered) {
            this.eventBus._off('textlayerrendered', this._onTextLayerRendered)
            this._onTextLayerRendered = null
          }
        }

        cssTransform(e) {
          const {
            target: t,
            redrawAnnotationLayer: i = !1,
            redrawAnnotationEditorLayer: n = !1,
            redrawXfaLayer: s = !1
          } = e
          const a = this.viewport.width
          const r = this.viewport.height
          const o = this.div
          t.style.width = t.parentNode.style.width = o.style.width = `${Math.floor(a)}px`
          t.style.height = t.parentNode.style.height = o.style.height = `${Math.floor(r)}px`
          const l = this.viewport.rotation - this.paintedViewportMap.get(t).rotation
          const c = Math.abs(l)
          let d = 1
          let h = 1
          if (c === 90 || c === 270) {
            d = r / a
            h = a / r
          }
          t.style.transform = `rotate(${l}deg) scale(${d}, ${h})`
          if (this.textLayer) {
            const e = this.textLayer.viewport
            const t = this.viewport.rotation - e.rotation
            const i = Math.abs(t)
            let n = a / e.width
            ;(i !== 90 && i !== 270) || (n = a / e.height)
            const s = this.textLayer.textLayerDiv
            let r
            let o
            switch (i) {
              case 0:
                r = o = 0
                break
              case 90:
                r = 0
                o = `-${s.style.height}`
                break
              case 180:
                r = `-${s.style.width}`
                o = `-${s.style.height}`
                break
              case 270:
                r = `-${s.style.width}`
                o = 0
                break
              default:
                console.error('Bad rotation value.')
            }
            s.style.transform = `rotate(${i}deg) scale(${n}) translate(${r}, ${o})`
            s.style.transformOrigin = '0% 0%'
          }
          i && this.annotationLayer && this._renderAnnotationLayer()
          n && this.annotationEditorLayer && this._renderAnnotationEditorLayer()
          s && this.xfaLayer && this._renderXfaLayer()
        }

        get width() {
          return this.viewport.width
        }

        get height() {
          return this.viewport.height
        }

        getPagePoint(e, t) {
          return this.viewport.convertToPdfPoint(e, t)
        }

        toggleLoadingIconSpinner() {
          let e
          const t =
            (arguments.length > 0 &&
              void 0 !== arguments[0] &&
              arguments[0]((e = this.loadingIconDiv)) === null) ||
            void 0 === e ||
            e.classList.toggle('notVisible', !t)
        }

        draw() {
          let e
          let t
          let i
          const a = this
          ;(0, l.log_debug)('begin to draw page on canvas')
          if (this.renderingState !== s.RenderingStates.INITIAL) {
            console.error('Must be in new state before drawing')
            this.reset()
          }
          const { div: r, pdfPage: c } = this
          if (!c) {
            this.renderingState = s.RenderingStates.FINISHED
            if (this.loadingIconDiv) {
              this.loadingIconDiv.remove()
              delete this.loadingIconDiv
            }
            return Promise.reject(new Error('pdfPage is not loaded'))
          }
          this.renderingState = s.RenderingStates.RUNNING
          const d = document.createElement('div')
          d.style.width = r.style.width
          d.style.height = r.style.height
          d.classList.add('canvasWrapper')
          ;(0, l.log_debug)(
            `create canvas with width = ${d.style.width}, height = ${d.style.height}`
          )
          const p =
            ((e = this.annotationLayer) === null || void 0 === e ? void 0 : e.div) ||
            ((t = this.annotationEditorLayer) === null || void 0 === t ? void 0 : t.div)
          p ? p.before(d) : r.append(d)
          let g = null
          if (this.textLayerMode !== s.TextLayerMode.DISABLE && this.textLayerFactory) {
            this._accessibilityManager ||
              (this._accessibilityManager = new o.TextAccessibilityManager())
            const e = document.createElement('div')
            e.className = 'textLayer'
            e.style.width = d.style.width
            e.style.height = d.style.height
            p ? p.before(e) : r.append(e)
            g = this.textLayerFactory.createTextLayerBuilder({
              textLayerDiv: e,
              pageIndex: this.id - 1,
              viewport: this.viewport,
              enhanceTextSelection: this.textLayerMode === s.TextLayerMode.ENABLE_ENHANCE,
              eventBus: this.eventBus,
              highlighter: this.textHighlighter,
              accessibilityManager: this._accessibilityManager
            })
          }
          this.textLayer = g
          if (
            _classPrivateFieldGet(this, h) !== n.AnnotationMode.DISABLE &&
            this.annotationLayerFactory
          ) {
            this._annotationCanvasMap || (this._annotationCanvasMap = new Map())
            this.annotationLayer ||
              (this.annotationLayer = this.annotationLayerFactory.createAnnotationLayerBuilder({
                pageDiv: r,
                pdfPage: c,
                imageResourcesPath: this.imageResourcesPath,
                renderForms: _classPrivateFieldGet(this, h) === n.AnnotationMode.ENABLE_FORMS,
                l10n: this.l10n,
                annotationCanvasMap: this._annotationCanvasMap,
                accessibilityManager: this._accessibilityManager
              }))
          }
          ;(i = this.xfaLayer) !== null && void 0 !== i && i.div && r.append(this.xfaLayer.div)
          let f = null
          this.renderingQueue &&
            (f = (e) => {
              if (this.renderingQueue.isHighestPriority(this)) e()
              else {
                this.renderingState = s.RenderingStates.PAUSED
                this.resume = () => {
                  this.renderingState = s.RenderingStates.RUNNING
                  e()
                }
              }
            })
          const finishPaintTask = async function () {
            const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
            m === a.paintTask && (a.paintTask = null)
            if (e instanceof n.RenderingCancelledException) a._renderError = null
            else {
              a._renderError = e
              a.renderingState = s.RenderingStates.FINISHED
              if (a.loadingIconDiv) {
                a.loadingIconDiv.remove()
                delete a.loadingIconDiv
              }
              a._resetZoomLayer(!0)
              _classPrivateFieldGet(a, u).regularAnnotations = !m.separateAnnots
              a.eventBus.dispatch('pagerendered', {
                source: a,
                pageNumber: a.id,
                cssTransform: !1,
                timestamp: performance.now(),
                error: a._renderError
              })
              if (e) throw e
            }
          }
          const m =
            this.renderer === s.RendererType.SVG ? this.paintOnSvg(d) : this.paintOnCanvas(d)
          m.onRenderContinue = f
          this.paintTask = m
          const v = m.promise.then(
            () =>
              finishPaintTask(null).then(() => {
                if (g) {
                  const e = c.streamTextContent({ includeMarkedContent: !0 })
                  g.setTextContentStream(e)
                  g.render()
                }
                this.annotationLayer &&
                  this._renderAnnotationLayer().then(() => {
                    if (this.annotationEditorLayerFactory) {
                      this.annotationEditorLayer ||
                        (this.annotationEditorLayer =
                          this.annotationEditorLayerFactory.createAnnotationEditorLayerBuilder({
                            pageDiv: r,
                            pdfPage: c,
                            l10n: this.l10n,
                            accessibilityManager: this._accessibilityManager
                          }))
                      this._renderAnnotationEditorLayer()
                    }
                  })
              }),
            function (e) {
              return finishPaintTask(e)
            }
          )
          if (this.xfaLayerFactory) {
            this.xfaLayer ||
              (this.xfaLayer = this.xfaLayerFactory.createXfaLayerBuilder({
                pageDiv: r,
                pdfPage: c
              }))
            this._renderXfaLayer()
          }
          if (this.structTreeLayerFactory && this.textLayer && this.canvas) {
            this._onTextLayerRendered = (e) => {
              if (e.pageNumber === this.id) {
                this.eventBus._off('textlayerrendered', this._onTextLayerRendered)
                this._onTextLayerRendered = null
                this.canvas &&
                  this.pdfPage.getStructTree().then((e) => {
                    if (!e) return
                    if (!this.canvas) return
                    const t = this.structTreeLayer.render(e)
                    t.classList.add('structTree')
                    this.canvas.append(t)
                  })
              }
            }
            this.eventBus._on('textlayerrendered', this._onTextLayerRendered)
            this.structTreeLayer = this.structTreeLayerFactory.createStructTreeLayerBuilder({
              pdfPage: c
            })
          }
          r.setAttribute('data-loaded', !0)
          this.eventBus.dispatch('pagerender', { source: this, pageNumber: this.id })
          return v
        }

        paintOnCanvas(e) {
          ;(0, l.log_debug)(`into PageViewer paintOnCanvas, page index = ${this.id}`)
          const t = (0, n.createPromiseCapability)()
          const i = {
            promise: t.promise,
            onRenderContinue(e) {
              e()
            },
            cancel() {
              f.cancel()
            },
            get separateAnnots() {
              return f.separateAnnots
            }
          }
          const a = this.viewport
          const r = document.createElement('canvas')
          r.setAttribute('role', 'presentation')
          r.hidden = !0
          r.setAttribute('id', `PageCanvas${this.id}`)
          let o = !0
          const showCanvas = function () {
            if (o) {
              r.hidden = !1
              o = !1
            }
          }
          e.append(r)
          this.canvas = r
          const c = r.getContext('2d', { alpha: !1 })
          const d = (this.outputScale = new s.OutputScale())
          if (this.useOnlyCssZoom) {
            const e = a.clone({ scale: n.PixelsPerInch.PDF_TO_CSS_UNITS })
            d.sx *= e.width / a.width
            d.sy *= e.height / a.height
          }
          if (this.maxCanvasPixels > 0) {
            const e = a.width * a.height
            const t = Math.sqrt(this.maxCanvasPixels / e)
            if (d.sx > t || d.sy > t) {
              d.sx = t
              d.sy = t
              this.hasRestrictedScaling = !0
            } else this.hasRestrictedScaling = !1
          }
          const u = (0, s.approximateFraction)(d.sx)
          const p = (0, s.approximateFraction)(d.sy)
          r.width = (0, s.roundToDivide)(a.width * d.sx, u[0])
          r.height = (0, s.roundToDivide)(a.height * d.sy, p[0])
          r.style.width = `${(0, s.roundToDivide)(a.width, u[1])}px`
          r.style.height = `${(0, s.roundToDivide)(a.height, p[1])}px`
          this.paintedViewportMap.set(r, a)
          const g = {
            canvasContext: c,
            transform: d.scaled ? [d.sx, 0, 0, d.sy, 0, 0] : null,
            viewport: this.viewport,
            annotationMode: _classPrivateFieldGet(this, h),
            optionalContentConfigPromise: this._optionalContentConfigPromise,
            annotationCanvasMap: this._annotationCanvasMap,
            pageColors: this.pageColors
          }
          const f = this.pdfPage.render(g)
          f.onContinue = function (e) {
            showCanvas()
            i.onRenderContinue ? i.onRenderContinue(e) : e()
          }
          f.promise.then(
            function () {
              showCanvas()
              t.resolve()
            },
            function (e) {
              showCanvas()
              t.reject(e)
            }
          )
          ;(0, l.log_debug)(`finish PageViewer paintOnCanvas, page index = ${this.id}`)
          return i
        }

        paintOnSvg(e) {
          let t = !1
          const ensureNotCancelled = () => {
            if (t)
              throw new n.RenderingCancelledException(`Rendering cancelled, page ${this.id}`, 'svg')
          }
          const i = this.pdfPage
          const a = this.viewport.clone({ scale: n.PixelsPerInch.PDF_TO_CSS_UNITS })
          return {
            promise: i
              .getOperatorList({ annotationMode: _classPrivateFieldGet(this, h) })
              .then((t) => {
                ensureNotCancelled()
                return new n.SVGGraphics(i.commonObjs, i.objs).getSVG(t, a).then((t) => {
                  ensureNotCancelled()
                  this.svg = t
                  this.paintedViewportMap.set(t, a)
                  t.style.width = e.style.width
                  t.style.height = e.style.height
                  this.renderingState = s.RenderingStates.FINISHED
                  e.append(t)
                })
              }),
            onRenderContinue(e) {
              e()
            },
            cancel() {
              t = !0
            },
            get separateAnnots() {
              return !1
            }
          }
        }

        setPageLabel(e) {
          this.pageLabel = typeof e === 'string' ? e : null
          this.pageLabel !== null
            ? this.div.setAttribute('data-page-label', this.pageLabel)
            : this.div.removeAttribute('data-page-label')
        }

        get thumbnailCanvas() {
          const { initialOptionalContent: e, regularAnnotations: t } = _classPrivateFieldGet(
            this,
            u
          )
          return e && t ? this.canvas : null
        }
      }
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.TextAccessibilityManager = void 0
      const n = i(1)
      function _classPrivateFieldInitSpec(e, t, i) {
        _checkPrivateRedeclaration(e, t)
        t.set(e, i)
      }
      function _checkPrivateRedeclaration(e, t) {
        if (t.has(e))
          throw new TypeError('Cannot initialize the same private elements twice on an object')
      }
      function _classPrivateMethodGet(e, t, i) {
        if (!t.has(e)) throw new TypeError('attempted to get private field on non-instance')
        return i
      }
      function _classStaticPrivateMethodGet(e, t, i) {
        !(function _classCheckPrivateStaticAccess(e, t) {
          if (e !== t) throw new TypeError('Private static access of wrong provenance')
        })(e, t)
        return i
      }
      function _classPrivateFieldGet(e, t) {
        return (function _classApplyDescriptorGet(e, t) {
          if (t.get) return t.get.call(e)
          return t.value
        })(e, _classExtractFieldDescriptor(e, t, 'get'))
      }
      function _classPrivateFieldSet(e, t, i) {
        !(function _classApplyDescriptorSet(e, t, i) {
          if (t.set) t.set.call(e, i)
          else {
            if (!t.writable) throw new TypeError('attempted to set read only private field')
            t.value = i
          }
        })(e, _classExtractFieldDescriptor(e, t, 'set'), i)
        return i
      }
      function _classExtractFieldDescriptor(e, t, i) {
        if (!t.has(e)) throw new TypeError(`attempted to ${i} private field on non-instance`)
        return t.get(e)
      }
      const s = new WeakMap()
      const a = new WeakMap()
      const r = new WeakMap()
      const o = new WeakMap()
      const l = new WeakSet()
      class TextAccessibilityManager {
        constructor() {
          !(function _classPrivateMethodInitSpec(e, t) {
            _checkPrivateRedeclaration(e, t)
            t.add(e)
          })(this, l)
          _classPrivateFieldInitSpec(this, s, { writable: !0, value: !1 })
          _classPrivateFieldInitSpec(this, a, { writable: !0, value: null })
          _classPrivateFieldInitSpec(this, r, { writable: !0, value: new Map() })
          _classPrivateFieldInitSpec(this, o, { writable: !0, value: new Map() })
        }

        setTextMapping(e) {
          _classPrivateFieldSet(this, a, e)
        }

        enable() {
          if (_classPrivateFieldGet(this, s))
            throw new Error('TextAccessibilityManager is already enabled.')
          if (!_classPrivateFieldGet(this, a))
            throw new Error('Text divs and strings have not been set.')
          _classPrivateFieldSet(this, s, !0)
          _classPrivateFieldSet(this, a, _classPrivateFieldGet(this, a).slice())
          _classPrivateFieldGet(this, a).sort(
            _classStaticPrivateMethodGet(
              TextAccessibilityManager,
              TextAccessibilityManager,
              _compareElementPositions
            )
          )
          if (_classPrivateFieldGet(this, r).size > 0) {
            const e = _classPrivateFieldGet(this, a)
            for (const [t, i] of _classPrivateFieldGet(this, r)) {
              document.getElementById(t)
                ? _classPrivateMethodGet(this, l, _addIdToAriaOwns2).call(this, t, e[i])
                : _classPrivateFieldGet(this, r).delete(t)
            }
          }
          for (const [e, t] of _classPrivateFieldGet(this, o)) this.addPointerInTextLayer(e, t)
          _classPrivateFieldGet(this, o).clear()
        }

        disable() {
          if (_classPrivateFieldGet(this, s)) {
            _classPrivateFieldGet(this, o).clear()
            _classPrivateFieldSet(this, a, null)
            _classPrivateFieldSet(this, s, !1)
          }
        }

        removePointerInTextLayer(e) {
          let t
          if (!_classPrivateFieldGet(this, s)) {
            _classPrivateFieldGet(this, o).delete(e)
            return
          }
          const i = _classPrivateFieldGet(this, a)
          if (!i || i.length === 0) return
          const { id: n } = e
          const l = _classPrivateFieldGet(this, r).get(n)
          if (void 0 === l) return
          const c = i[l]
          _classPrivateFieldGet(this, r).delete(n)
          let d = c.getAttribute('aria-owns')
          if ((t = d) !== null && void 0 !== t && t.includes(n)) {
            d = d
              .split(' ')
              .filter((e) => e !== n)
              .join(' ')
            if (d) c.setAttribute('aria-owns', d)
            else {
              c.removeAttribute('aria-owns')
              c.setAttribute('role', 'presentation')
            }
          }
        }

        addPointerInTextLayer(e, t) {
          const { id: i } = e
          if (!i) return
          if (!_classPrivateFieldGet(this, s)) {
            _classPrivateFieldGet(this, o).set(e, t)
            return
          }
          t && this.removePointerInTextLayer(e)
          const c = _classPrivateFieldGet(this, a)
          if (!c || c.length === 0) return
          const d = (0, n.binarySearchFirstItem)(
            c,
            (t) =>
              _classStaticPrivateMethodGet(
                TextAccessibilityManager,
                TextAccessibilityManager,
                _compareElementPositions
              ).call(TextAccessibilityManager, e, t) < 0
          )
          const h = Math.max(0, d - 1)
          _classPrivateMethodGet(this, l, _addIdToAriaOwns2).call(this, i, c[h])
          _classPrivateFieldGet(this, r).set(i, h)
        }

        moveElementInDOM(e, t, i, s) {
          this.addPointerInTextLayer(i, s)
          if (!e.hasChildNodes()) {
            e.append(t)
            return
          }
          const a = Array.from(e.childNodes).filter((e) => e !== t)
          if (a.length === 0) return
          const r = i || t
          const o = (0, n.binarySearchFirstItem)(
            a,
            (e) =>
              _classStaticPrivateMethodGet(
                TextAccessibilityManager,
                TextAccessibilityManager,
                _compareElementPositions
              ).call(TextAccessibilityManager, r, e) < 0
          )
          o === 0 ? a[0].before(t) : a[o - 1].after(t)
        }
      }
      t.TextAccessibilityManager = TextAccessibilityManager
      function _compareElementPositions(e, t) {
        const i = e.getBoundingClientRect()
        const n = t.getBoundingClientRect()
        if (i.width === 0 && i.height === 0) return 1
        if (n.width === 0 && n.height === 0) return -1
        const s = i.y
        const a = i.y + i.height
        const r = i.y + i.height / 2
        const o = n.y
        const l = n.y + n.height
        const c = n.y + n.height / 2
        if (r <= o && c >= a) return -1
        if (c <= s && r >= l) return 1
        return i.x + i.width / 2 - (n.x + n.width / 2)
      }
      function _addIdToAriaOwns2(e, t) {
        const i = t.getAttribute('aria-owns')
        ;(i != null && i.includes(e)) || t.setAttribute('aria-owns', i ? `${i} ${e}` : e)
        t.removeAttribute('role')
      }
    },
    (e, t) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.log_warn = t.log_trace = t.log_info = t.log_error = t.log_debug = t.log_assert = void 0
      t.setLogLevel = function setLogLevel(e) {
        if (e == 0) {
          t.log_trace = log_trace = function () {}
          t.log_error = log_error = function () {}
          t.log_assert = log_assert = function () {}
          t.log_warn = log_warn = function () {}
          t.log_debug = log_debug = function () {}
          t.log_info = log_info = function () {}
          return
        }
        t.log_assert = log_assert = console.assert.bind(window.console)
        e >= 1 && (t.log_error = log_error = console.error.bind(window.console))
        e >= 2 && (t.log_warn = log_warn = console.warn.bind(window.console))
        e >= 3 && (t.log_info = log_info = console.info.bind(window.console))
        e >= 4 && (t.log_debug = log_debug = console.debug.bind(window.console))
        e >= 5 && (t.log_trace = log_trace = console.trace.bind(window.console))
      }
      var log_trace = function () {}
      t.log_trace = log_trace
      var log_error = function () {}
      t.log_error = log_error
      var log_assert = function () {}
      t.log_assert = log_assert
      var log_warn = function () {}
      t.log_warn = log_warn
      var log_debug = function () {}
      t.log_debug = log_debug
      var log_info = function () {}
      t.log_info = log_info
    },
    (e, t) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.debouncer =
        t.copyTextToClipboard =
        t.contains =
        t.colorToRGB =
        t.checkStr =
        t.checkPwd =
        t.changeToChinese =
        t.changeCase =
        t.average =
        t.appendQuery =
        t.addClass =
        t.ErrorCode =
          void 0
      t.dispatchCustomEvent = dispatchCustomEvent
      t.dispatchError = function dispatchError(e, t) {
        dispatchCustomEvent('BJCAErrorEvent', t.getError(), e)
      }
      t.formArray = t.elementIsVisibleInViewport = t.download = void 0
      t.formatDate = function formatDate(e, t) {
        const i = {
          'M+': e.getMonth() + 1,
          'd+': e.getDate(),
          'h+': e.getHours(),
          'm+': e.getMinutes(),
          's+': e.getSeconds(),
          'q+': Math.floor((e.getMonth() + 3) / 3),
          S: e.getMilliseconds()
        }
        ;/(y+)/.test(t) &&
          (t = t.replace(RegExp.$1, `${e.getFullYear()}`.substr(4 - RegExp.$1.length)))
        for (const n in i)
          new RegExp(`(${n})`).test(t) &&
            (t = t.replace(
              RegExp.$1,
              RegExp.$1.length == 1 ? i[n] : `00${i[n]}`.substr(`${i[n]}`.length)
            ))
        return t
      }
      t.unique =
        t.union =
        t.ua =
        t.trim =
        t.sum =
        t.sort =
        t.shuffle =
        t.scrollToTop =
        t.removeHtmltag =
        t.removeClass =
        t.remove =
        t.random =
        t.numberToChinese =
        t.min =
        t.max =
        t.isWeiXin =
        t.isUndefined =
        t.isURL =
        t.isSymbol =
        t.isString =
        t.isSpider =
        t.isSet =
        t.isRegExp =
        t.isQQBrowser =
        t.isPromise =
        t.isPhone =
        t.isPC =
        t.isObjectEqual =
        t.isObj =
        t.isNumber =
        t.isNull =
        t.isMobile =
        t.isIos =
        t.isFunction =
        t.isError =
        t.isEmail =
        t.isDeviceMobile =
        t.isDate =
        t.isCardID =
        t.isBoolean =
        t.isArray =
        t.intersect =
        t.insertStr =
        t.injectScript =
        t.hasClass =
        t.getScrollPosition =
        t.getQueryString =
          void 0
      class ErrorClass {
        constructor(e, t) {
          this.code = e
          this.msg = t
        }

        getError() {
          return { code: this.code, msg: this.msg }
        }
      }
      const i = [
        new ErrorClass(10001, 'wrong annot index'),
        new ErrorClass(10002, 'page view is null'),
        new ErrorClass(10003, 'annot config has not been set'),
        new ErrorClass(10004, 'annotationLayer is null')
      ]
      t.ErrorCode = i
      function dispatchCustomEvent(e, t, i) {
        const n = document.createEvent('CustomEvent')
        n.initCustomEvent(e, !0, !0, t)
        i.dispatchEvent(n)
      }
      t.isEmail = (e) => /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]{2,3}){1,2})$/.test(e)
      t.isMobile = (e) => /^1[0-9]{10}$/.test(e)
      t.isPhone = (e) => /^([0-9]{3,4}-)?[0-9]{7,8}$/.test(e)
      t.isURL = (e) => /^http[s]?:\/\/.*/.test(e)
      t.isString = (e) => Object.prototype.toString.call(e).slice(8, -1) === 'String'
      t.isNumber = (e) => Object.prototype.toString.call(e).slice(8, -1) === 'Number'
      t.isBoolean = (e) => Object.prototype.toString.call(e).slice(8, -1) === 'Boolean'
      t.isFunction = (e) => Object.prototype.toString.call(e).slice(8, -1) === 'Function'
      t.isNull = (e) => Object.prototype.toString.call(e).slice(8, -1) === 'Null'
      t.isUndefined = (e) => Object.prototype.toString.call(e).slice(8, -1) === 'Undefined'
      t.isObj = (e) => Object.prototype.toString.call(e).slice(8, -1) === 'Object'
      t.isArray = (e) => Object.prototype.toString.call(e).slice(8, -1) === 'Array'
      t.isDate = (e) => Object.prototype.toString.call(e).slice(8, -1) === 'Date'
      t.isRegExp = (e) => Object.prototype.toString.call(e).slice(8, -1) === 'RegExp'
      t.isError = (e) => Object.prototype.toString.call(e).slice(8, -1) === 'Error'
      t.isSymbol = (e) => Object.prototype.toString.call(e).slice(8, -1) === 'Symbol'
      t.isPromise = (e) => Object.prototype.toString.call(e).slice(8, -1) === 'Promise'
      t.isSet = (e) => Object.prototype.toString.call(e).slice(8, -1) === 'Set'
      const n = navigator.userAgent.toLowerCase()
      t.ua = n
      t.isWeiXin = () => n.match(/microMessenger/i) == 'micromessenger'
      t.isDeviceMobile = () => /android|webos|iphone|ipod|balckberry/i.test(n)
      t.isQQBrowser = () => !!n.match(/mqqbrowser|qzone|qqbrowser|qbwebviewtype/i)
      t.isSpider = () =>
        /adsbot|googlebot|bingbot|msnbot|yandexbot|baidubot|robot|careerbot|seznambot|bot|baiduspider|jikespider|symantecspider|scannerlwebcrawler|crawler|360spider|sosospider|sogou web sprider|sogou orion spider/.test(
          n
        )
      t.isIos = () => {
        const e = navigator.userAgent
        return (
          !(e.indexOf('Android') > -1 || e.indexOf('Linux') > -1) &&
          (e.indexOf('iPhone') > -1 || (e.indexOf('iPad') > -1 || e.indexOf('Windows Phone'), !1))
        )
      }
      t.isPC = () => {
        for (
          var e = navigator.userAgent,
            t = ['Android', 'iPhone', 'SymbianOS', 'Windows Phone', 'iPad', 'iPod'],
            i = !0,
            n = 0;
          n < t.length;
          n++
        )
          if (e.indexOf(t[n]) > 0) {
            i = !1
            break
          }
        return i
      }
      t.removeHtmltag = (e) => e.replace(/<[^>]+>/g, '')
      t.getQueryString = (e) => {
        const t = new RegExp(`(^|&)${e}=([^&]*)(&|$)`, 'i')
        return ((window.location.search.split('?')[1] || '').match(t) || [])[2]
      }
      t.injectScript = (e) => {
        const t = document.createElement('script')
        t.type = 'text/javascript'
        t.async = !0
        t.src = e
        const i = document.getElementsByTagName('script')[0]
        i.parentNode.insertBefore(t, i)
      }
      t.download = (e) => {
        const t = navigator.userAgent.toLowerCase().indexOf('chrome') > -1
        const i = navigator.userAgent.toLowerCase().indexOf('safari') > -1
        if (t || i) {
          const n = document.createElement('a')
          n.href = e
          if (void 0 !== n.download) {
            const s = e.substring(e.lastIndexOf('/') + 1, e.length)
            n.download = s
          }
          if (document.createEvent) {
            const a = document.createEvent('MouseEvents')
            a.initEvent('click', !0, !0)
            n.dispatchEvent(a)
            return !0
          }
        }
        e.indexOf('?') === -1 && (e += '?download')
        window.open(e, '_self')
        return !0
      }
      const hasClass = (e, t) => new RegExp(`(^|\\s)${t}(\\s|$)`).test(e.className)
      t.hasClass = hasClass
      t.addClass = (e, t) => {
        if (hasClass(e, t)) return
        const i = e.className.split(' ')
        i.push(t)
        e.className = i.join(' ')
      }
      t.removeClass = (e, t) => {
        if (!hasClass(e, t)) return
        const i = new RegExp(`(^|\\s)${t}(\\s|$)`, 'g')
        e.className = e.className.replace(i, ' ')
      }
      t.getScrollPosition = function () {
        const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : window
        return {
          x: void 0 !== e.pageXOffset ? e.pageXOffset : e.scrollLeft,
          y: void 0 !== e.pageYOffset ? e.pageYOffset : e.scrollTop
        }
      }
      const scrollToTop = () => {
        const e = document.documentElement.scrollTop || document.body.scrollTop
        if (e > 0) {
          window.requestAnimationFrame(scrollToTop)
          window.scrollTo(0, e - e / 8)
        }
      }
      t.scrollToTop = scrollToTop
      t.elementIsVisibleInViewport = function (e) {
        const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
        const { top: i, left: n, bottom: s, right: a } = e.getBoundingClientRect()
        const { innerHeight: r, innerWidth: o } = window
        return t
          ? ((i > 0 && i < r) || (s > 0 && s < r)) && ((n > 0 && n < o) || (a > 0 && a < o))
          : i >= 0 && n >= 0 && s <= r && a <= o
      }
      t.shuffle = (e) => {
        for (var t, i = []; e.length > 0; ) {
          t = Math.floor(Math.random() * e.length)
          i.push(e[t])
          e.splice(t, 1)
        }
        return i
      }
      t.copyTextToClipboard = (e) => {
        const t = document.createElement('textarea')
        t.style.background = 'transparent'
        t.value = e
        document.body.appendChild(t)
        t.select()
        try {
          document.execCommand('copy')
        } catch (e) {
          console.log('Oops, unable to copy')
        }
        document.body.removeChild(t)
      }
      t.checkStr = (e, t) => {
        switch (t) {
          case 'phone':
            return /^1[3|4|5|6|7|8|9][0-9]{9}$/.test(e)
          case 'tel':
            return /^(0\d{2,3}-\d{7,8})(-\d{1,4})?$/.test(e)
          case 'card':
            return /(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)/.test(e)
          case 'pwd':
            return /^[a-zA-Z]\w{5,17}$/.test(e)
          case 'postal':
            return /[1-9]\d{5}(?!\d)/.test(e)
          case 'QQ':
            return /^[1-9][0-9]{4,9}$/.test(e)
          case 'email':
            return /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.test(e)
          case 'money':
            return /^\d*(?:\.\d{0,2})?$/.test(e)
          case 'URL':
            return /(http|ftp|https):\/\/[\w\-_]+(\.[\w\-_]+)+([\w\-\.,@?^=%&:/~\+#]*[\w\-\@?^=%&/~\+#])?/.test(
              e
            )
          case 'IP':
            return /((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))/.test(
              e
            )
          case 'date':
            return (
              /^(\d{4})\-(\d{2})\-(\d{2}) (\d{2})(?:\:\d{2}|:(\d{2}):(\d{2}))$/.test(e) ||
              /^(\d{4})\-(\d{2})\-(\d{2})$/.test(e)
            )
          case 'number':
            return /^[0-9]$/.test(e)
          case 'english':
            return /^[a-zA-Z]+$/.test(e)
          case 'chinese':
            return /^[\\u4E00-\\u9FA5]+$/.test(e)
          case 'lower':
            return /^[a-z]+$/.test(e)
          case 'upper':
            return /^[A-Z]+$/.test(e)
          case 'HTML':
            return /<("[^"]*"|'[^']*'|[^'">])*>/.test(e)
          default:
            return !0
        }
      }
      t.isCardID = (e) => {
        if (!/(^\d{15}$)|(^\d{17}(\d|X|x)$)/.test(e)) {
          console.log('你输入的身份证长度或格式错误')
          return !1
        }
        if (
          !{
            11: '北京',
            12: '天津',
            13: '河北',
            14: '山西',
            15: '内蒙古',
            21: '辽宁',
            22: '吉林',
            23: '黑龙江',
            31: '上海',
            32: '江苏',
            33: '浙江',
            34: '安徽',
            35: '福建',
            36: '江西',
            37: '山东',
            41: '河南',
            42: '湖北',
            43: '湖南',
            44: '广东',
            45: '广西',
            46: '海南',
            50: '重庆',
            51: '四川',
            52: '贵州',
            53: '云南',
            54: '西藏',
            61: '陕西',
            62: '甘肃',
            63: '青海',
            64: '宁夏',
            65: '新疆',
            71: '台湾',
            81: '香港',
            82: '澳门',
            91: '国外'
          }[parseInt(e.substr(0, 2))]
        ) {
          console.log('你的身份证地区非法')
          return !1
        }
        const t = `${e.substr(6, 4)}-${Number(e.substr(10, 2))}-${Number(e.substr(12, 2))}`.replace(
          /-/g,
          '/'
        )
        const i = new Date(t)
        if (t != `${i.getFullYear()}/${i.getMonth() + 1}/${i.getDate()}`) {
          console.log('身份证上的出生日期非法')
          return !1
        }
        for (
          var n = 0, s = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2], a = 0;
          a < e.length - 1;
          a++
        )
          n += e[a] * s[a]
        const r = '10X98765432'[n % 11]
        if (e[e.length - 1] != r) {
          console.log('你输入的身份证号非法')
          return !1
        }
        return !0
      }
      t.random = (e, t) =>
        arguments.length === 2 ? Math.floor(e + Math.random() * (t + 1 - e)) : null
      t.numberToChinese = (e) => {
        for (
          var t = new Array('零', '一', '二', '三', '四', '五', '六', '七', '八', '九', '十'),
            i = new Array('', '十', '百', '仟', '萬', '億', '点', ''),
            n = `${e}`.replace(/(^0*)/g, '').split('.'),
            s = 0,
            a = '',
            r = n[0].length - 1;
          r >= 0;
          r--
        ) {
          switch (s) {
            case 0:
              a = i[7] + a
              break
            case 4:
              new RegExp(`0{4}//d{${n[0].length - r - 1}}$`).test(n[0]) || (a = i[4] + a)
              break
            case 8:
              a = i[5] + a
              i[7] = i[5]
              s = 0
          }
          s % 4 == 2 && n[0].charAt(r + 2) != 0 && n[0].charAt(r + 1) == 0 && (a = t[0] + a)
          n[0].charAt(r) != 0 && (a = t[n[0].charAt(r)] + i[s % 4] + a)
          s++
        }
        if (n.length > 1) {
          a += i[6]
          for (r = 0; r < n[1].length; r++) a += t[n[1].charAt(r)]
        }
        a == '一十' && (a = '十')
        a.match(/^一/) && a.length == 3 && (a = a.replace('一', ''))
        return a
      }
      t.changeToChinese = (e) => {
        typeof e === 'number' && (e = new String(e))
        e = (e = (e = e.replace(/,/g, '')).replace(/ /g, '')).replace(/￥/g, '')
        if (isNaN(e)) return ''
        for (var t = String(e).split('.'), i = '', n = t[0].length - 1; n >= 0; n--) {
          if (t[0].length > 10) return ''
          var s = ''
          var a = t[0].charAt(n)
          switch (a) {
            case '0':
              s = `零${s}`
              break
            case '1':
              s = `壹${s}`
              break
            case '2':
              s = `贰${s}`
              break
            case '3':
              s = `叁${s}`
              break
            case '4':
              s = `肆${s}`
              break
            case '5':
              s = `伍${s}`
              break
            case '6':
              s = `陆${s}`
              break
            case '7':
              s = `柒${s}`
              break
            case '8':
              s = `捌${s}`
              break
            case '9':
              s = `玖${s}`
          }
          switch (t[0].length - n - 1) {
            case 0:
              s += '元'
              break
            case 1:
            case 5:
              a != 0 && (s += '拾')
              break
            case 2:
            case 6:
              a != 0 && (s += '佰')
              break
            case 3:
            case 7:
              a != 0 && (s += '仟')
              break
            case 4:
              s += '万'
              break
            case 8:
              s += '亿'
              break
            case 9:
              s += '拾'
          }
          i = s + i
        }
        if (e.indexOf('.') != -1) {
          t[1].length > 2 && (t[1] = t[1].substr(0, 2))
          for (n = 0; n < t[1].length; n++) {
            s = ''
            switch ((a = t[1].charAt(n))) {
              case '0':
                s = `零${s}`
                break
              case '1':
                s = `壹${s}`
                break
              case '2':
                s = `贰${s}`
                break
              case '3':
                s = `叁${s}`
                break
              case '4':
                s = `肆${s}`
                break
              case '5':
                s = `伍${s}`
                break
              case '6':
                s = `陆${s}`
                break
              case '7':
                s = `柒${s}`
                break
              case '8':
                s = `捌${s}`
                break
              case '9':
                s = `玖${s}`
            }
            n == 0 && (s += '角')
            n == 1 && (s += '分')
            i += s
          }
        }
        for (; i.search('零零') != -1; )
          i =
            i
              .replace(
                '零零',
                '零'
              )(
                (i = (i = (i = (i = (i = (i = i.replace('零亿', '亿')).replace(
                  '亿万',
                  '亿'
                )).replace('零万', '万')).replace('零元', '元')).replace('零角', '')).replace(
                  '零分',
                  ''
                ))
              )
              .charAt(i.length - 1) == '元' && (i += '整')
        return i
      }
      t.contains = (e, t) => e.indexOf(t) != -1
      t.sort = function (e) {
        const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1
        return e.sort((i, n) => {
          switch (t) {
            case 1:
              return i - n
            case 2:
              return n - i
            case 3:
              return Math.random() - 0.5
            default:
              return e
          }
        })
      }
      t.unique = (e) => {
        if (Array.hasOwnProperty('from')) return Array.from(new Set(e))
        for (var t = {}, i = [], n = 0; n < e.length; n++)
          if (!t[e[n]]) {
            t[e[n]] = !0
            i.push(e[n])
          }
        return i
      }
      t.union = (e, t) => {
        const i = e.concat(t)
        return (void 0).unique(i)
      }
      t.intersect = (e, t) => {
        e = (void 0).unique(e)
        return (void 0).map(e, function (e) {
          return undefined.contains(t, e) ? e : null
        })
      }
      t.remove = (e, t) => {
        const i = e.indexOf(t)
        i > -1 && e.splice(i, 1)
        return e
      }
      t.formArray = (e) => (Array.isArray(e) ? e : Array.prototype.slice.call(e))
      t.max = (e) => Math.max.apply(null, e)
      t.min = (e) => Math.min.apply(null, e)
      t.sum = (e) => e.reduce((e, t) => e + t)
      t.average = (e) => (void 0).sum(e) / e.length
      t.trim = (e, t) => {
        switch ((t = t || 1)) {
          case 1:
            return e.replace(/\s+/g, '')
          case 2:
            return e.replace(/(^\s*)|(\s*$)/g, '')
          case 3:
            return e.replace(/(^\s*)/g, '')
          case 4:
            return e.replace(/(\s*$)/g, '')
          default:
            return e
        }
      }
      t.changeCase = (e, t) => {
        switch ((t = t || 4)) {
          case 1:
            return e.replace(/\b\w+\b/g, function (e) {
              return e.substring(0, 1).toUpperCase() + e.substring(1).toLowerCase()
            })
          case 2:
            return e.replace(/\b\w+\b/g, function (e) {
              return e.substring(0, 1).toLowerCase() + e.substring(1).toUpperCase()
            })
          case 3:
            return e
              .split('')
              .map(function (e) {
                return /[a-z]/.test(e) ? e.toUpperCase() : e.toLowerCase()
              })
              .join('')
          case 4:
            return e.toUpperCase()
          case 5:
            return e.toLowerCase()
          default:
            return e
        }
      }
      t.checkPwd = (e) => {
        let t = 0
        if (e.length < 6) return t
        ;/[0-9]/.test(e) && t++
        ;/[a-z]/.test(e) && t++
        ;/[A-Z]/.test(e) && t++
        ;/[\.|-|_]/.test(e) && t++
        return t
      }
      t.debouncer = function (e, t) {
        const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 200
        if (t - (window.debounceTimestamp || 0) > i) {
          e && e()
          window.debounceTimestamp = t
        }
      }
      t.insertStr = (e, t, i) => e.slice(0, t) + i + e.slice(t)
      t.isObjectEqual = (e, t) => {
        const i = Object.getOwnPropertyNames(e)
        const n = Object.getOwnPropertyNames(t)
        if (i.length !== n.length) return !1
        for (let s = 0; s < i.length; s++) {
          const a = i[s]
          if (e[a] !== t[a]) return !1
        }
        return !0
      }
      t.colorToRGB = (e, t) => {
        const i = typeof t === 'number'
        if (!/^(#?)[a-fA-F0-9]{6}$/.test(e)) return ''
        for (var n = e.replace(/#/, ''), s = [], a = 0; a < 3; a++) {
          const r = n.substring(2 * a, 2 * a + 2)
          const o = parseInt(r, 16)
          s.push(o)
        }
        return `rgb${i ? 'a' : ''}(${s.join()}${i ? `,${t}` : ''})`
      }
      t.appendQuery = (e, t, i) => {
        let n = t
        typeof n === 'string' && ((n = {})[t] = i)
        n = $.param(n)
        e.includes('?') ? (e += `&${n}`) : (e += `?${n}`)
        return e
      }
    },
    (e, t) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.StructTreeLayerBuilder = void 0
      const i = {
        Document: null,
        DocumentFragment: null,
        Part: 'group',
        Sect: 'group',
        Div: 'group',
        Aside: 'note',
        NonStruct: 'none',
        P: null,
        H: 'heading',
        Title: null,
        FENote: 'note',
        Sub: 'group',
        Lbl: null,
        Span: null,
        Em: null,
        Strong: null,
        Link: 'link',
        Annot: 'note',
        Form: 'form',
        Ruby: null,
        RB: null,
        RT: null,
        RP: null,
        Warichu: null,
        WT: null,
        WP: null,
        L: 'list',
        LI: 'listitem',
        LBody: null,
        Table: 'table',
        TR: 'row',
        TH: 'columnheader',
        TD: 'cell',
        THead: 'columnheader',
        TBody: null,
        TFoot: null,
        Caption: null,
        Figure: 'figure',
        Formula: null,
        Artifact: null
      }
      const n = /^H(\d+)$/
      t.StructTreeLayerBuilder = class StructTreeLayerBuilder {
        constructor(e) {
          const { pdfPage: t } = e
          this.pdfPage = t
        }

        render(e) {
          return this._walk(e)
        }

        _setAttributes(e, t) {
          void 0 !== e.alt && t.setAttribute('aria-label', e.alt)
          void 0 !== e.id && t.setAttribute('aria-owns', e.id)
          void 0 !== e.lang && t.setAttribute('lang', e.lang)
        }

        _walk(e) {
          if (!e) return null
          const t = document.createElement('span')
          if ('role' in e) {
            const { role: s } = e
            const a = s.match(n)
            if (a) {
              t.setAttribute('role', 'heading')
              t.setAttribute('aria-level', a[1])
            } else i[s] && t.setAttribute('role', i[s])
          }
          this._setAttributes(e, t)
          if (e.children)
            if (e.children.length === 1 && 'id' in e.children[0])
              this._setAttributes(e.children[0], t)
            else for (const i of e.children) t.append(this._walk(i))
          return t
        }
      }
    },
    (e, t) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.TextHighlighter = void 0
      t.TextHighlighter = class TextHighlighter {
        constructor(e) {
          const { findController: t, eventBus: i, pageIndex: n } = e
          this.findController = t
          this.matches = []
          this.eventBus = i
          this.pageIdx = n
          this._onUpdateTextLayerMatches = null
          this.textDivs = null
          this.textContentItemsStr = null
          this.enabled = !1
        }

        setTextMapping(e, t) {
          this.textDivs = e
          this.textContentItemsStr = t
        }

        enable() {
          if (!this.textDivs || !this.textContentItemsStr)
            throw new Error('Text divs and strings have not been set.')
          if (this.enabled) throw new Error('TextHighlighter is already enabled.')
          this.enabled = !0
          if (!this._onUpdateTextLayerMatches) {
            this._onUpdateTextLayerMatches = (e) => {
              ;(e.pageIndex !== this.pageIdx && e.pageIndex !== -1) || this._updateMatches()
            }
            this.eventBus._on('updatetextlayermatches', this._onUpdateTextLayerMatches)
          }
          this._updateMatches()
        }

        disable() {
          if (this.enabled) {
            this.enabled = !1
            if (this._onUpdateTextLayerMatches) {
              this.eventBus._off('updatetextlayermatches', this._onUpdateTextLayerMatches)
              this._onUpdateTextLayerMatches = null
            }
          }
        }

        _convertMatches(e, t) {
          if (!e) return []
          const { textContentItemsStr: i } = this
          let n = 0
          let s = 0
          const a = i.length - 1
          const r = []
          for (let o = 0, l = e.length; o < l; o++) {
            let l = e[o]
            for (; n !== a && l >= s + i[n].length; ) {
              s += i[n].length
              n++
            }
            n === i.length && console.error('Could not find a matching mapping')
            const c = { begin: { divIdx: n, offset: l - s } }
            l += t[o]
            for (; n !== a && l > s + i[n].length; ) {
              s += i[n].length
              n++
            }
            c.end = { divIdx: n, offset: l - s }
            r.push(c)
          }
          return r
        }

        _renderMatches(e) {
          if (e.length === 0) return
          const { findController: t, pageIdx: i } = this
          const { textContentItemsStr: n, textDivs: s } = this
          const a = i === t.selected.pageIdx
          const r = t.selected.matchIdx
          let o = null
          const l = { divIdx: -1, offset: void 0 }
          function beginText(e, t) {
            const i = e.divIdx
            s[i].textContent = ''
            return appendTextToDiv(i, 0, e.offset, t)
          }
          function appendTextToDiv(e, t, i, a) {
            let r = s[e]
            if (r.nodeType === Node.TEXT_NODE) {
              const t = document.createElement('span')
              r.before(t)
              t.append(r)
              s[e] = t
              r = t
            }
            const o = n[e].substring(t, i)
            const l = document.createTextNode(o)
            if (a) {
              const e = document.createElement('span')
              e.className = `${a} appended`
              e.append(l)
              r.append(e)
              return a.includes('selected') ? e.offsetLeft : 0
            }
            r.append(l)
            return 0
          }
          let c = r
          let d = c + 1
          if (t.state.highlightAll) {
            c = 0
            d = e.length
          } else if (!a) return
          for (let n = c; n < d; n++) {
            const c = e[n]
            const d = c.begin
            const h = c.end
            const u = a && n === r
            const p = u ? ' selected' : ''
            let g = 0
            if (o && d.divIdx === o.divIdx) appendTextToDiv(o.divIdx, o.offset, d.offset)
            else {
              o !== null && appendTextToDiv(o.divIdx, o.offset, l.offset)
              beginText(d)
            }
            if (d.divIdx === h.divIdx)
              g = appendTextToDiv(d.divIdx, d.offset, h.offset, `highlight${p}`)
            else {
              g = appendTextToDiv(d.divIdx, d.offset, l.offset, `highlight begin${p}`)
              for (let e = d.divIdx + 1, t = h.divIdx; e < t; e++)
                s[e].className = `highlight middle${p}`
              beginText(h, `highlight end${p}`)
            }
            o = h
            u &&
              t.scrollMatchIntoView({
                element: s[d.divIdx],
                selectedLeft: g,
                pageIndex: i,
                matchIndex: r
              })
          }
          o && appendTextToDiv(o.divIdx, o.offset, l.offset)
        }

        _updateMatches() {
          if (!this.enabled) return
          const { findController: e, matches: t, pageIdx: i } = this
          const { textContentItemsStr: n, textDivs: s } = this
          let a = -1
          for (let e = 0, i = t.length; e < i; e++) {
            const i = t[e]
            for (let e = Math.max(a, i.begin.divIdx), t = i.end.divIdx; e <= t; e++) {
              const t = s[e]
              t.textContent = n[e]
              t.className = ''
            }
            a = i.end.divIdx + 1
          }
          if (e == null || !e.highlightMatches) return
          const r = e.pageMatches[i] || null
          const o = e.pageMatchesLength[i] || null
          this.matches = this._convertMatches(r, o)
          this._renderMatches(this.matches)
        }
      }
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.TextLayerBuilder = void 0
      const n = i(5)
      t.TextLayerBuilder = class TextLayerBuilder {
        constructor(e) {
          const {
            textLayerDiv: t,
            eventBus: i,
            pageIndex: n,
            viewport: s,
            highlighter: a = null,
            enhanceTextSelection: r = !1,
            accessibilityManager: o = null
          } = e
          this.textLayerDiv = t
          this.eventBus = i
          this.textContent = null
          this.textContentItemsStr = []
          this.textContentStream = null
          this.renderingDone = !1
          this.pageNumber = n + 1
          this.viewport = s
          this.textDivs = []
          this.textLayerRenderTask = null
          this.highlighter = a
          this.enhanceTextSelection = r
          this.accessibilityManager = o
          this._bindMouse()
        }

        _finishRendering() {
          this.renderingDone = !0
          if (!this.enhanceTextSelection) {
            const e = document.createElement('div')
            e.className = 'endOfContent'
            this.textLayerDiv.append(e)
          }
          this.eventBus.dispatch('textlayerrendered', {
            source: this,
            pageNumber: this.pageNumber,
            numTextDivs: this.textDivs.length
          })
        }

        render() {
          let e
          let t
          const i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
          if ((!this.textContent && !this.textContentStream) || this.renderingDone) return
          this.cancel()
          this.textDivs.length =
            0((e = this.highlighter)) === null ||
            void 0 === e ||
            e.setTextMapping(
              this.textDivs,
              this.textContentItemsStr
            )((t = this.accessibilityManager)) === null ||
            void 0 === t ||
            t.setTextMapping(this.textDivs)
          const s = document.createDocumentFragment()
          this.textLayerRenderTask = (0, n.renderTextLayer)({
            textContent: this.textContent,
            textContentStream: this.textContentStream,
            container: s,
            viewport: this.viewport,
            textDivs: this.textDivs,
            textContentItemsStr: this.textContentItemsStr,
            timeout: i,
            enhanceTextSelection: this.enhanceTextSelection
          })
          this.textLayerRenderTask.promise.then(
            () => {
              let e
              let t
              this.textLayerDiv.append(s)
              this._finishRendering()((e = this.highlighter)) === null ||
                void 0 === e ||
                e.enable()((t = this.accessibilityManager)) === null ||
                void 0 === t ||
                t.enable()
            },
            function (e) {}
          )
        }

        cancel() {
          let e
          let t
          if (this.textLayerRenderTask) {
            this.textLayerRenderTask.cancel()
            this.textLayerRenderTask = null
          }
          ;(e = this.highlighter) === null ||
            void 0 === e ||
            e.disable()((t = this.accessibilityManager)) === null ||
            void 0 === t ||
            t.disable()
        }

        setTextContentStream(e) {
          this.cancel()
          this.textContentStream = e
        }

        setTextContent(e) {
          this.cancel()
          this.textContent = e
        }

        _bindMouse() {
          const e = this.textLayerDiv
          let t = null
          e.addEventListener('mousedown', (i) => {
            if (this.enhanceTextSelection && this.textLayerRenderTask) {
              this.textLayerRenderTask.expandTextDivs(!0)
              if (t) {
                clearTimeout(t)
                t = null
              }
              return
            }
            const n = e.querySelector('.endOfContent')
            if (!n) return
            let s = i.target !== e
            s = s && window.getComputedStyle(n).getPropertyValue('-moz-user-select') !== 'none'
            if (s) {
              const t = e.getBoundingClientRect()
              const s = Math.max(0, (i.pageY - t.top) / t.height)
              n.style.top = `${(100 * s).toFixed(2)}%`
            }
            n.classList.add('active')
          })
          e.addEventListener('mouseup', () => {
            if (this.enhanceTextSelection && this.textLayerRenderTask) {
              t = setTimeout(() => {
                this.textLayerRenderTask && this.textLayerRenderTask.expandTextDivs(!1)
                t = null
              }, 300)
              return
            }
            const i = e.querySelector('.endOfContent')
            if (i) {
              i.style.top = ''
              i.classList.remove('active')
            }
          })
        }
      }
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.XfaLayerBuilder = void 0
      const n = i(5)
      t.XfaLayerBuilder = class XfaLayerBuilder {
        constructor(e) {
          const {
            pageDiv: t,
            pdfPage: i,
            annotationStorage: n = null,
            linkService: s,
            xfaHtml: a = null
          } = e
          this.pageDiv = t
          this.pdfPage = i
          this.annotationStorage = n
          this.linkService = s
          this.xfaHtml = a
          this.div = null
          this._cancelled = !1
        }

        render(e) {
          const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 'display'
          if (t === 'print') {
            const i = {
              viewport: e.clone({ dontFlip: !0 }),
              div: this.div,
              xfaHtml: this.xfaHtml,
              annotationStorage: this.annotationStorage,
              linkService: this.linkService,
              intent: t
            }
            const s = document.createElement('div')
            this.pageDiv.append(s)
            i.div = s
            const a = n.XfaLayer.render(i)
            return Promise.resolve(a)
          }
          return this.pdfPage
            .getXfa()
            .then((i) => {
              if (this._cancelled || !i) return { textDivs: [] }
              const s = {
                viewport: e.clone({ dontFlip: !0 }),
                div: this.div,
                xfaHtml: i,
                annotationStorage: this.annotationStorage,
                linkService: this.linkService,
                intent: t
              }
              if (this.div) return n.XfaLayer.update(s)
              this.div = document.createElement('div')
              this.pageDiv.append(this.div)
              s.div = this.div
              return n.XfaLayer.render(s)
            })
            .catch((e) => {
              console.error(e)
            })
        }

        cancel() {
          this._cancelled = !0
        }

        hide() {
          this.div && (this.div.hidden = !0)
        }
      }
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.SecondaryToolbar = void 0
      const n = i(1)
      const s = i(7)
      const a = i(30)
      function _classPrivateMethodInitSpec(e, t) {
        !(function _checkPrivateRedeclaration(e, t) {
          if (t.has(e))
            throw new TypeError('Cannot initialize the same private elements twice on an object')
        })(e, t)
        t.add(e)
      }
      function _classPrivateMethodGet(e, t, i) {
        if (!t.has(e)) throw new TypeError('attempted to get private field on non-instance')
        return i
      }
      const r = new WeakSet()
      const o = new WeakSet()
      const l = new WeakSet()
      const c = new WeakSet()
      const d = new WeakSet()
      t.SecondaryToolbar = class SecondaryToolbar {
        constructor(e, t) {
          _classPrivateMethodInitSpec(this, d)
          _classPrivateMethodInitSpec(this, c)
          _classPrivateMethodInitSpec(this, l)
          _classPrivateMethodInitSpec(this, o)
          _classPrivateMethodInitSpec(this, r)
          this.toolbar = e.toolbar
          this.toggleButton = e.toggleButton
          this.buttons = [
            { element: e.presentationModeButton, eventName: 'presentationmode', close: !0 },
            { element: e.printButton, eventName: 'print', close: !0 },
            { element: e.downloadButton, eventName: 'download', close: !0 },
            { element: e.viewBookmarkButton, eventName: null, close: !0 },
            { element: e.firstPageButton, eventName: 'firstpage', close: !0 },
            { element: e.lastPageButton, eventName: 'lastpage', close: !0 },
            { element: e.pageRotateCwButton, eventName: 'rotatecw', close: !1 },
            { element: e.pageRotateCcwButton, eventName: 'rotateccw', close: !1 },
            {
              element: e.cursorSelectToolButton,
              eventName: 'switchcursortool',
              eventDetails: { tool: s.CursorTool.SELECT },
              close: !0
            },
            {
              element: e.cursorHandToolButton,
              eventName: 'switchcursortool',
              eventDetails: { tool: s.CursorTool.HAND },
              close: !0
            },
            {
              element: e.scrollPageButton,
              eventName: 'switchscrollmode',
              eventDetails: { mode: n.ScrollMode.PAGE },
              close: !0
            },
            {
              element: e.scrollVerticalButton,
              eventName: 'switchscrollmode',
              eventDetails: { mode: n.ScrollMode.VERTICAL },
              close: !0
            },
            {
              element: e.scrollHorizontalButton,
              eventName: 'switchscrollmode',
              eventDetails: { mode: n.ScrollMode.HORIZONTAL },
              close: !0
            },
            {
              element: e.scrollWrappedButton,
              eventName: 'switchscrollmode',
              eventDetails: { mode: n.ScrollMode.WRAPPED },
              close: !0
            },
            {
              element: e.spreadNoneButton,
              eventName: 'switchspreadmode',
              eventDetails: { mode: n.SpreadMode.NONE },
              close: !0
            },
            {
              element: e.spreadOddButton,
              eventName: 'switchspreadmode',
              eventDetails: { mode: n.SpreadMode.ODD },
              close: !0
            },
            {
              element: e.spreadEvenButton,
              eventName: 'switchspreadmode',
              eventDetails: { mode: n.SpreadMode.EVEN },
              close: !0
            },
            { element: e.documentPropertiesButton, eventName: 'documentproperties', close: !0 }
          ]
          this.buttons.push({ element: e.openFileButton, eventName: 'openfile', close: !0 })
          this.items = {
            firstPage: e.firstPageButton,
            lastPage: e.lastPageButton,
            pageRotateCw: e.pageRotateCwButton,
            pageRotateCcw: e.pageRotateCcwButton
          }
          this.eventBus = t
          this.opened = !1
          _classPrivateMethodGet(this, o, _bindClickListeners2).call(this)
          _classPrivateMethodGet(this, l, _bindCursorToolsListener2).call(this, e)
          _classPrivateMethodGet(this, c, _bindScrollModeListener2).call(this, e)
          _classPrivateMethodGet(this, d, _bindSpreadModeListener2).call(this, e)
          this.reset()
        }

        get isOpen() {
          return this.opened
        }

        setPageNumber(e) {
          this.pageNumber = e
          _classPrivateMethodGet(this, r, _updateUIState2).call(this)
        }

        setPagesCount(e) {
          this.pagesCount = e
          _classPrivateMethodGet(this, r, _updateUIState2).call(this)
        }

        reset() {
          this.pageNumber = 0
          this.pagesCount = 0
          _classPrivateMethodGet(this, r, _updateUIState2).call(this)
          this.eventBus.dispatch('secondarytoolbarreset', { source: this })
        }

        open() {
          if (!this.opened) {
            this.opened = !0
            this.toggleButton.classList.add('toggled')
            this.toggleButton.setAttribute('aria-expanded', 'true')
            this.toolbar.classList.remove('hidden')
          }
        }

        close() {
          if (this.opened) {
            this.opened = !1
            this.toolbar.classList.add('hidden')
            this.toggleButton.classList.remove('toggled')
            this.toggleButton.setAttribute('aria-expanded', 'false')
          }
        }

        toggle() {
          this.opened ? this.close() : this.open()
        }
      }
      function _updateUIState2() {
        this.items.firstPage.disabled = this.pageNumber <= 1
        this.items.lastPage.disabled = this.pageNumber >= this.pagesCount
        this.items.pageRotateCw.disabled = this.pagesCount === 0
        this.items.pageRotateCcw.disabled = this.pagesCount === 0
      }
      function _bindClickListeners2() {
        this.toggleButton.addEventListener('click', this.toggle.bind(this))
        for (const { element: e, eventName: t, close: i, eventDetails: n } of this.buttons)
          e.addEventListener('click', (e) => {
            if (t !== null) {
              const e = { source: this }
              for (const t in n) e[t] = n[t]
              this.eventBus.dispatch(t, e)
            }
            i && this.close()
          })
      }
      function _bindCursorToolsListener2(e) {
        const { cursorSelectToolButton: t, cursorHandToolButton: i } = e
        this.eventBus._on('cursortoolchanged', function (e) {
          const { tool: n } = e
          const a = n === s.CursorTool.SELECT
          const r = n === s.CursorTool.HAND
          t.classList.toggle('toggled', a)
          i.classList.toggle('toggled', r)
          t.setAttribute('aria-checked', a)
          i.setAttribute('aria-checked', r)
        })
      }
      function _bindScrollModeListener2(e) {
        const {
          scrollPageButton: t,
          scrollVerticalButton: i,
          scrollHorizontalButton: s,
          scrollWrappedButton: r,
          spreadNoneButton: o,
          spreadOddButton: l,
          spreadEvenButton: c
        } = e
        const scrollModeChanged = (e) => {
          const { mode: d } = e
          const h = d === n.ScrollMode.PAGE
          const u = d === n.ScrollMode.VERTICAL
          const p = d === n.ScrollMode.HORIZONTAL
          const g = d === n.ScrollMode.WRAPPED
          t.classList.toggle('toggled', h)
          i.classList.toggle('toggled', u)
          s.classList.toggle('toggled', p)
          r.classList.toggle('toggled', g)
          t.setAttribute('aria-checked', h)
          i.setAttribute('aria-checked', u)
          s.setAttribute('aria-checked', p)
          r.setAttribute('aria-checked', g)
          const f = this.pagesCount > a.PagesCountLimit.FORCE_SCROLL_MODE_PAGE
          t.disabled = f
          i.disabled = f
          s.disabled = f
          r.disabled = f
          o.disabled = p
          l.disabled = p
          c.disabled = p
        }
        this.eventBus._on('scrollmodechanged', scrollModeChanged)
        this.eventBus._on('secondarytoolbarreset', (e) => {
          e.source === this && scrollModeChanged({ mode: n.ScrollMode.VERTICAL })
        })
      }
      function _bindSpreadModeListener2(e) {
        const { spreadNoneButton: t, spreadOddButton: i, spreadEvenButton: s } = e
        function spreadModeChanged(e) {
          const { mode: a } = e
          const r = a === n.SpreadMode.NONE
          const o = a === n.SpreadMode.ODD
          const l = a === n.SpreadMode.EVEN
          t.classList.toggle('toggled', r)
          i.classList.toggle('toggled', o)
          s.classList.toggle('toggled', l)
          t.setAttribute('aria-checked', r)
          i.setAttribute('aria-checked', o)
          s.setAttribute('aria-checked', l)
        }
        this.eventBus._on('spreadmodechanged', spreadModeChanged)
        this.eventBus._on('secondarytoolbarreset', (e) => {
          e.source === this && spreadModeChanged({ mode: n.SpreadMode.NONE })
        })
      }
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.Toolbar = void 0
      const n = i(1)
      const s = i(5)
      function _classPrivateMethodInitSpec(e, t) {
        _checkPrivateRedeclaration(e, t)
        t.add(e)
      }
      function _checkPrivateRedeclaration(e, t) {
        if (t.has(e))
          throw new TypeError('Cannot initialize the same private elements twice on an object')
      }
      function _classPrivateFieldGet(e, t) {
        return (function _classApplyDescriptorGet(e, t) {
          if (t.get) return t.get.call(e)
          return t.value
        })(e, _classExtractFieldDescriptor(e, t, 'get'))
      }
      function _classPrivateFieldSet(e, t, i) {
        !(function _classApplyDescriptorSet(e, t, i) {
          if (t.set) t.set.call(e, i)
          else {
            if (!t.writable) throw new TypeError('attempted to set read only private field')
            t.value = i
          }
        })(e, _classExtractFieldDescriptor(e, t, 'set'), i)
        return i
      }
      function _classExtractFieldDescriptor(e, t, i) {
        if (!t.has(e)) throw new TypeError(`attempted to ${i} private field on non-instance`)
        return t.get(e)
      }
      function _classPrivateMethodGet(e, t, i) {
        if (!t.has(e)) throw new TypeError('attempted to get private field on non-instance')
        return i
      }
      const a = new WeakMap()
      const r = new WeakSet()
      const o = new WeakSet()
      const l = new WeakSet()
      const c = new WeakSet()
      t.Toolbar = class Toolbar {
        constructor(e, t, i) {
          _classPrivateMethodInitSpec(this, c)
          _classPrivateMethodInitSpec(this, l)
          _classPrivateMethodInitSpec(this, o)
          _classPrivateMethodInitSpec(this, r)
          !(function _classPrivateFieldInitSpec(e, t, i) {
            _checkPrivateRedeclaration(e, t)
            t.set(e, i)
          })(this, a, { writable: !0, value: !1 })
          this.toolbar = e.container
          this.eventBus = t
          this.l10n = i
          this.buttons = [
            { element: e.previous, eventName: 'previouspage' },
            { element: e.next, eventName: 'nextpage' },
            { element: e.zoomIn, eventName: 'zoomin' },
            { element: e.zoomOut, eventName: 'zoomout' },
            { element: e.print, eventName: 'print' },
            { element: e.presentationModeButton, eventName: 'presentationmode' },
            { element: e.download, eventName: 'download' },
            { element: e.viewBookmark, eventName: null },
            { element: e.lineAnnot, eventName: 'lineannot' },
            { element: e.selectTool, eventName: 'selecttool' },
            {
              element: e.editorFreeTextButton,
              eventName: 'switchannotationeditormode',
              eventDetails: {
                get mode() {
                  const { classList: t } = e.editorFreeTextButton
                  return t.contains('toggled')
                    ? s.AnnotationEditorType.NONE
                    : s.AnnotationEditorType.FREETEXT
                }
              }
            },
            {
              element: e.editorInkButton,
              eventName: 'switchannotationeditormode',
              eventDetails: {
                get mode() {
                  const { classList: t } = e.editorInkButton
                  return t.contains('toggled')
                    ? s.AnnotationEditorType.NONE
                    : s.AnnotationEditorType.INK
                }
              }
            }
          ]
          this.buttons.push({ element: e.openFile, eventName: 'openfile' })
          this.items = {
            numPages: e.numPages,
            pageNumber: e.pageNumber,
            scaleSelect: e.scaleSelect,
            customScaleOption: e.customScaleOption,
            previous: e.previous,
            next: e.next,
            zoomIn: e.zoomIn,
            zoomOut: e.zoomOut
          }
          _classPrivateMethodGet(this, r, _bindListeners2).call(this, e)
          this.reset()
        }

        setPageNumber(e, t) {
          this.pageNumber = e
          this.pageLabel = t
          _classPrivateMethodGet(this, l, _updateUIState2).call(this, !1)
        }

        setPagesCount(e, t) {
          this.pagesCount = e
          this.hasPageLabels = t
          _classPrivateMethodGet(this, l, _updateUIState2).call(this, !0)
        }

        setPageScale(e, t) {
          this.pageScaleValue = (e || t).toString()
          this.pageScale = t
          _classPrivateMethodGet(this, l, _updateUIState2).call(this, !1)
        }

        reset() {
          this.pageNumber = 0
          this.pageLabel = null
          this.hasPageLabels = !1
          this.pagesCount = 0
          this.pageScaleValue = n.DEFAULT_SCALE_VALUE
          this.pageScale = n.DEFAULT_SCALE
          _classPrivateMethodGet(this, l, _updateUIState2).call(this, !0)
          this.updateLoadingIndicatorState()
          this.eventBus.dispatch('toolbarreset', { source: this })
        }

        updateLoadingIndicatorState() {
          const e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
          const { pageNumber: t } = this.items
          t.classList.toggle('visiblePageIsLoading', e)
        }
      }
      function _bindListeners2(e) {
        const { pageNumber: t, scaleSelect: i } = this.items
        const s = this
        for (const { element: e, eventName: t, eventDetails: i } of this.buttons)
          e.addEventListener('click', (e) => {
            if (t !== null) {
              const e = { source: this }
              if (i) for (const t in i) e[t] = i[t]
              this.eventBus.dispatch(t, e)
            }
          })
        t.addEventListener('click', function () {
          this.select()
        })
        t.addEventListener('change', function () {
          s.eventBus.dispatch('pagenumberchanged', { source: s, value: this.value })
        })
        i.addEventListener('change', function () {
          this.value !== 'custom' &&
            s.eventBus.dispatch('scalechanged', { source: s, value: this.value })
        })
        i.addEventListener('click', function (e) {
          const t = e.target
          this.value === s.pageScaleValue && t.tagName.toUpperCase() === 'OPTION' && this.blur()
        })
        i.oncontextmenu = n.noContextMenuHandler
        this.eventBus._on('localized', () => {
          _classPrivateFieldSet(this, a, !0)
          _classPrivateMethodGet(this, c, _adjustScaleWidth2).call(this)
          _classPrivateMethodGet(this, l, _updateUIState2).call(this, !0)
        })
        _classPrivateMethodGet(this, o, _bindEditorToolsListener2).call(this, e)
      }
      function _bindEditorToolsListener2(e) {
        const {
          editorFreeTextButton: t,
          editorFreeTextParamsToolbar: i,
          editorInkButton: n,
          editorInkParamsToolbar: a
        } = e
        const editorModeChanged = function (e) {
          const r = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
          const o = [
            { mode: s.AnnotationEditorType.FREETEXT, button: t, toolbar: i },
            { mode: s.AnnotationEditorType.INK, button: n, toolbar: a }
          ]
          for (const { mode: t, button: i, toolbar: n } of o) {
            const s = t === e.mode
            i.classList.toggle('toggled', s)
            i.setAttribute('aria-checked', s)
            i.disabled = r
            n == null || n.classList.toggle('hidden', !s)
          }
        }
        this.eventBus._on('annotationeditormodechanged', editorModeChanged)
        this.eventBus._on('toolbarreset', (e) => {
          e.source === this && editorModeChanged({ mode: s.AnnotationEditorType.NONE }, !0)
        })
      }
      function _updateUIState2() {
        const e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0]
        if (!_classPrivateFieldGet(this, a)) return
        const { pageNumber: t, pagesCount: i, pageScaleValue: s, pageScale: r, items: o } = this
        if (e) {
          if (this.hasPageLabels) o.pageNumber.type = 'text'
          else {
            o.pageNumber.type = 'number'
            this.l10n.get('of_pages', { pagesCount: i }).then((e) => {
              o.numPages.textContent = e
            })
          }
          o.pageNumber.max = i
        }
        if (this.hasPageLabels) {
          o.pageNumber.value = this.pageLabel
          this.l10n.get('page_of_pages', { pageNumber: t, pagesCount: i }).then((e) => {
            o.numPages.textContent = e
          })
        } else o.pageNumber.value = t
        o.previous.disabled = t <= 1
        o.next.disabled = t >= i
        o.zoomOut.disabled = r <= n.MIN_SCALE
        o.zoomIn.disabled = r >= n.MAX_SCALE
        this.l10n.get('page_scale_percent', { scale: Math.round(1e4 * r) / 100 }).then((e) => {
          let t = !1
          for (const e of o.scaleSelect.options)
            if (e.value === s) {
              e.selected = !0
              t = !0
            } else e.selected = !1
          if (!t) {
            o.customScaleOption.textContent = e
            o.customScaleOption.selected = !0
          }
        })
      }
      async function _adjustScaleWidth2() {
        const { items: e, l10n: t } = this
        const i = Promise.all([
          t.get('page_scale_auto'),
          t.get('page_scale_actual'),
          t.get('page_scale_fit'),
          t.get('page_scale_width')
        ])
        await n.animationStarted
        const s = getComputedStyle(e.scaleSelect)
        const a = parseInt(s.getPropertyValue('--scale-select-container-width'), 10)
        const r = parseInt(s.getPropertyValue('--scale-select-overflow'), 10)
        const o = document.createElement('canvas')
        const l = o.getContext('2d', { alpha: !1 })
        l.font = `${s.fontSize} ${s.fontFamily}`
        let c = 0
        for (const e of await i) {
          const { width: t } = l.measureText(e)
          t > c && (c = t)
        }
        c += 2 * r
        c > a && n.docStyle.setProperty('--scale-select-container-width', `${c}px`)
        o.width = 0
        o.height = 0
      }
    },
    (e, t) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.ViewHistory = void 0
      t.ViewHistory = class ViewHistory {
        constructor(e) {
          const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 20
          this.fingerprint = e
          this.cacheSize = t
          this._initializedPromise = this._readFromStorage().then((e) => {
            const t = JSON.parse(e || '{}')
            let i = -1
            if (Array.isArray(t.files)) {
              for (; t.files.length >= this.cacheSize; ) t.files.shift()
              for (let e = 0, n = t.files.length; e < n; e++) {
                if (t.files[e].fingerprint === this.fingerprint) {
                  i = e
                  break
                }
              }
            } else t.files = []
            i === -1 && (i = t.files.push({ fingerprint: this.fingerprint }) - 1)
            this.file = t.files[i]
            this.database = t
          })
        }

        async _writeToStorage() {
          const e = JSON.stringify(this.database)
          localStorage.setItem('pdfjs.history', e)
        }

        async _readFromStorage() {
          return localStorage.getItem('pdfjs.history')
        }

        async set(e, t) {
          await this._initializedPromise
          this.file[e] = t
          return this._writeToStorage()
        }

        async setMultiple(e) {
          await this._initializedPromise
          for (const t in e) this.file[t] = e[t]
          return this._writeToStorage()
        }

        async get(e, t) {
          await this._initializedPromise
          const i = this.file[e]
          return void 0 !== i ? i : t
        }

        async getMultiple(e) {
          await this._initializedPromise
          const t = Object.create(null)
          for (const i in e) {
            const n = this.file[i]
            t[i] = void 0 !== n ? n : e[i]
          }
          return t
        }
      }
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.BjcaAnnotInfo = BjcaAnnotInfo
      t.addHighlightAnnot = addHighlightAnnot
      t.listenClickEvent = listenClickEvent
      t.listenMouseDragEvent = function listenMouseDragEvent() {
        document.onmousedown = function (e) {
          const t = e.clientX
          const i = e.clientY
          if (!(i <= document.getElementById('toolbarViewer').offsetHeight)) {
            const r = decideMouseOnPage(e.view.PDFViewerApplication.pdfViewer, t, i)
            if (r != 0) {
              const l = document.getElementById('bjca_menu')
              if (l.style.display == 'block') {
                if ((0, n.isPointOnElement)({ x: t, y: i }, l)) return
                l.style.display = 'none'
              }
              const c = document.getElementById(`PageCanvas${r}`)
              const d = e.view.PDFViewerApplication.pdfViewer.getPageView(r - 1)
              if (isHoverAnnot(e, r) === null) {
                o = new Date().getTime()
                ;(0, s.log_trace)(`mouse down at page ${r}`)
                const h = windowToCanvas(c, t, i)
                e.preventDefault()
                const u = c.getBoundingClientRect()
                const p = e.view.PDFViewerApplicationOptions.get('annotConfig')
                if (p !== null) {
                  const g = {
                    author: p.author,
                    annotType: 1,
                    createDate: (0, a.formatDate)(new Date(), 'yyyy-MM-dd hh:mm:ss'),
                    scale: e.view.PDFViewerApplication.pdfViewer.scale,
                    canvasW: u.width,
                    canvasH: u.height,
                    page: r,
                    style: { strokeColor: p.strokeColor, fillColor: '', lineW: p.lineW },
                    position: { inkList: [h.x, h.y], rect: [] }
                  }
                  d.restoreSnapShot()
                  d.saveSnapShot()
                  document.curDrawAnnot = new BjcaAnnotInfo(g)
                } else (0, a.dispatchError)(parent.document, a.ErrorCode[2])
              } else
                e.button == 0
                  ? listenClickEvent()
                  : e.button == 2
                  ? implContextMenu(e)
                  : e.button == 1
                  ? (0, s.log_warn)('click annot with middle button pressing')
                  : (0, s.log_error)(`unknown button pressed, button = ${e.button}`)
            }
          }
        }
        document.onmousemove = function (e) {
          const t = document.getElementById('viewerContainer')
          t.style.cursor = 'default'
          const i = e.clientX
          const n = e.clientY
          if (!(n <= document.getElementById('toolbarViewer').offsetHeight)) {
            const s = decideMouseOnPage(e.view.PDFViewerApplication.pdfViewer, i, n)
            if (s != 0) {
              t.style.cursor = 'url("images/cursor-cross-25.cur") 12 12, default'
              if (
                void 0 !== document.curDrawAnnot &&
                document.curDrawAnnot !== null &&
                e.buttons === 1
              ) {
                const a = e.view.PDFViewerApplication.pdfViewer.getPageView(s - 1)
                const r = document.curDrawAnnot
                if (r.page === s) {
                  e.preventDefault()
                  const o = document.getElementById(`PageCanvas${s}`)
                  const l = windowToCanvas(o, i, n)
                  a.restoreSnapShot()
                  r.updatePos(l.x, l.y)
                  r.draw(o)
                }
              } else {
                isHoverAnnot(e, s) != null && (t.style.cursor = 'default')
              }
            }
          }
        }
        document.onmouseup = function (e) {
          const t = e.clientX
          const i = e.clientY
          if (
            !(i <= document.getElementById('toolbarViewer').offsetHeight) &&
            void 0 !== document.curDrawAnnot &&
            document.curDrawAnnot !== null
          ) {
            const a = decideMouseOnPage(e.view.PDFViewerApplication.pdfViewer, t, i)
            ;(0, s.log_trace)(`mouse up at page ${a}`)
            if (a != 0) {
              const r = e.view.PDFViewerApplication.pdfViewer.getPageView(a - 1)
              const c = document.curDrawAnnot
              if (c.page === a) {
                const d = (l = new Date().getTime()) - o
                const h = document.getElementById(`PageCanvas${a}`)
                const u = windowToCanvas(h, t, i)
                const p = (0, n.getDistance)(c.position.inkList[0], c.position.inkList[1], u.x, u.y)
                if (d <= 200 && p < 5) {
                  ;(0, s.log_trace)(`mouse down -> up time consume = ${l - o}`)
                  document.curDrawAnnot = null
                  r.restoreSnapShot()
                  l = 0
                  o = 0
                } else {
                  o = 0
                  l = 0
                  r.restoreSnapShot()
                  if (
                    void 0 !== document.focusAn &&
                    document.focusAn !== null &&
                    document.focusAn.page !== c.page
                  ) {
                    e.view.PDFViewerApplication.pdfViewer
                      .getPageView(document.focusAn.page - 1)
                      .restoreSnapShot()
                  }
                  c.updatePos(u.x, u.y)
                  c.draw(h)
                  r.addBjcaAnnotInfo(c)
                  document.curDrawAnnot = null
                  r.saveSnapShot()
                }
              } else {
                e.view.PDFViewerApplication.pdfViewer.getPageView(c.page - 1).restoreSnapShot()
              }
            }
          }
        }
      }
      t.stopListenDragEvent = function stopListenDragEvent() {
        document.onmousedown = null
        document.onmousemove = null
        document.onmouseup = null
      }
      var n = i(46)
      var s = i(36)
      var a = i(37)
      const r = i(1)
      var o = 0
      var l = 0
      function BjcaAnnotInfo(e) {
        this.author = e.author
        this.annotType = e.annotType
        this.createDate = e.createDate
        e.id == null || e.id == null || e.id.length == 0
          ? (this.id = (0, n.randomString)(32, '0123456789abcdef'))
          : (this.id = e.id)
        e.scale == null || e.scale == null || e.scale == 0
          ? (this.scale = 1)
          : (this.scale = e.scale)
        this.canvasW = e.canvasW
        this.canvasH = e.canvasH
        this.page = e.page
        this.style = e.style
        this.position = e.position
        this.position.rect = null
        this.status = 0
        this.text = e.text
        this.updatePos = function (e, t) {
          if (this.annotType === 1) {
            this.position.inkList[2] = e
            this.position.inkList[3] = t
          } else if (this.annotType === 2) {
            this.position.inkList.push(e)
            this.position.inkList.push(t)
          }
        }
        this.getLineRect = function (e, t) {
          let i = e
          i < -90 ? (i += 180) : i <= 0 ? (i = Math.abs(i)) : i > 90 && (i = 180 - i)
          let n
          let s
          let a
          let r
          const o = this.style.lineW / 2
          const l = Math.sin((i * Math.PI) / 180) * o
          const c = Math.cos((i * Math.PI) / 180) * o
          if (e < -90) {
            n = [t[0] + l, t[1] - c]
            s = [t[0] - l, t[1] + c]
            a = [t[2] - l, t[3] + c]
            r = [t[2] + l, t[3] - c]
          } else if (e < 0 && e >= -90) {
            n = [t[0] - l, t[1] - c]
            s = [t[0] + l, t[1] + c]
            a = [t[2] + l, t[3] + c]
            r = [t[2] - l, t[3] - c]
          } else if (e >= 0 && e < 90) {
            n = [t[0] - l, t[1] + c]
            s = [t[0] + l, t[1] - c]
            a = [t[2] + l, t[3] - c]
            r = [t[2] - l, t[3] + c]
          } else {
            n = [t[0] + l, t[1] + c]
            s = [t[0] - l, t[1] - c]
            a = [t[2] - l, t[3] - c]
            r = [t[2] + l, t[3] + c]
          }
          this.position.rect = [n, s, a, r]
          return this.position.rect
        }
        this.checkPointInRect = function (e, t, i, s, a) {
          i /= a
          s /= a
          let r = (0, n.isPointAtLeftOfLine)(e[0], e[1], i, s)
          return (
            !(r < 0 && ((t >= 0 && t < 90) || t < -90)) &&
            !(r > 0 && ((t < 0 && t >= -90) || t >= 90)) &&
            !(
              (r = (0, n.isPointAtLeftOfLine)(e[1], e[2], i, s)) < 0 &&
              ((t >= 0 && t < 90) || t < -90)
            ) &&
            !(r > 0 && ((t < 0 && t >= -90) || t >= 90)) &&
            !(
              (r = (0, n.isPointAtLeftOfLine)(e[2], e[3], i, s)) < 0 &&
              ((t >= 0 && t < 90) || t < -90)
            ) &&
            !(r > 0 && ((t < 0 && t >= -90) || t >= 90)) &&
            !(
              (r = (0, n.isPointAtLeftOfLine)(e[3], e[0], i, s)) < 0 &&
              ((t >= 0 && t < 90) || t < -90)
            ) &&
            !(r > 0 && ((t < 0 && t >= -90) || t >= 90))
          )
        }
        this.drawBorder = function (e) {
          ;(0, s.log_debug)('begin draw annot border')
          if (e == null) return
          const t = e.getContext('2d')
          const i = e.getBoundingClientRect().width / this.canvasW
          t.save()
          const a = (0, r.getOutputScale)(t)
          t.scale(i * a.sx, i * a.sy)
          if (this.position.rect == null) {
            const o = this.position.inkList
            const l = (0, n.getAngle)(o[0], o[1], o[2], o[3])
            this.getLineRect(l, o)
          }
          t.setLineDash([3, 3])
          t.beginPath()
          t.lineWidth = 2
          t.moveTo(this.position.rect[0][0], this.position.rect[0][1])
          t.lineTo(this.position.rect[1][0], this.position.rect[1][1])
          t.moveTo(this.position.rect[1][0], this.position.rect[1][1])
          t.lineTo(this.position.rect[2][0], this.position.rect[2][1])
          t.moveTo(this.position.rect[2][0], this.position.rect[2][1])
          t.lineTo(this.position.rect[3][0], this.position.rect[3][1])
          t.moveTo(this.position.rect[3][0], this.position.rect[3][1])
          t.lineTo(this.position.rect[0][0], this.position.rect[0][1])
          t.strokeStyle = 'rgba(65, 140, 252, 1)'
          t.stroke()
          t.restore()
        }
        this.isOnAnnot = function (e, t, i, a) {
          if (this.page !== t) return !1
          if (this.annotType == 1) {
            var r = 0
            var o = e.getBoundingClientRect().width / this.canvasW
            var l = this.position.inkList
            r = (0, n.getAngle)(l[0], l[1], l[2], l[3])
            this.getLineRect(r, l)
            if (this.position.rect == null) {
              ;(0, s.log_error)('compute annot rect failed')
              return !1
            }
            return this.checkPointInRect(this.position.rect, r, i, a, o)
          }
          if (this.annotType == 2) {
            ;(r = 0),
              (o = e.getBoundingClientRect().width / this.canvasW),
              (l = this.position.inkList)
            for (let c = 0; c < l.length / 4; ++c) {
              const d = l[4 * c + 1] - this.style.lineW / 2
              const h = l[4 * c + 3] + this.style.lineW / 2
              const u = [l[0], d, l[2], h]
              const p = i / o
              const g = a / o
              if (p >= u[0] && p <= u[2] && g >= d && g <= h) return !0
            }
            return !1
          }
          throw new Error('not supported bjca annot type')
        }
        this.draw = function (e) {
          if (this.annotType === 1 || this.annotType == 2) return this.drawLine(e)
          ;(0, s.log_error)('not supported annot type')
        }
        this.drawLine = function (e) {
          const t = e.getContext('2d')
          const i = e.getBoundingClientRect().width / this.canvasW
          t.save()
          const n = (0, r.getOutputScale)(t)
          t.scale(i * n.sx, i * n.sy)
          t.strokeStyle = this.style.strokeColor
          t.lineWidth = this.style.lineW
          if (this.annotType == 1) {
            t.beginPath()
            t.moveTo(this.position.inkList[0], this.position.inkList[1])
            t.lineTo(this.position.inkList[2], this.position.inkList[3])
            t.stroke()
          } else if (this.annotType == 2)
            for (let a = 0; a < this.position.inkList.length / 4; ++a) {
              t.closePath()
              t.beginPath()
              const o = [this.position.inkList[4 * a], this.position.inkList[4 * a + 1]]
              const l = [this.position.inkList[4 * a + 2], this.position.inkList[4 * a + 3]]
              t.moveTo(o[0], o[1])
              ;(0, s.log_debug)(`moveTo:[${o[0]} ${o[1]}]`)
              t.lineTo(l[0], l[1])
              ;(0, s.log_debug)(`lineTo:[${l[0]} ${l[1]}]`)
              t.stroke()
            }
          t.restore()
        }
      }
      function windowToCanvas(e, t, i) {
        const n = e.getBoundingClientRect()
        return { x: t - n.left, y: i - n.top }
      }
      function decideMouseOnPage(e, t, i) {
        for (var n = 0, s = 0; s < e._pages.length; ++s) {
          const a = document.getElementById(`PageCanvas${s + 1}`)
          if (a != null) {
            const r = a.getBoundingClientRect()
            if (t <= r.right && t >= r.left && i <= r.bottom && i >= r.top) {
              n = s + 1
              break
            }
          }
        }
        return n
      }
      function implContextMenu(e) {
        const t = (e = e || window.event).clientX
        const i = e.clientY
        if (i <= document.getElementById('toolbarViewer').offsetHeight) return !0
        const n = e.view.PDFViewerApplication.pdfViewer
        const s = decideMouseOnPage(n, t, i)
        if (s == 0) return !0
        let a = 1
        const r = isHoverAnnot(e, s)
        if (r == null) {
          if (!(window.getSelection().toString().length > 0)) return !0
          a = 2
        } else {
          n.getPageView(s - 1).rightClickedAnnot = r.id
        }
        !(function showContextMenu(e, t) {
          const i = document.getElementById('bjca_menu')
          i.style.display = 'block'
          if (t == 1) {
            document.getElementById('bjca_highlight').style.display = 'none'
            document.getElementById('bjca_delete').style.display = 'block'
          } else if (t == 2) {
            document.getElementById('bjca_delete').style.display = 'none'
            document.getElementById('bjca_highlight').style.display = 'block'
          }
          let n = e.clientX
          let s = e.clientY
          const a = document.documentElement.clientWidth || document.body.clientWidth
          const r = document.documentElement.clientHeight || document.body.clientHeight
          n >= a - i.offsetWidth && (n = a - i.offsetWidth)
          s > r - i.offsetHeight && (s = r - i.offsetHeight)
          i.style.left = `${n}px`
          i.style.top = `${s}px`
          const o = window.getSelection()
          if (o.toString().length > 0) {
            i.sel = {}
            i.sel.selectionRects = o.getRangeAt(0).getClientRects()
            i.sel.selectionTexts = o.toString()
          }
        })(e, a)
        return !1
      }
      function listenClickEvent() {
        document.onclick = function (e) {
          const t = e.clientX
          const i = e.clientY
          document.getElementById('bjca_menu').style.display = 'none'
          e.target.id !== '' && (0, s.log_debug)(`click = ${e.target.id}`)
          if (!(i <= document.getElementById('toolbarViewer').offsetHeight)) {
            const n = e.view.PDFViewerApplication.pdfViewer
            const r = decideMouseOnPage(n, t, i)
            if (r != 0)
              for (
                let o = document.getElementById(`PageCanvas${r}`),
                  l = windowToCanvas(o, t, i),
                  c = n.getPageView(r - 1),
                  d = 0;
                d < c.anInfoArray.length;
                ++d
              ) {
                const h = c.anInfoArray[d]
                if (h.isOnAnnot(o, r, l.x, l.y)) {
                  ;(0, s.log_debug)(`click annot id:${h.id}`)
                  c.restoreSnapShot()
                  if (
                    void 0 !== document.focusAn &&
                    document.focusAn !== null &&
                    document.focusAn.page !== h.page
                  ) {
                    e.view.PDFViewerApplication.pdfViewer
                      .getPageView(document.focusAn.page - 1)
                      .restoreSnapShot()
                  }
                  c.focusBjcaAnnot(h)
                  ;(0, a.dispatchCustomEvent)(
                    'clickBjcaAnnot',
                    { id: h.id, pageNumber: h.page },
                    parent.document
                  )
                  break
                }
              }
          }
        }
        document.ondblclick = function (e) {
          ;(0, s.log_debug)('double click on document')
        }
        document.oncontextmenu = function (e) {
          return implContextMenu(e)
        }
        bjca_menu.addEventListener('click', function (e) {
          e = e || window.event
          ;(0, s.log_debug)(`click = ${e.target.id}`)
          e.stopPropagation()
          bjca_menu.style.display = 'none'
          if (e.target.id == 'bjca_delete')
            !(function deleteAnnot(e) {
              const t = e.clientX
              const i = e.clientY
              const n = decideMouseOnPage(e.view.PDFViewerApplication.pdfViewer, t, i)
              if (n == 0) return
              const s = e.view.PDFViewerApplication.pdfViewer.getPageView(n - 1)
              if (s.rightClickedAnnot == null) return
              const a = s.lookupBjcaAnnot(s.rightClickedAnnot)
              s.rightClickedAnnot = null
              if (a === -1) return
              s.deleteBjcaAnnotInfo(a)
              s.restoreInitPageSnapShot()
              s.redrawPageAnnot()
              s.redrawSignture()
              s.saveSnapShot()
            })(e)
          else if (e.target.id == 'bjca_highlight') {
            e.sel = bjca_menu.sel
            addHighlightAnnot(e)
          }
        })
      }
      function isHoverAnnot(e, t) {
        const i = document.getElementById(`PageCanvas${t}`)
        if (i == null) return null
        for (
          let n = windowToCanvas(i, e.clientX, e.clientY),
            s = e.view.PDFViewerApplication.pdfViewer.getPageView(t - 1),
            a = 0;
          a < s.anInfoArray.length;
          ++a
        ) {
          const r = s.anInfoArray[a]
          if (r.isOnAnnot(i, t, n.x, n.y)) return r
        }
        return null
      }
      function addHighlightAnnot(e) {
        const t = e.view.PDFViewerApplication.pdfViewer.currentPageNumber
        if (t == 0) return !1
        let i = window.getSelection().getRangeAt(0).getClientRects()
        let n = window.getSelection().toString()
        if (i.length === 0) {
          i = e.sel.selectionRects
          n = e.sel.selectionTexts
        }
        const r = Object.values(i)
        const o = document.getElementById(`PageCanvas${t}`)
        const l = e.view.PDFViewerApplication.pdfViewer.getPageView(t - 1)
        ;(0, s.log_trace)(`text selection at page ${t}`)
        const c = o.getBoundingClientRect()
        const d = e.view.PDFViewerApplicationOptions.get('annotConfig')
        if (d === null) {
          ;(0, a.dispatchError)(parent.document, a.ErrorCode[2])
          return !1
        }
        const h = {
          author: d.author,
          annotType: 2,
          createDate: (0, a.formatDate)(new Date(), 'yyyy-MM-dd hh:mm:ss'),
          scale: e.view.PDFViewerApplication.pdfViewer.scale,
          canvasW: c.width,
          canvasH: c.height,
          page: t,
          style: { strokeColor: d.strokeColor, fillColor: '', lineW: d.lineW },
          text: n,
          position: { inkList: [], rect: [] }
        }
        let u = 0
        let p = null
        r.forEach(function (e) {
          const t = e.bottom - e.top
          const i = e.top + t / 2 - c.top
          t > u && (u = t)
          ;(0,
          s.log_debug)(`rect height = ${t}, rect = [${e.left} ${e.top} ${e.right} ${e.bottom}]`)
          const n = e.left - c.left
          const a = e.right - c.left
          h.position.inkList.length > 0 &&
            (p = [
              h.position.inkList[h.position.inkList.length - 2],
              h.position.inkList[h.position.inkList.length - 1]
            ])
          if (p !== null && Math.abs(p[1] - i) < 2)
            h.position.inkList.splice(h.position.inkList.length - 2, 1, a)
          else {
            h.position.inkList.push(n)
            h.position.inkList.push(i)
            h.position.inkList.push(a)
            h.position.inkList.push(i)
          }
        })
        for (let g = 0; g < h.position.inkList.length / 4; ++g) {
          const f = h.position.inkList[4 * g]
          const m = h.position.inkList[4 * g + 2]
          const v = h.position.inkList[4 * g + 1]
          ;(0, s.log_debug)(`line width = ${u}, line = [${f} ${v} ${m} ${v}]`)
        }
        h.style.lineW = u
        document.curDrawAnnot = new BjcaAnnotInfo(h)
        document.curDrawAnnot.draw(o)
        l.saveSnapShot()
        l.addBjcaAnnotInfo(document.curDrawAnnot)
        return !0
      }
    },
    (e, t) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.getAngle = function getAngle(e, t, i, n) {
        const s = i - e
        const a = n - t
        if (!s && !a) return 0
        return Math.atan2(a, s) * (180 / Math.PI)
      }
      t.getDistance = function getDistance(e, t, i, n) {
        const s = { x: e, y: t }
        const a = { x: i, y: n }
        return Math.sqrt(dist2(s, a))
      }
      t.isPointAtLeftOfLine = function isPointAtLeftOfLine(e, t, i, n) {
        return (t[0] - e[0]) * (n - e[1]) - (i - e[0]) * (t[1] - e[1])
      }
      t.isPointOnElement = function isPointOnElement(e, t) {
        const i = t.getBoundingClientRect()
        return (function isPointInRect(e, t) {
          return e.x <= t.right && e.x >= t.left && e.y <= t.bottom && e.y >= t.top
        })(e, i)
      }
      t.randomString = function randomString(e, t) {
        for (var i = '', n = e; n > 0; --n) i += t[Math.floor(Math.random() * t.length)]
        return i
      }
      function sqr(e) {
        return e * e
      }
      function dist2(e, t) {
        return sqr(e.x - t.x) + sqr(e.y - t.y)
      }
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.drawWaterMark = function drawWaterMark(e, t) {
        const i = e.canvas
        ;(0, s.log_info)(`current page scale = ${e.scale}`)
        const a = i.getContext('2d')
        a.save()
        const r = (0, n.getOutputScale)(a)
        a.scale(r.sx * e.scale, r.sy * e.scale)
        let o = t.fontSize
        o += 'px '
        o += t.fontName
        a.font = o
        a.textBaseline = 'bottom'
        const l = `${t.text} ${t.time}`
        const c = i.getBoundingClientRect()
        const d = (Math.abs(t.rotation) * Math.PI) / 180
        const h = Math.cos(Math.abs(d))
        const u = Math.tan(Math.abs(d))
        const p = a.measureText(l).width + t.dash
        const g = t.fontSize + t.lineGap
        const f = Math.ceil((c.width / h - t.startX) / p)
        const m = Math.ceil((c.height / h - t.startY) / g)
        a.rotate(-d)
        a.fillStyle = t.color
        for (let v = 0; v < m; v++)
          for (let _ = t.startY + v * g, b = 0; b < f; b++) {
            const w = -t.startX + _ * u
            a.fillText(l, b * p - w, _)
          }
        a.rotate(d)
        a.restore()
        return !0
      }
      var n = i(1)
      var s = i(36)
    },
    (e, t) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.git_version = t.compile_time = void 0
      t.git_version = '2.16.105-a5460d62364c89c318247e526711a2daa1a41711'
      t.compile_time = '2022.10.13 17:28:55.69'
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.GenericCom = void 0
      const n = i(4)
      const s = i(50)
      const a = i(51)
      const r = i(52)
      const o = i(54)
      t.GenericCom = {}
      class GenericPreferences extends s.BasePreferences {
        async _writeToStorage(e) {
          localStorage.setItem('pdfjs.preferences', JSON.stringify(e))
        }

        async _readFromStorage(e) {
          return JSON.parse(localStorage.getItem('pdfjs.preferences'))
        }
      }
      class GenericExternalServices extends n.DefaultExternalServices {
        static createDownloadManager(e) {
          return new a.DownloadManager()
        }

        static createPreferences() {
          return new GenericPreferences()
        }

        static createL10n(e) {
          const { locale: t = 'en-US' } = e
          return new r.GenericL10n(t)
        }

        static createScripting(e) {
          const { sandboxBundleSrc: t } = e
          return new o.GenericScripting(t)
        }
      }
      n.PDFViewerApplication.externalServices = GenericExternalServices
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.BasePreferences = void 0
      i(2)
      function _classPrivateFieldInitSpec(e, t, i) {
        !(function _checkPrivateRedeclaration(e, t) {
          if (t.has(e))
            throw new TypeError('Cannot initialize the same private elements twice on an object')
        })(e, t)
        t.set(e, i)
      }
      function _classPrivateFieldGet(e, t) {
        return (function _classApplyDescriptorGet(e, t) {
          if (t.get) return t.get.call(e)
          return t.value
        })(e, _classExtractFieldDescriptor(e, t, 'get'))
      }
      function _classPrivateFieldSet(e, t, i) {
        !(function _classApplyDescriptorSet(e, t, i) {
          if (t.set) t.set.call(e, i)
          else {
            if (!t.writable) throw new TypeError('attempted to set read only private field')
            t.value = i
          }
        })(e, _classExtractFieldDescriptor(e, t, 'set'), i)
        return i
      }
      function _classExtractFieldDescriptor(e, t, i) {
        if (!t.has(e)) throw new TypeError(`attempted to ${i} private field on non-instance`)
        return t.get(e)
      }
      const n = new WeakMap()
      const s = new WeakMap()
      const a = new WeakMap()
      class BasePreferences {
        constructor() {
          _classPrivateFieldInitSpec(this, n, {
            writable: !0,
            value: Object.freeze({
              annotationEditorMode: -1,
              annotationMode: 2,
              cursorToolOnLoad: 0,
              defaultZoomValue: '100',
              disablePageLabels: !1,
              enablePermissions: !1,
              enablePrintAutoRotate: !0,
              enableScripting: !0,
              externalLinkTarget: 0,
              historyUpdateUrl: !1,
              ignoreDestinationZoom: !1,
              forcePageColors: !1,
              pageColorsBackground: 'Canvas',
              pageColorsForeground: 'CanvasText',
              pdfBugEnabled: !0,
              sidebarViewOnLoad: 1,
              scrollModeOnLoad: 0,
              spreadModeOnLoad: -1,
              textLayerMode: 1,
              useOnlyCssZoom: !1,
              viewerCssTheme: 0,
              viewOnLoad: 0,
              disableAutoFetch: !1,
              disableFontFace: !1,
              disableRange: !1,
              disableStream: !1,
              enableXfa: !0,
              renderer: 'canvas'
            })
          })
          _classPrivateFieldInitSpec(this, s, { writable: !0, value: Object.create(null) })
          _classPrivateFieldInitSpec(this, a, { writable: !0, value: null })
          if (this.constructor === BasePreferences)
            throw new Error('Cannot initialize BasePreferences.')
          _classPrivateFieldSet(
            this,
            a,
            this._readFromStorage(_classPrivateFieldGet(this, n)).then((e) => {
              for (const t in _classPrivateFieldGet(this, n)) {
                const i = e == null ? void 0 : e[t]
                typeof i === typeof _classPrivateFieldGet(this, n)[t] &&
                  (_classPrivateFieldGet(this, s)[t] = i)
              }
            })
          )
        }

        async _writeToStorage(e) {
          throw new Error('Not implemented: _writeToStorage')
        }

        async _readFromStorage(e) {
          throw new Error('Not implemented: _readFromStorage')
        }

        async reset() {
          await _classPrivateFieldGet(this, a)
          const e = _classPrivateFieldGet(this, s)
          _classPrivateFieldSet(this, s, Object.create(null))
          return this._writeToStorage(_classPrivateFieldGet(this, n)).catch((t) => {
            _classPrivateFieldSet(this, s, e)
            throw t
          })
        }

        async set(e, t) {
          await _classPrivateFieldGet(this, a)
          const i = _classPrivateFieldGet(this, n)[e]
          const r = _classPrivateFieldGet(this, s)
          if (void 0 === i) throw new Error(`Set preference: "${e}" is undefined.`)
          if (void 0 === t) throw new Error('Set preference: no value is specified.')
          const o = typeof t
          const l = typeof i
          if (o !== l) {
            if (o !== 'number' || l !== 'string')
              throw new Error(`Set preference: "${t}" is a ${o}, expected a ${l}.`)
            t = t.toString()
          } else if (o === 'number' && !Number.isInteger(t))
            throw new Error(`Set preference: "${t}" must be an integer.`)
          _classPrivateFieldGet(this, s)[e] = t
          return this._writeToStorage(_classPrivateFieldGet(this, s)).catch((e) => {
            _classPrivateFieldSet(this, s, r)
            throw e
          })
        }

        async get(e) {
          let t
          await _classPrivateFieldGet(this, a)
          const i = _classPrivateFieldGet(this, n)[e]
          if (void 0 === i) throw new Error(`Get preference: "${e}" is undefined.`)
          return (t = _classPrivateFieldGet(this, s)[e]) !== null && void 0 !== t ? t : i
        }

        async getAll() {
          await _classPrivateFieldGet(this, a)
          const e = Object.create(null)
          for (const i in _classPrivateFieldGet(this, n)) {
            var t
            e[i] =
              (t = _classPrivateFieldGet(this, s)[i]) !== null && void 0 !== t
                ? t
                : _classPrivateFieldGet(this, n)[i]
          }
          return e
        }
      }
      t.BasePreferences = BasePreferences
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.DownloadManager = void 0
      const n = i(5)
      function download(e, t) {
        const i = document.createElement('a')
        if (!i.click) throw new Error('DownloadManager: "a.click()" is not supported.')
        i.href = e
        i.target = '_parent'
        'download' in i && (i.download = t)
        ;(document.body || document.documentElement).append(i)
        i.click()
        i.remove()
      }
      t.DownloadManager = class DownloadManager {
        constructor() {
          this._openBlobUrls = new WeakMap()
        }

        downloadUrl(e, t) {
          ;(0, n.createValidAbsoluteUrl)(e, 'http://example.com')
            ? download(`${e}#pdfjs.action=download`, t)
            : console.error(`downloadUrl - not a valid URL: ${e}`)
        }

        downloadData(e, t, i) {
          download(URL.createObjectURL(new Blob([e], { type: i })), t)
        }

        openOrDownloadData(e, t, i) {
          const s = (0, n.isPdfFile)(i)
          const a = s ? 'application/pdf' : ''
          if (s) {
            let n
            let s = this._openBlobUrls.get(e)
            if (!s) {
              s = URL.createObjectURL(new Blob([t], { type: a }))
              this._openBlobUrls.set(e, s)
            }
            n = `?file=${encodeURIComponent(`${s}#${i}`)}`
            try {
              window.open(n)
              return !0
            } catch (t) {
              console.error(`openOrDownloadData: ${t}`)
              URL.revokeObjectURL(s)
              this._openBlobUrls.delete(e)
            }
          }
          this.downloadData(t, i, a)
          return !1
        }

        download(e, t, i) {
          download(URL.createObjectURL(e), i)
        }
      }
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.GenericL10n = void 0
      i(53)
      const n = i(32)
      const s = document.webL10n
      t.GenericL10n = class GenericL10n {
        constructor(e) {
          this._lang = e
          this._ready = new Promise((t, i) => {
            s.setLanguage((0, n.fixupLangCode)(e), () => {
              t(s)
            })
          })
        }

        async getLanguage() {
          return (await this._ready).getLanguage()
        }

        async getDirection() {
          return (await this._ready).getDirection()
        }

        async get(e) {
          const t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
          const i =
            arguments.length > 2 && void 0 !== arguments[2]
              ? arguments[2]
              : (0, n.getL10nFallback)(e, t)
          return (await this._ready).get(e, t, i)
        }

        async translate(e) {
          return (await this._ready).translate(e)
        }
      }
    },
    () => {
      document.webL10n = (function (e, t, i) {
        let n = {}
        let s = ''
        const a = 'textContent'
        let r = ''
        const o = {}
        let l = 'loading'
        function xhrLoadText(e, t, i) {
          t = t || function _onSuccess(e) {}
          i = i || function _onFailure() {}
          const n = new XMLHttpRequest()
          n.open('GET', e, true)
          n.overrideMimeType && n.overrideMimeType('text/plain; charset=utf-8')
          n.onreadystatechange = function () {
            n.readyState == 4 && (n.status == 200 || n.status === 0 ? t(n.responseText) : i())
          }
          n.onerror = i
          n.ontimeout = i
          try {
            n.send(null)
          } catch (e) {
            i()
          }
        }
        function parseResource(e, t, i, r) {
          const o = e.replace(/[^\/]*$/, '') || './'
          function evalString(e) {
            return e.lastIndexOf('\\') < 0
              ? e
              : e
                  .replace(/\\\\/g, '\\')
                  .replace(/\\n/g, '\n')
                  .replace(/\\r/g, '\r')
                  .replace(/\\t/g, '\t')
                  .replace(/\\b/g, '\b')
                  .replace(/\\f/g, '\f')
                  .replace(/\\{/g, '{')
                  .replace(/\\}/g, '}')
                  .replace(/\\"/g, '"')
                  .replace(/\\'/g, "'")
          }
          xhrLoadText(
            e,
            function (e) {
              s += e
              !(function parseProperties(e, i) {
                const n = {}
                const s = /^\s*|\s*$/
                const a = /^\s*#|^\s*$/
                const r = /^\s*\[(.*)\]\s*$/
                const l = /^\s*@import\s+url\((.*)\)\s*$/i
                const c = /^([^=\s]*)\s*=\s*(.+)$/
                function parseRawLines(e, i, d) {
                  const h = e.replace(s, '').split(/[\r\n]+/)
                  let u = '*'
                  const p = t.split('-', 1)[0]
                  let g = !1
                  let f = ''
                  !(function nextEntry() {
                    for (;;) {
                      if (!h.length) {
                        d()
                        return
                      }
                      const e = h.shift()
                      if (!a.test(e)) {
                        if (i) {
                          if ((f = r.exec(e))) {
                            u = f[1].toLowerCase()
                            g = u !== '*' && u !== t && u !== p
                            continue
                          }
                          if (g) continue
                          if ((f = l.exec(e))) {
                            loadImport(o + f[1], nextEntry)
                            return
                          }
                        }
                        const s = e.match(c)
                        s && s.length == 3 && (n[s[1]] = evalString(s[2]))
                      }
                    }
                  })()
                }
                function loadImport(e, t) {
                  xhrLoadText(
                    e,
                    function (e) {
                      parseRawLines(e, !1, t)
                    },
                    function () {
                      console.warn(`${e} not found.`)
                      t()
                    }
                  )
                }
                parseRawLines(e, !0, function () {
                  i(n)
                })
              })(e, function (e) {
                for (const t in e) {
                  var s
                  var r
                  const o = t.lastIndexOf('.')
                  if (o > 0) {
                    s = t.substring(0, o)
                    r = t.substring(o + 1)
                  } else {
                    s = t
                    r = a
                  }
                  n[s] || (n[s] = {})
                  n[s][r] = e[t]
                }
                i && i()
              })
            },
            r
          )
        }
        function loadLocale(e, i) {
          e && (e = e.toLowerCase())
          i = i || function _callback() {}
          !(function clear() {
            n = {}
            s = ''
            r = ''
          })()
          r = e
          const a = (function getL10nResourceLinks() {
            return t.querySelectorAll('link[type="application/l10n"]')
          })()
          const o = a.length
          if (o !== 0) {
            let c
            let d = 0
            c = function () {
              if (++d >= o) {
                i()
                l = 'complete'
              }
            }
            for (let h = 0; h < o; h++) {
              new L10nResourceLink(a[h]).load(e, c)
            }
          } else {
            const u = (function getL10nDictionary() {
              const e = t.querySelector('script[type="application/l10n"]')
              return e ? JSON.parse(e.innerHTML) : null
            })()
            if (u && u.locales && u.default_locale) {
              console.log('using the embedded JSON directory, early way out')
              if (!(n = u.locales[e])) {
                const p = u.default_locale.toLowerCase()
                for (let g in u.locales) {
                  if ((g = g.toLowerCase()) === e) {
                    n = u.locales[e]
                    break
                  }
                  g === p && (n = u.locales[p])
                }
              }
              i()
            } else console.log('no resource to load, early way out')
            l = 'complete'
          }
          function L10nResourceLink(e) {
            const t = e.href
            this.load = function (e, i) {
              parseResource(t, e, i, function () {
                console.warn(`${t} not found.`)
                console.warn(`"${e}" resource not found`)
                r = ''
                i()
              })
            }
          }
        }
        o.plural = function (e, t, i, s) {
          const l = parseFloat(t)
          if (isNaN(l)) return e
          if (s != a) return e
          o._pluralRules ||
            (o._pluralRules = (function getPluralRules(e) {
              function isIn(e, t) {
                return t.indexOf(e) !== -1
              }
              function isBetween(e, t, i) {
                return t <= e && e <= i
              }
              const t = {
                0(e) {
                  return 'other'
                },
                1(e) {
                  return isBetween(e % 100, 3, 10)
                    ? 'few'
                    : e === 0
                    ? 'zero'
                    : isBetween(e % 100, 11, 99)
                    ? 'many'
                    : e == 2
                    ? 'two'
                    : e == 1
                    ? 'one'
                    : 'other'
                },
                2(e) {
                  return e !== 0 && e % 10 == 0 ? 'many' : e == 2 ? 'two' : e == 1 ? 'one' : 'other'
                },
                3(e) {
                  return e == 1 ? 'one' : 'other'
                },
                4(e) {
                  return isBetween(e, 0, 1) ? 'one' : 'other'
                },
                5(e) {
                  return isBetween(e, 0, 2) && e != 2 ? 'one' : 'other'
                },
                6(e) {
                  return e === 0 ? 'zero' : e % 10 == 1 && e % 100 != 11 ? 'one' : 'other'
                },
                7(e) {
                  return e == 2 ? 'two' : e == 1 ? 'one' : 'other'
                },
                8(e) {
                  return isBetween(e, 3, 6)
                    ? 'few'
                    : isBetween(e, 7, 10)
                    ? 'many'
                    : e == 2
                    ? 'two'
                    : e == 1
                    ? 'one'
                    : 'other'
                },
                9(e) {
                  return e === 0 || (e != 1 && isBetween(e % 100, 1, 19))
                    ? 'few'
                    : e == 1
                    ? 'one'
                    : 'other'
                },
                10(e) {
                  return isBetween(e % 10, 2, 9) && !isBetween(e % 100, 11, 19)
                    ? 'few'
                    : e % 10 != 1 || isBetween(e % 100, 11, 19)
                    ? 'other'
                    : 'one'
                },
                11(e) {
                  return isBetween(e % 10, 2, 4) && !isBetween(e % 100, 12, 14)
                    ? 'few'
                    : e % 10 == 0 || isBetween(e % 10, 5, 9) || isBetween(e % 100, 11, 14)
                    ? 'many'
                    : e % 10 == 1 && e % 100 != 11
                    ? 'one'
                    : 'other'
                },
                12(e) {
                  return isBetween(e, 2, 4) ? 'few' : e == 1 ? 'one' : 'other'
                },
                13(e) {
                  return isBetween(e % 10, 2, 4) && !isBetween(e % 100, 12, 14)
                    ? 'few'
                    : (e != 1 && isBetween(e % 10, 0, 1)) ||
                      isBetween(e % 10, 5, 9) ||
                      isBetween(e % 100, 12, 14)
                    ? 'many'
                    : e == 1
                    ? 'one'
                    : 'other'
                },
                14(e) {
                  return isBetween(e % 100, 3, 4)
                    ? 'few'
                    : e % 100 == 2
                    ? 'two'
                    : e % 100 == 1
                    ? 'one'
                    : 'other'
                },
                15(e) {
                  return e === 0 || isBetween(e % 100, 2, 10)
                    ? 'few'
                    : isBetween(e % 100, 11, 19)
                    ? 'many'
                    : e == 1
                    ? 'one'
                    : 'other'
                },
                16(e) {
                  return e % 10 == 1 && e != 11 ? 'one' : 'other'
                },
                17(e) {
                  return e == 3
                    ? 'few'
                    : e === 0
                    ? 'zero'
                    : e == 6
                    ? 'many'
                    : e == 2
                    ? 'two'
                    : e == 1
                    ? 'one'
                    : 'other'
                },
                18(e) {
                  return e === 0
                    ? 'zero'
                    : isBetween(e, 0, 2) && e !== 0 && e != 2
                    ? 'one'
                    : 'other'
                },
                19(e) {
                  return isBetween(e, 2, 10) ? 'few' : isBetween(e, 0, 1) ? 'one' : 'other'
                },
                20(e) {
                  return (!isBetween(e % 10, 3, 4) && e % 10 != 9) ||
                    isBetween(e % 100, 10, 19) ||
                    isBetween(e % 100, 70, 79) ||
                    isBetween(e % 100, 90, 99)
                    ? e % 1e6 == 0 && e !== 0
                      ? 'many'
                      : e % 10 != 2 || isIn(e % 100, [12, 72, 92])
                      ? e % 10 != 1 || isIn(e % 100, [11, 71, 91])
                        ? 'other'
                        : 'one'
                      : 'two'
                    : 'few'
                },
                21(e) {
                  return e === 0 ? 'zero' : e == 1 ? 'one' : 'other'
                },
                22(e) {
                  return isBetween(e, 0, 1) || isBetween(e, 11, 99) ? 'one' : 'other'
                },
                23(e) {
                  return isBetween(e % 10, 1, 2) || e % 20 == 0 ? 'one' : 'other'
                },
                24(e) {
                  return isBetween(e, 3, 10) || isBetween(e, 13, 19)
                    ? 'few'
                    : isIn(e, [2, 12])
                    ? 'two'
                    : isIn(e, [1, 11])
                    ? 'one'
                    : 'other'
                }
              }
              const i = {
                af: 3,
                ak: 4,
                am: 4,
                ar: 1,
                asa: 3,
                az: 0,
                be: 11,
                bem: 3,
                bez: 3,
                bg: 3,
                bh: 4,
                bm: 0,
                bn: 3,
                bo: 0,
                br: 20,
                brx: 3,
                bs: 11,
                ca: 3,
                cgg: 3,
                chr: 3,
                cs: 12,
                cy: 17,
                da: 3,
                de: 3,
                dv: 3,
                dz: 0,
                ee: 3,
                el: 3,
                en: 3,
                eo: 3,
                es: 3,
                et: 3,
                eu: 3,
                fa: 0,
                ff: 5,
                fi: 3,
                fil: 4,
                fo: 3,
                fr: 5,
                fur: 3,
                fy: 3,
                ga: 8,
                gd: 24,
                gl: 3,
                gsw: 3,
                gu: 3,
                guw: 4,
                gv: 23,
                ha: 3,
                haw: 3,
                he: 2,
                hi: 4,
                hr: 11,
                hu: 0,
                id: 0,
                ig: 0,
                ii: 0,
                is: 3,
                it: 3,
                iu: 7,
                ja: 0,
                jmc: 3,
                jv: 0,
                ka: 0,
                kab: 5,
                kaj: 3,
                kcg: 3,
                kde: 0,
                kea: 0,
                kk: 3,
                kl: 3,
                km: 0,
                kn: 0,
                ko: 0,
                ksb: 3,
                ksh: 21,
                ku: 3,
                kw: 7,
                lag: 18,
                lb: 3,
                lg: 3,
                ln: 4,
                lo: 0,
                lt: 10,
                lv: 6,
                mas: 3,
                mg: 4,
                mk: 16,
                ml: 3,
                mn: 3,
                mo: 9,
                mr: 3,
                ms: 0,
                mt: 15,
                my: 0,
                nah: 3,
                naq: 7,
                nb: 3,
                nd: 3,
                ne: 3,
                nl: 3,
                nn: 3,
                no: 3,
                nr: 3,
                nso: 4,
                ny: 3,
                nyn: 3,
                om: 3,
                or: 3,
                pa: 3,
                pap: 3,
                pl: 13,
                ps: 3,
                pt: 3,
                rm: 3,
                ro: 9,
                rof: 3,
                ru: 11,
                rwk: 3,
                sah: 0,
                saq: 3,
                se: 7,
                seh: 3,
                ses: 0,
                sg: 0,
                sh: 11,
                shi: 19,
                sk: 12,
                sl: 14,
                sma: 7,
                smi: 7,
                smj: 7,
                smn: 7,
                sms: 7,
                sn: 3,
                so: 3,
                sq: 3,
                sr: 11,
                ss: 3,
                ssy: 3,
                st: 3,
                sv: 3,
                sw: 3,
                syr: 3,
                ta: 3,
                te: 3,
                teo: 3,
                th: 0,
                ti: 4,
                tig: 3,
                tk: 3,
                tl: 4,
                tn: 3,
                to: 0,
                tr: 0,
                ts: 3,
                tzm: 22,
                uk: 11,
                ur: 3,
                ve: 3,
                vi: 0,
                vun: 3,
                wa: 4,
                wae: 3,
                wo: 0,
                xh: 3,
                xog: 3,
                yo: 0,
                zh: 0,
                zu: 3
              }[e.replace(/-.*$/, '')]
              if (!(i in t)) {
                console.warn(`plural form unknown for [${e}]`)
                return function () {
                  return 'other'
                }
              }
              return t[i]
            })(r))
          const c = `[${o._pluralRules(l)}]`
          l === 0 && `${i}[zero]` in n
            ? (e = n[`${i}[zero]`][s])
            : l == 1 && `${i}[one]` in n
            ? (e = n[`${i}[one]`][s])
            : l == 2 && `${i}[two]` in n
            ? (e = n[`${i}[two]`][s])
            : i + c in n
            ? (e = n[i + c][s])
            : `${i}[other]` in n && (e = n[`${i}[other]`][s])
          return e
        }
        function getL10nData(e, t, i) {
          let s = n[e]
          if (!s) {
            console.warn(`#${e} is undefined.`)
            if (!i) return null
            s = i
          }
          const a = {}
          for (const r in s) {
            let o = s[r]
            o = substArguments((o = substIndexes(o, t, e, r)), t, e)
            a[r] = o
          }
          return a
        }
        function substIndexes(e, t, i, s) {
          const a = /\{\[\s*([a-zA-Z]+)\(([a-zA-Z]+)\)\s*\]\}/.exec(e)
          if (!a || !a.length) return e
          let r
          const l = a[1]
          const c = a[2]
          t && c in t ? (r = t[c]) : c in n && (r = n[c])
          if (l in o) {
            e = (0, o[l])(e, r, i, s)
          }
          return e
        }
        function substArguments(e, t, i) {
          return e.replace(/\{\{\s*(.+?)\s*\}\}/g, function (e, s) {
            if (t && s in t) return t[s]
            if (s in n) return n[s]
            console.log(`argument {{${s}}} for #${i} is undefined.`)
            return e
          })
        }
        function translateElement(e) {
          const i = (function getL10nAttributes(e) {
            if (!e) return {}
            const t = e.getAttribute('data-l10n-id')
            const i = e.getAttribute('data-l10n-args')
            let n = {}
            if (i)
              try {
                n = JSON.parse(i)
              } catch (e) {
                console.warn(`could not parse arguments for #${t}`)
              }
            return { id: t, args: n }
          })(e)
          if (i.id) {
            const n = getL10nData(i.id, i.args)
            if (n) {
              if (n[a]) {
                if (
                  (function getChildElementCount(e) {
                    if (e.children) return e.children.length
                    if (void 0 !== e.childElementCount) return e.childElementCount
                    for (var t = 0, i = 0; i < e.childNodes.length; i++)
                      t += e.nodeType === 1 ? 1 : 0
                    return t
                  })(e) === 0
                )
                  e[a] = n[a]
                else {
                  for (var s = e.childNodes, r = !1, o = 0, l = s.length; o < l; o++)
                    if (s[o].nodeType === 3 && /\S/.test(s[o].nodeValue))
                      if (r) s[o].nodeValue = ''
                      else {
                        s[o].nodeValue = n[a]
                        r = !0
                      }
                  if (!r) {
                    const c = t.createTextNode(n[a])
                    e.prepend(c)
                  }
                }
                delete n[a]
              }
              for (const d in n) e[d] = n[d]
            } else console.warn(`#${i.id} is undefined.`)
          }
        }
        return {
          get(e, t, i) {
            let n
            const s = e.lastIndexOf('.')
            let r = a
            if (s > 0) {
              r = e.substring(s + 1)
              e = e.substring(0, s)
            }
            i && ((n = {})[r] = i)
            const o = getL10nData(e, t, n)
            return o && r in o ? o[r] : `{{${e}}}`
          },
          getData() {
            return n
          },
          getText() {
            return s
          },
          getLanguage() {
            return r
          },
          setLanguage(e, t) {
            loadLocale(e, function () {
              t && t()
            })
          },
          getDirection() {
            const e = r.split('-', 1)[0]
            return ['ar', 'he', 'fa', 'ps', 'ur'].indexOf(e) >= 0 ? 'rtl' : 'ltr'
          },
          translate: function translateFragment(e) {
            for (
              let i = (function getTranslatableChildren(e) {
                  return e ? e.querySelectorAll('*[data-l10n-id]') : []
                })((e = e || t.documentElement)),
                n = i.length,
                s = 0;
              s < n;
              s++
            )
              translateElement(i[s])
            translateElement(e)
          },
          getReadyState() {
            return l
          },
          ready(i) {
            i &&
              (l == 'complete' || l == 'interactive'
                ? e.setTimeout(function () {
                    i()
                  })
                : t.addEventListener &&
                  t.addEventListener('localized', function once() {
                    t.removeEventListener('localized', once)
                    i()
                  }))
          }
        }
      })(window, document)
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.GenericScripting = void 0
      t.docPropertiesLookup = async function docPropertiesLookup(e) {
        const t = ''.split('#')[0]
        let {
          info: i,
          metadata: s,
          contentDispositionFilename: a,
          contentLength: r
        } = await e.getMetadata()
        if (!r) {
          const { length: t } = await e.getDownloadInfo()
          r = t
        }
        return {
          ...i,
          baseURL: t,
          filesize: r,
          filename: a || (0, n.getPdfFilenameFromUrl)(''),
          metadata: s == null ? void 0 : s.getRaw(),
          authors: s == null ? void 0 : s.get('dc:creator'),
          numPages: e.numPages,
          URL: ''
        }
      }
      var n = i(5)
      t.GenericScripting = class GenericScripting {
        constructor(e) {
          this._ready = (0, n.loadScript)(e, !0).then(() => window.pdfjsSandbox.QuickJSSandbox())
        }

        async createSandbox(e) {
          ;(await this._ready).create(e)
        }

        async dispatchEventInSandbox(e) {
          const t = await this._ready
          setTimeout(() => t.dispatchEvent(e), 0)
        }

        async destroySandbox() {
          ;(await this._ready).nukeSandbox()
        }
      }
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.PDFPrintService = PDFPrintService
      const n = i(5)
      const s = i(4)
      const a = i(56)
      let r = null
      let o = null
      let l = null
      function PDFPrintService(e, t, i, n) {
        const s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null
        const a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null
        const r = arguments.length > 6 ? arguments[6] : void 0
        this.pdfDocument = e
        this.pagesOverview = t
        this.printContainer = i
        this._printResolution = n || 150
        this._optionalContentConfigPromise = s || e.getOptionalContentConfig()
        this._printAnnotationStoragePromise = a || Promise.resolve()
        this.l10n = r
        this.currentPage = -1
        this.scratchCanvas = document.createElement('canvas')
      }
      PDFPrintService.prototype = {
        layout() {
          this.throwIfInactive()
          const e = document.querySelector('body')
          e.setAttribute('data-pdfjsprinting', !0)
          this.pagesOverview.every(function (e) {
            return (
              e.width === this.pagesOverview[0].width && e.height === this.pagesOverview[0].height
            )
          }, this) ||
            console.warn('Not all pages have the same size. The printed result may be incorrect!')
          this.pageStyleSheet = document.createElement('style')
          const t = this.pagesOverview[0]
          this.pageStyleSheet.textContent = `@page { size: ${t.width}pt ${t.height}pt;}`
          e.append(this.pageStyleSheet)
        },
        destroy() {
          if (r !== this) return
          this.printContainer.textContent = ''
          document.querySelector('body').removeAttribute('data-pdfjsprinting')
          if (this.pageStyleSheet) {
            this.pageStyleSheet.remove()
            this.pageStyleSheet = null
          }
          this.scratchCanvas.width = this.scratchCanvas.height = 0
          this.scratchCanvas = null
          r = null
          ensureOverlay().then(function () {
            l.active === o && l.close(o)
          })
        },
        renderPages() {
          if (this.pdfDocument.isPureXfa) {
            ;(0, a.getXfaHtmlForPrinting)(this.printContainer, this.pdfDocument)
            return Promise.resolve()
          }
          const e = this.pagesOverview.length
          const renderNextPage = (t, i) => {
            this.throwIfInactive()
            if (++this.currentPage >= e) {
              renderProgress(e, e, this.l10n)
              t()
              return
            }
            const s = this.currentPage
            renderProgress(s, e, this.l10n)
            ;(function renderPage(e, t, i, s, a, o, l) {
              const c = r.scratchCanvas
              const d = a / n.PixelsPerInch.PDF
              c.width = Math.floor(s.width * d)
              c.height = Math.floor(s.height * d)
              const h = c.getContext('2d')
              h.save()
              h.fillStyle = 'rgb(255, 255, 255)'
              h.fillRect(0, 0, c.width, c.height)
              h.restore()
              return Promise.all([t.getPage(i), l]).then(function (e) {
                const [t, i] = e
                const a = {
                  canvasContext: h,
                  transform: [d, 0, 0, d, 0, 0],
                  viewport: t.getViewport({ scale: 1, rotation: s.rotation }),
                  intent: 'print',
                  annotationMode: n.AnnotationMode.ENABLE_STORAGE,
                  optionalContentConfigPromise: o,
                  printAnnotationStorage: i
                }
                return t.render(a).promise
              })
            })(
              0,
              this.pdfDocument,
              s + 1,
              this.pagesOverview[s],
              this._printResolution,
              this._optionalContentConfigPromise,
              this._printAnnotationStoragePromise
            )
              .then(this.useRenderedPage.bind(this))
              .then(function () {
                renderNextPage(t, i)
              }, i)
          }
          return new Promise(renderNextPage)
        },
        useRenderedPage() {
          this.throwIfInactive()
          const e = document.createElement('img')
          const t = this.scratchCanvas
          'toBlob' in t
            ? t.toBlob(function (t) {
                e.src = URL.createObjectURL(t)
              })
            : (e.src = t.toDataURL())
          const i = document.createElement('div')
          i.className = 'printedPage'
          i.append(e)
          this.printContainer.append(i)
          return new Promise(function (t, i) {
            e.onload = t
            e.onerror = i
          })
        },
        performPrint() {
          this.throwIfInactive()
          return new Promise((e) => {
            setTimeout(() => {
              if (this.active) {
                c.call(window)
                setTimeout(e, 20)
              } else e()
            }, 0)
          })
        },
        get active() {
          return this === r
        },
        throwIfInactive() {
          if (!this.active) throw new Error('This print request was cancelled or completed.')
        }
      }
      const c = window.print
      window.print = function () {
        if (r) console.warn('Ignored window.print() because of a pending print job.')
        else {
          ensureOverlay().then(function () {
            r && l.open(o)
          })
          try {
            dispatchEvent('beforeprint')
          } finally {
            if (!r) {
              console.error('Expected print service to be initialized.')
              ensureOverlay().then(function () {
                l.active === o && l.close(o)
              })
              return
            }
            const e = r
            r.renderPages()
              .then(function () {
                return e.performPrint()
              })
              .catch(function () {})
              .then(function () {
                e.active && abort()
              })
          }
        }
      }
      function dispatchEvent(e) {
        const t = document.createEvent('CustomEvent')
        t.initCustomEvent(e, !1, !1, 'custom')
        window.dispatchEvent(t)
      }
      function abort() {
        if (r) {
          r.destroy()
          dispatchEvent('afterprint')
        }
      }
      function renderProgress(e, t, i) {
        o || (o = document.getElementById('printServiceDialog'))
        const n = Math.round((100 * e) / t)
        const s = o.querySelector('progress')
        const a = o.querySelector('.relative-progress')
        s.value = n
        i.get('print_progress_percent', { progress: n }).then((e) => {
          a.textContent = e
        })
      }
      window.addEventListener(
        'keydown',
        function (e) {
          if (
            e.keyCode === 80 &&
            (e.ctrlKey || e.metaKey) &&
            !e.altKey &&
            (!e.shiftKey || window.chrome || window.opera)
          ) {
            window.print()
            e.preventDefault()
            e.stopImmediatePropagation ? e.stopImmediatePropagation() : e.stopPropagation()
          }
        },
        !0
      )
      if ('onbeforeprint' in window) {
        const stopPropagationIfNeeded = function (e) {
          e.detail !== 'custom' && e.stopImmediatePropagation && e.stopImmediatePropagation()
        }
        window.addEventListener('beforeprint', stopPropagationIfNeeded)
        window.addEventListener('afterprint', stopPropagationIfNeeded)
      }
      let d
      function ensureOverlay() {
        if (!d) {
          l = s.PDFViewerApplication.overlayManager
          if (!l) throw new Error('The overlay manager has not yet been initialized.')
          o || (o = document.getElementById('printServiceDialog'))
          d = l.register(o, !0)
          document.getElementById('printCancel').onclick = abort
          o.addEventListener('close', abort)
        }
        return d
      }
      s.PDFPrintServiceFactory.instance = {
        supportsPrinting: !0,
        createPrintService(e, t, i, n, s, a, o) {
          if (r) throw new Error('The print service is created and active.')
          r = new PDFPrintService(e, t, i, n, s, a, o)
          return r
        }
      }
    },
    (e, t, i) => {
      Object.defineProperty(t, '__esModule', { value: !0 })
      t.getXfaHtmlForPrinting = function getXfaHtmlForPrinting(e, t) {
        const i = t.allXfaHtml
        const r = new s.SimpleLinkService()
        const o = Math.round(100 * n.PixelsPerInch.PDF_TO_CSS_UNITS) / 100
        for (const s of i.children) {
          const i = document.createElement('div')
          i.className = 'xfaPrintedPage'
          e.append(i)
          const l = new a.XfaLayerBuilder({
            pageDiv: i,
            pdfPage: null,
            annotationStorage: t.annotationStorage,
            linkService: r,
            xfaHtml: s
          })
          const c = (0, n.getXfaPageViewport)(s, { scale: o })
          l.render(c, 'print')
        }
      }
      var n = i(5)
      var s = i(3)
      var a = i(41)
    }
  ]
  const t = {}
  function __webpack_require__(i) {
    const n = t[i]
    if (void 0 !== n) return n.exports
    const s = (t[i] = { exports: {} })
    e[i](s, s.exports, __webpack_require__)
    return s.exports
  }
  const i = {}
  ;(() => {
    const e = i
    Object.defineProperty(e, '__esModule', { value: !0 })
    Object.defineProperty(e, 'PDFViewerApplication', {
      enumerable: !0,
      get() {
        return o.PDFViewerApplication
      }
    })
    e.PDFViewerApplicationConstants = void 0
    Object.defineProperty(e, 'PDFViewerApplicationOptions', {
      enumerable: !0,
      get() {
        return a.AppOptions
      }
    })
    let t
    let n
    const s = __webpack_require__(1)
    var a = __webpack_require__(2)
    const r = __webpack_require__(3)
    var o = __webpack_require__(4)
    const l = __webpack_require__(36)
    const c = __webpack_require__(37)
    const d = {
      LinkTarget: r.LinkTarget,
      RenderingStates: s.RenderingStates,
      ScrollMode: s.ScrollMode,
      SpreadMode: s.SpreadMode
    }
    e.PDFViewerApplicationConstants = d
    window.PDFViewerApplication = o.PDFViewerApplication
    window.PDFViewerApplicationConstants = d
    window.PDFViewerApplicationOptions = a.AppOptions
    __webpack_require__(49)
    __webpack_require__(55)
    function webViewerLoad() {
      console.debug('begin load web viewer')
      const e = (function getViewerConfiguration() {
        console.debug('begin get web viewer config')
        let e = null
        e = {
          container: document.getElementById('errorWrapper'),
          errorMessage: document.getElementById('errorMessage'),
          closeButton: document.getElementById('errorClose'),
          errorMoreInfo: document.getElementById('errorMoreInfo'),
          moreInfoButton: document.getElementById('errorShowMore'),
          lessInfoButton: document.getElementById('errorShowLess')
        }
        return {
          appContainer: document.body,
          mainContainer: document.getElementById('viewerContainer'),
          viewerContainer: document.getElementById('viewer'),
          toolbar: {
            container: document.getElementById('toolbarViewer'),
            numPages: document.getElementById('numPages'),
            pageNumber: document.getElementById('pageNumber'),
            scaleSelect: document.getElementById('scaleSelect'),
            customScaleOption: document.getElementById('customScaleOption'),
            previous: document.getElementById('previous'),
            next: document.getElementById('next'),
            zoomIn: document.getElementById('zoomIn'),
            zoomOut: document.getElementById('zoomOut'),
            viewFind: document.getElementById('viewFind'),
            openFile: document.getElementById('openFile'),
            print: document.getElementById('print'),
            lineAnnot: document.getElementById('lineAnnot'),
            selectTool: document.getElementById('selectTool'),
            editorFreeTextButton: document.getElementById('editorFreeText'),
            editorFreeTextParamsToolbar: document.getElementById('editorFreeTextParamsToolbar'),
            editorInkButton: document.getElementById('editorInk'),
            editorInkParamsToolbar: document.getElementById('editorInkParamsToolbar'),
            presentationModeButton: document.getElementById('presentationMode'),
            download: document.getElementById('download'),
            viewBookmark: document.getElementById('viewBookmark')
          },
          secondaryToolbar: {
            toolbar: document.getElementById('secondaryToolbar'),
            toggleButton: document.getElementById('secondaryToolbarToggle'),
            presentationModeButton: document.getElementById('secondaryPresentationMode'),
            openFileButton: document.getElementById('secondaryOpenFile'),
            printButton: document.getElementById('secondaryPrint'),
            downloadButton: document.getElementById('secondaryDownload'),
            viewBookmarkButton: document.getElementById('secondaryViewBookmark'),
            firstPageButton: document.getElementById('firstPage'),
            lastPageButton: document.getElementById('lastPage'),
            pageRotateCwButton: document.getElementById('pageRotateCw'),
            pageRotateCcwButton: document.getElementById('pageRotateCcw'),
            cursorSelectToolButton: document.getElementById('cursorSelectTool'),
            cursorHandToolButton: document.getElementById('cursorHandTool'),
            scrollPageButton: document.getElementById('scrollPage'),
            scrollVerticalButton: document.getElementById('scrollVertical'),
            scrollHorizontalButton: document.getElementById('scrollHorizontal'),
            scrollWrappedButton: document.getElementById('scrollWrapped'),
            spreadNoneButton: document.getElementById('spreadNone'),
            spreadOddButton: document.getElementById('spreadOdd'),
            spreadEvenButton: document.getElementById('spreadEven'),
            documentPropertiesButton: document.getElementById('documentProperties')
          },
          sidebar: {
            outerContainer: document.getElementById('outerContainer'),
            sidebarContainer: document.getElementById('sidebarContainer'),
            toggleButton: document.getElementById('sidebarToggle'),
            thumbnailButton: document.getElementById('viewThumbnail'),
            outlineButton: document.getElementById('viewOutline'),
            attachmentsButton: document.getElementById('viewAttachments'),
            layersButton: document.getElementById('viewLayers'),
            thumbnailView: document.getElementById('thumbnailView'),
            outlineView: document.getElementById('outlineView'),
            attachmentsView: document.getElementById('attachmentsView'),
            layersView: document.getElementById('layersView'),
            outlineOptionsContainer: document.getElementById('outlineOptionsContainer'),
            currentOutlineItemButton: document.getElementById('currentOutlineItem')
          },
          sidebarResizer: {
            outerContainer: document.getElementById('outerContainer'),
            resizer: document.getElementById('sidebarResizer')
          },
          findBar: {
            bar: document.getElementById('findbar'),
            toggleButton: document.getElementById('viewFind'),
            findField: document.getElementById('findInput'),
            highlightAllCheckbox: document.getElementById('findHighlightAll'),
            caseSensitiveCheckbox: document.getElementById('findMatchCase'),
            matchDiacriticsCheckbox: document.getElementById('findMatchDiacritics'),
            entireWordCheckbox: document.getElementById('findEntireWord'),
            findMsg: document.getElementById('findMsg'),
            findResultsCount: document.getElementById('findResultsCount'),
            findPreviousButton: document.getElementById('findPrevious'),
            findNextButton: document.getElementById('findNext')
          },
          passwordOverlay: {
            dialog: document.getElementById('passwordDialog'),
            label: document.getElementById('passwordText'),
            input: document.getElementById('password'),
            submitButton: document.getElementById('passwordSubmit'),
            cancelButton: document.getElementById('passwordCancel')
          },
          documentProperties: {
            dialog: document.getElementById('documentPropertiesDialog'),
            closeButton: document.getElementById('documentPropertiesClose'),
            fields: {
              fileName: document.getElementById('fileNameField'),
              fileSize: document.getElementById('fileSizeField'),
              title: document.getElementById('titleField'),
              author: document.getElementById('authorField'),
              subject: document.getElementById('subjectField'),
              keywords: document.getElementById('keywordsField'),
              creationDate: document.getElementById('creationDateField'),
              modificationDate: document.getElementById('modificationDateField'),
              creator: document.getElementById('creatorField'),
              producer: document.getElementById('producerField'),
              version: document.getElementById('versionField'),
              pageCount: document.getElementById('pageCountField'),
              pageSize: document.getElementById('pageSizeField'),
              linearized: document.getElementById('linearizedField')
            }
          },
          annotationEditorParams: {
            editorFreeTextFontSize: document.getElementById('editorFreeTextFontSize'),
            editorFreeTextColor: document.getElementById('editorFreeTextColor'),
            editorInkColor: document.getElementById('editorInkColor'),
            editorInkThickness: document.getElementById('editorInkThickness'),
            editorInkOpacity: document.getElementById('editorInkOpacity')
          },
          errorWrapper: e,
          printContainer: document.getElementById('printContainer'),
          openFileInput: document.getElementById('fileInput'),
          debuggerScriptPath: './debugger.js'
        }
      })()
      const t = document.createEvent('CustomEvent')
      t.initCustomEvent('webviewerloaded', !0, !0, { source: window })
      try {
        ;(0, c.dispatchCustomEvent)('webviewerloaded', {}, parent.document)
      } catch (e) {
        console.error(`webviewerloaded: ${e}`)
        document.dispatchEvent(t)
      }
      let i = a.AppOptions.get('LogLevel')
      i == null && (i = 3)
      ;(0, l.setLogLevel)(i)
      i >= 4 && (0, l.log_warn)('log level is debug at production')
      o.PDFViewerApplication.run(e)
    }
    ;(t = (n = document).blockUnblockOnload) === null || void 0 === t || t.call(n, !0)
    document.readyState === 'interactive' || document.readyState === 'complete'
      ? webViewerLoad()
      : document.addEventListener('DOMContentLoaded', webViewerLoad, !0)
  })()
})()
